   1               		.file	"SerialExample.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
 134               	.global	getCommandsTcb
 135               		.section	.progmem.data,"a",@progbits
 138               	getCommandsTcb:
 139 0000 0000      		.word	getCommandsStk+134
 140 0002 0000      		.word	pm(getCommands)
 141 0004 0000      		.word	getCommandsPid
 142 0006 01        		.byte	1
 143               	.global	getUAVStatusTcb
 146               	getUAVStatusTcb:
 147 0007 0000      		.word	getUAVStatusStk+110
 148 0009 0000      		.word	pm(getUAVStatus)
 149 000b 0000      		.word	getUAVStatusPid
 150 000d 04        		.byte	4
 151               	.global	leftServoPos
 152               		.data
 155               	leftServoPos:
 156 0000 3200      		.word	50
 157               		.text
 159               	.global	parserInit
 161               	parserInit:
 162               		.stabd	46,0,0
 164               	.Ltext1:
   1:parser.c      **** #include <avr/io.h>			// include I/O definitions (port names, pin names, etc)
   2:parser.c      **** #include <avr/interrupt.h>	// include interrupt support
   3:parser.c      **** #include <avr/pgmspace.h>	// include AVR program memory support
   4:parser.c      **** #include <string.h>			// include standard C string functions
   5:parser.c      **** #include <stdlib.h>			// include stdlib for string conversion functions
   6:parser.c      **** 
   7:parser.c      **** 
   8:parser.c      **** #include "parser.h"
   9:parser.c      **** #include "parserconf.h"
  10:parser.c      **** 
  11:parser.c      **** 
  12:parser.c      **** 
  13:parser.c      **** // command list
  14:parser.c      **** char CommandList[MAX_COMMANDS][MAX_CMD_LENGTH];
  15:parser.c      **** // command function pointer list
  16:parser.c      **** ParserFuncPtrType ParserFunctionList[MAX_COMMANDS];
  17:parser.c      **** // number of commands currently registered
  18:parser.c      **** unsigned char parserNumCommands;
  19:parser.c      **** //current length of input buffer
  20:parser.c      **** unsigned char parserBufferLength;
  21:parser.c      **** //buffer into which commands are written as they come through
  22:parser.c      **** unsigned char parserBuffer[BUFFERSIZE];
  23:parser.c      **** 
  24:parser.c      **** ParserFuncPtrType ParserExecFunction;
  25:parser.c      **** 
  26:parser.c      **** // function pointer to single character output routine
  27:parser.c      **** void (*parserOutputFunc)(unsigned char c);
  28:parser.c      **** 
  29:parser.c      **** 
  30:parser.c      **** void parserInit(void)
  31:parser.c      **** {
 166               	.LM0:
 167               	/* prologue: frame size=0 */
 168               	/* prologue end (size=0) */
  32:parser.c      **** 	// initialize input buffer
  33:parser.c      **** 	parserBufferLength = 0;
 170               	.LM1:
 171 0000 1092 0000 		sts parserBufferLength,__zero_reg__
  34:parser.c      **** 	// initialize executing function
  35:parser.c      **** 	ParserExecFunction = 0;
 173               	.LM2:
 174 0004 1092 0000 		sts (ParserExecFunction)+1,__zero_reg__
 175 0008 1092 0000 		sts ParserExecFunction,__zero_reg__
  36:parser.c      **** 	// initialize command list
  37:parser.c      **** 	parserNumCommands = 0;
 177               	.LM3:
 178 000c 1092 0000 		sts parserNumCommands,__zero_reg__
 179               	/* epilogue: frame size=0 */
 180 0010 0895      		ret
 181               	/* epilogue end (size=1) */
 182               	/* function parserInit size 9 (8) */
 184               	.Lscope0:
 186               		.stabd	78,0,0
 190               	.global	parserAddCommand
 192               	parserAddCommand:
 193               		.stabd	46,0,0
  38:parser.c      **** }
  39:parser.c      **** 
  40:parser.c      **** 
  41:parser.c      **** void parserAddCommand(unsigned char* newCmdString, ParserFuncPtrType newCmdFuncPtr)
  42:parser.c      **** {
 195               	.LM4:
 196               	/* prologue: frame size=0 */
 197 0012 0F93      		push r16
 198 0014 1F93      		push r17
 199               	/* prologue end (size=2) */
 200 0016 AC01      		movw r20,r24
 201 0018 8B01      		movw r16,r22
  43:parser.c      **** 	// add command string to end of command list
  44:parser.c      **** 	strcpy(CommandList[parserNumCommands], newCmdString);
 203               	.LM5:
 204 001a 8091 0000 		lds r24,parserNumCommands
 205 001e 2FE0      		ldi r18,lo8(15)
 206 0020 829F      		mul r24,r18
 207 0022 C001      		movw r24,r0
 208 0024 1124      		clr r1
 209 0026 BA01      		movw r22,r20
 210 0028 8050      		subi r24,lo8(-(CommandList))
 211 002a 9040      		sbci r25,hi8(-(CommandList))
 212 002c 0E94 0000 		call strcpy
  45:parser.c      **** 	// add command function ptr to end of function list
  46:parser.c      **** 	ParserFunctionList[parserNumCommands] = newCmdFuncPtr;
 214               	.LM6:
 215 0030 8091 0000 		lds r24,parserNumCommands
 216 0034 E82F      		mov r30,r24
 217 0036 FF27      		clr r31
 218 0038 EE0F      		lsl r30
 219 003a FF1F      		rol r31
 220 003c E050      		subi r30,lo8(-(ParserFunctionList))
 221 003e F040      		sbci r31,hi8(-(ParserFunctionList))
 222 0040 1183      		std Z+1,r17
 223 0042 0083      		st Z,r16
  47:parser.c      **** 	// increment number of registered commands
  48:parser.c      **** 	parserNumCommands++;
 225               	.LM7:
 226 0044 8F5F      		subi r24,lo8(-(1))
 227 0046 8093 0000 		sts parserNumCommands,r24
 228               	/* epilogue: frame size=0 */
 229 004a 1F91      		pop r17
 230 004c 0F91      		pop r16
 231 004e 0895      		ret
 232               	/* epilogue end (size=3) */
 233               	/* function parserAddCommand size 31 (26) */
 235               	.Lscope1:
 237               		.stabd	78,0,0
 240               	.global	parserSetOutputFunc
 242               	parserSetOutputFunc:
 243               		.stabd	46,0,0
  49:parser.c      **** }
  50:parser.c      **** 
  51:parser.c      **** 
  52:parser.c      **** void parserSetOutputFunc(void (*output_func)(unsigned char c))
  53:parser.c      **** {
 245               	.LM8:
 246               	/* prologue: frame size=0 */
 247               	/* prologue end (size=0) */
  54:parser.c      **** 	// set new output function
  55:parser.c      **** 	parserOutputFunc = output_func;
 249               	.LM9:
 250 0050 9093 0000 		sts (parserOutputFunc)+1,r25
 251 0054 8093 0000 		sts parserOutputFunc,r24
 252               	/* epilogue: frame size=0 */
 253 0058 0895      		ret
 254               	/* epilogue end (size=1) */
 255               	/* function parserSetOutputFunc size 5 (4) */
 257               	.Lscope2:
 259               		.stabd	78,0,0
 261               	.global	parserProcessInputString
 263               	parserProcessInputString:
 264               		.stabd	46,0,0
  56:parser.c      **** }
  57:parser.c      **** 
  58:parser.c      **** 
  59:parser.c      **** void parserInputFunc(unsigned char c)
  60:parser.c      **** {
  61:parser.c      **** 	// process the received character
  62:parser.c      **** 	
  63:parser.c      **** 	if (c != '\r')		//anything other than return character must be a part of the command
  64:parser.c      **** 	{	
  65:parser.c      **** 		// echo character to the output
  66:parser.c      **** //		parserOutputFunc(c);
  67:parser.c      **** 		// add it to the command line buffer
  68:parser.c      **** 		parserBuffer[parserBufferLength] = c;
  69:parser.c      **** 		// update buffer length
  70:parser.c      **** 		parserBufferLength++;
  71:parser.c      **** 	}
  72:parser.c      **** 	else				//return character -> process command
  73:parser.c      **** 	{
  74:parser.c      **** 		// add null termination to command
  75:parser.c      **** 		parserBuffer[parserBufferLength] = 0;
  76:parser.c      **** 		// command is complete, process it
  77:parser.c      **** 		parserProcessInputString();
  78:parser.c      **** 		// reset buffer
  79:parser.c      **** 		parserBufferLength = 0;
  80:parser.c      **** 	}
  81:parser.c      **** }
  82:parser.c      **** 
  83:parser.c      **** 
  84:parser.c      **** void parserProcessInputString(void)
  85:parser.c      **** {
 266               	.LM10:
 267               	/* prologue: frame size=0 */
 268 005a CF93      		push r28
 269 005c DF93      		push r29
 270               	/* prologue end (size=2) */
 271 005e C0E0      		ldi r28,lo8(0)
 272 0060 D0E0      		ldi r29,hi8(0)
 273 0062 22C0      		rjmp .L8
 274               	.L9:
  86:parser.c      **** 	unsigned char cmdIndex;
  87:parser.c      **** 
  88:parser.c      **** 	// search command list for match with entered command
  89:parser.c      **** 	for(cmdIndex=0; cmdIndex<parserNumCommands; cmdIndex++)
  90:parser.c      **** 	{
  91:parser.c      **** 		if( !strncmp(CommandList[cmdIndex], parserBuffer, 1) )		//command is first char of buffer
 276               	.LM11:
 277 0064 AE2F      		mov r26,r30
 278 0066 BB27      		clr r27
 279 0068 8FE0      		ldi r24,lo8(15)
 280 006a 90E0      		ldi r25,hi8(15)
 281 006c A89F      		mul r26,r24
 282 006e F001      		movw r30,r0
 283 0070 A99F      		mul r26,r25
 284 0072 F00D      		add r31,r0
 285 0074 B89F      		mul r27,r24
 286 0076 F00D      		add r31,r0
 287 0078 1124      		clr r1
 288 007a E050      		subi r30,lo8(-(CommandList))
 289 007c F040      		sbci r31,hi8(-(CommandList))
 290 007e 9081      		ld r25,Z
 291 0080 8091 0000 		lds r24,parserBuffer
 292 0084 9817      		cp r25,r24
 293 0086 79F4      		brne .L10
  92:parser.c      **** 		{
  93:parser.c      **** 			// user-entered command matched a command in the list (database)
  94:parser.c      **** 			ParserExecFunction = ParserFunctionList[cmdIndex];
 295               	.LM12:
 296 0088 AA0F      		lsl r26
 297 008a BB1F      		rol r27
 298 008c A050      		subi r26,lo8(-(ParserFunctionList))
 299 008e B040      		sbci r27,hi8(-(ParserFunctionList))
 300 0090 ED91      		ld r30,X+
 301 0092 FC91      		ld r31,X
 302 0094 F093 0000 		sts (ParserExecFunction)+1,r31
 303 0098 E093 0000 		sts ParserExecFunction,r30
  95:parser.c      **** 			// run the corresponding function
  96:parser.c      **** 			ParserExecFunction();
 305               	.LM13:
 306 009c 0995      		icall
  97:parser.c      **** 			// reset
  98:parser.c      **** 			ParserExecFunction = 0;
 308               	.LM14:
 309 009e 1092 0000 		sts (ParserExecFunction)+1,__zero_reg__
 310 00a2 1092 0000 		sts ParserExecFunction,__zero_reg__
 311               	.L10:
 312 00a6 2196      		adiw r28,1
 313               	.L8:
 314 00a8 EC2F      		mov r30,r28
 316               	.LM15:
 317 00aa 8091 0000 		lds r24,parserNumCommands
 318 00ae C817      		cp r28,r24
 319 00b0 C8F2      		brlo .L9
 320               	/* epilogue: frame size=0 */
 321 00b2 DF91      		pop r29
 322 00b4 CF91      		pop r28
 323 00b6 0895      		ret
 324               	/* epilogue end (size=3) */
 325               	/* function parserProcessInputString size 47 (42) */
 330               	.Lscope3:
 332               		.stabd	78,0,0
 335               	.global	parserInputFunc
 337               	parserInputFunc:
 338               		.stabd	46,0,0
 340               	.LM16:
 341               	/* prologue: frame size=0 */
 342               	/* prologue end (size=0) */
 343 00b8 9091 0000 		lds r25,parserBufferLength
 345               	.LM17:
 346 00bc 8D30      		cpi r24,lo8(13)
 347 00be 49F0      		breq .L15
 349               	.LM18:
 350 00c0 E92F      		mov r30,r25
 351 00c2 FF27      		clr r31
 352 00c4 E050      		subi r30,lo8(-(parserBuffer))
 353 00c6 F040      		sbci r31,hi8(-(parserBuffer))
 354 00c8 8083      		st Z,r24
 356               	.LM19:
 357 00ca 9F5F      		subi r25,lo8(-(1))
 358 00cc 9093 0000 		sts parserBufferLength,r25
 359 00d0 0895      		ret
 360               	.L15:
 362               	.LM20:
 363 00d2 E92F      		mov r30,r25
 364 00d4 FF27      		clr r31
 365 00d6 E050      		subi r30,lo8(-(parserBuffer))
 366 00d8 F040      		sbci r31,hi8(-(parserBuffer))
 367 00da 1082      		st Z,__zero_reg__
 369               	.LM21:
 370 00dc 0E94 0000 		call parserProcessInputString
 372               	.LM22:
 373 00e0 1092 0000 		sts parserBufferLength,__zero_reg__
 374 00e4 0895      		ret
 375               	/* epilogue: frame size=0 */
 376               	/* epilogue: noreturn */
 377               	/* epilogue end (size=0) */
 378               	/* function parserInputFunc size 23 (23) */
 380               	.Lscope4:
 382               		.stabd	78,0,0
 384               	.global	parserGetArgStr
 386               	parserGetArgStr:
 387               		.stabd	46,0,0
  99:parser.c      **** 		}
 100:parser.c      **** 	}
 101:parser.c      **** }
 102:parser.c      **** 
 103:parser.c      **** // return string pointer to argument [argnum]
 104:parser.c      **** unsigned char* parserGetArgStr(void)
 105:parser.c      **** {
 389               	.LM23:
 390               	/* prologue: frame size=0 */
 391               	/* prologue end (size=0) */
 106:parser.c      **** 	return &parserBuffer[2];		//spec states that commands are 1 char followed by a space followed by t
 107:parser.c      **** }									//arg must start at idx 2
 393               	.LM24:
 394 00e6 80E0      		ldi r24,lo8(parserBuffer+2)
 395 00e8 90E0      		ldi r25,hi8(parserBuffer+2)
 396               	/* epilogue: frame size=0 */
 397 00ea 0895      		ret
 398               	/* epilogue end (size=1) */
 399               	/* function parserGetArgStr size 3 (2) */
 401               	.Lscope5:
 403               		.stabd	78,0,0
 405               	.global	__vector_11
 407               	__vector_11:
 408               		.stabd	46,0,0
 410               	.Ltext2:
   1:SerialExample.c **** /*
   2:SerialExample.c ****     Serial interface Demo for AvrXFifo's
   3:SerialExample.c **** 
   4:SerialExample.c ****     Also illustrates the use of Frame based variables
   5:SerialExample.c ****     at the top level tasking (switched from NAKED to
   6:SerialExample.c ****     NORETURN function attribute)
   7:SerialExample.c **** 
   8:SerialExample.c **** 	When linked with simple serialio there is no buffering
   9:SerialExample.c **** 	of charactors so only two charactors can be received
  10:SerialExample.c **** 	during the delay (Hardware buffering within the USART).
  11:SerialExample.c **** 
  12:SerialExample.c **** 	When linked with the buffered IO up to 31 (or whatever
  13:SerialExample.c **** 	the buffer size - 1 is) charactors can be received while
  14:SerialExample.c **** 	delaying.
  15:SerialExample.c **** */
  16:SerialExample.c **** #include <avr/io.h>
  17:SerialExample.c **** #include <avr/pgmspace.h>
  18:SerialExample.c **** #include <avrx-signal.h>
  19:SerialExample.c **** #include <stdio.h>
  20:SerialExample.c **** #include "avrx.h"
  21:SerialExample.c **** #include <avr/signal.h>	// include "signal" names (interrupt names)
  22:SerialExample.c **** #include <avr/interrupt.h>	// include interrupt support
  23:SerialExample.c **** #include <stdlib.h>
  24:SerialExample.c **** 
  25:SerialExample.c **** // Uncomment this to override "AvrXSerialIo.h and just use one channel
  26:SerialExample.c **** //#define USART_CHANNELS (1<1)	// 0 - USART0, 1 = USART1
  27:SerialExample.c **** 
  28:SerialExample.c **** #include "AvrXSerialIo.h"
  29:SerialExample.c **** 
  30:SerialExample.c **** #include "parserconf.h"
  31:SerialExample.c **** #include "parser.h"
  32:SerialExample.c **** #include "parser.c"
  33:SerialExample.c **** 
  34:SerialExample.c **** 
  35:SerialExample.c **** // global AVRLIB defines
  36:SerialExample.c **** //#include "../../avrlibdefs.h"
  37:SerialExample.c **** //#include <avrlibdefs.h>
  38:SerialExample.c **** // global AVRLIB types definitions
  39:SerialExample.c **** //#include "../../avrlibtypes.h"
  40:SerialExample.c **** //#include <avrlibdefs.h>
  41:SerialExample.c **** 
  42:SerialExample.c **** #include "global.h"
  43:SerialExample.c **** 
  44:SerialExample.c **** //#include "timer.h"
  45:SerialExample.c **** ///#include "timer.c"
  46:SerialExample.c **** //#include "servo.h"
  47:SerialExample.c **** //#include "servo.c"
  48:SerialExample.c **** /*
  49:SerialExample.c **** enum
  50:SerialExample.c **** {
  51:SerialExample.c **** 	FALSE,
  52:SerialExample.c **** 	TRUE
  53:SerialExample.c **** };
  54:SerialExample.c **** 
  55:SerialExample.c **** typedef unsigned char BOOL;
  56:SerialExample.c **** */
  57:SerialExample.c **** 
  58:SerialExample.c **** // Peripheral initialization
  59:SerialExample.c **** 
  60:SerialExample.c **** #define TCNT0_INIT (0xFF-CPUCLK/256/TICKRATE)
  61:SerialExample.c **** #define LEFT_SERVO_CHAN 	0
  62:SerialExample.c **** #define RIGHT_SERVO_CHAN 	1
  63:SerialExample.c **** #define THROTTLE_SERVO_CHAN 2
  64:SerialExample.c **** #define CAM_PAN_SERVO_CHAN  3
  65:SerialExample.c **** #define CAM_TILT_SERVO_CHAN 4
  66:SerialExample.c **** 
  67:SerialExample.c **** #define DEBUG 1
  68:SerialExample.c **** 
  69:SerialExample.c **** void setLeftServo(void);
  70:SerialExample.c **** void setRightServo(void);
  71:SerialExample.c **** void setThrottleServo(void);
  72:SerialExample.c **** void setCamPanServo(void);
  73:SerialExample.c **** void setCamTiltServo(void);
  74:SerialExample.c **** 
  75:SerialExample.c **** int leftServoPos = 50;		//0 seems to be beyond its reach
  76:SerialExample.c **** int rightServoPos;
  77:SerialExample.c **** int throttleServoPos;
  78:SerialExample.c **** int camPanServoPos;
  79:SerialExample.c **** int camTiltServoPos;
  80:SerialExample.c **** 
  81:SerialExample.c **** //long funcAParam;
  82:SerialExample.c **** //long funcBParam;
  83:SerialExample.c **** 
  84:SerialExample.c **** 
  85:SerialExample.c **** /*
  86:SerialExample.c ****  Timer 0 Overflow Interrupt Handler
  87:SerialExample.c **** 
  88:SerialExample.c ****  Prototypical Interrupt handler:
  89:SerialExample.c ****  . Switch to kernel context
  90:SerialExample.c ****  . handle interrupt
  91:SerialExample.c ****  . switch back to interrupted context.
  92:SerialExample.c ****  */
  93:SerialExample.c **** 
  94:SerialExample.c **** AVRX_SIGINT(SIG_OVERFLOW0)
  95:SerialExample.c **** {
 412               	.LM25:
 413               	/* prologue: frame size=0 */
 414               	/* prologue: naked */
 415               	/* prologue end (size=0) */
  96:SerialExample.c ****     IntProlog();                // Switch to kernel stack/context
 417               	.LM26:
 418 00ec 0E94 0000 		call IntProlog
  97:SerialExample.c ****     TCNT0 += TCNT0_INIT;		// Add to pre-load to account for any missed clocks
 420               	.LM27:
 421 00f0 82B7      		in r24,82-0x20
 422 00f2 8F53      		subi r24,lo8(-(-63))
 423 00f4 82BF      		out 82-0x20,r24
  98:SerialExample.c ****     AvrXTimerHandler();         // Call Time queue manager
 425               	.LM28:
 426 00f6 0E94 0000 		call AvrXTimerHandler
  99:SerialExample.c ****     Epilog();                   // Return to tasks
 428               	.LM29:
 429 00fa 0E94 0000 		call Epilog
 430               	/* epilogue: frame size=0 */
 431               	/* epilogue: naked */
 432               	/* epilogue end (size=0) */
 433               	/* function __vector_11 size 9 (9) */
 435               	.Lscope6:
 437               		.stabd	78,0,0
 441               	.global	myputs
 443               	myputs:
 444               		.stabd	46,0,0
 100:SerialExample.c **** }
 101:SerialExample.c **** 
 102:SerialExample.c **** 
 103:SerialExample.c **** 
 104:SerialExample.c **** // Super simple string printers...
 105:SerialExample.c **** 
 106:SerialExample.c **** // PutString from RAM
 107:SerialExample.c **** void myputs(int (*putch)(char), const uint8_t * psz)
 108:SerialExample.c **** {
 446               	.LM30:
 447               	/* prologue: frame size=0 */
 448 00fe 0F93      		push r16
 449 0100 1F93      		push r17
 450 0102 CF93      		push r28
 451 0104 DF93      		push r29
 452               	/* prologue end (size=4) */
 453 0106 8C01      		movw r16,r24
 454 0108 EB01      		movw r28,r22
 455 010a 03C0      		rjmp .L24
 456               	.L25:
 109:SerialExample.c **** 	while (*psz != 0)
 110:SerialExample.c **** 		(*putch)(*psz++);
 458               	.LM31:
 459 010c 2196      		adiw r28,1
 460 010e F801      		movw r30,r16
 461 0110 0995      		icall
 462               	.L24:
 464               	.LM32:
 465 0112 8881      		ld r24,Y
 466 0114 8823      		tst r24
 467 0116 D1F7      		brne .L25
 468               	/* epilogue: frame size=0 */
 469 0118 DF91      		pop r29
 470 011a CF91      		pop r28
 471 011c 1F91      		pop r17
 472 011e 0F91      		pop r16
 473 0120 0895      		ret
 474               	/* epilogue end (size=5) */
 475               	/* function myputs size 18 (9) */
 477               	.Lscope7:
 479               		.stabd	78,0,0
 483               	.global	myputs_P
 485               	myputs_P:
 486               		.stabd	46,0,0
 111:SerialExample.c **** }
 112:SerialExample.c **** 
 113:SerialExample.c **** // PutString from FLASH
 114:SerialExample.c **** void myputs_P(int (*putch)(char), const uint8_t * psz)
 115:SerialExample.c **** {
 488               	.LM33:
 489               	/* prologue: frame size=0 */
 490 0122 0F93      		push r16
 491 0124 1F93      		push r17
 492 0126 CF93      		push r28
 493 0128 DF93      		push r29
 494               	/* prologue end (size=4) */
 495 012a 8C01      		movw r16,r24
 496 012c EB01      		movw r28,r22
 497 012e 05C0      		rjmp .L29
 498               	.L30:
 499               	.LBB2:
 116:SerialExample.c **** 	while (__LPM(psz) != 0)
 117:SerialExample.c **** 		(*putch)(__LPM(psz++));
 501               	.LM34:
 502 0130 2196      		adiw r28,1
 503 0132 F901      		movw r30,r18
 504               	/* #APP */
 505 0134 8491      		lpm r24, Z
 506               		
 507               	/* #NOAPP */
 508               	.LBE2:
 509 0136 F801      		movw r30,r16
 510 0138 0995      		icall
 511               	.L29:
 512 013a 9E01      		movw r18,r28
 513               	.LBB3:
 515               	.LM35:
 516 013c FE01      		movw r30,r28
 517               	/* #APP */
 518 013e 8491      		lpm r24, Z
 519               		
 520               	/* #NOAPP */
 521               	.LBE3:
 522 0140 8823      		tst r24
 523 0142 B1F7      		brne .L30
 524               	/* epilogue: frame size=0 */
 525 0144 DF91      		pop r29
 526 0146 CF91      		pop r28
 527 0148 1F91      		pop r17
 528 014a 0F91      		pop r16
 529 014c 0895      		ret
 530               	/* epilogue end (size=5) */
 531               	/* function myputs_P size 28 (19) */
 540               	.Lscope8:
 542               		.stabd	78,0,0
 543               		.section	.progmem.data
 546               	__c.1904:
 547 000e 7720 2564 		.string	"w %d,"
 547      2C00 
 550               	__c.1902:
 551 0014 7120 2564 		.string	"q %d,"
 551      2C00 
 554               	__c.1900:
 555 001a 6220 2564 		.string	"b %d,"
 555      2C00 
 558               	__c.1898:
 559 0020 6620 2564 		.string	"f %d,"
 559      2C00 
 562               	__c.1896:
 563 0026 6720 2564 		.string	"g %d,"
 563      2C00 
 566               	__c.1894:
 567 002c 7320 2564 		.string	"s %d,"
 567      2C00 
 570               	__c.1892:
 571 0032 6120 3034 		.string	"a 043.3223n,"
 571      332E 3332 
 571      3233 6E2C 
 571      00
 574               	__c.1890:
 575 003f 6120 3037 		.string	"a 072.5759E,"
 575      322E 3537 
 575      3539 452C 
 575      00
 578               	__c.1888:
 579 004c 6320 2564 		.string	"c %d,"
 579      2C00 
 582               	__c.1886:
 583 0052 3100      		.string	"1"
 584               		.text
 586               	.global	getUAVStatus
 588               	getUAVStatus:
 589               		.stabd	46,0,0
 118:SerialExample.c **** }
 119:SerialExample.c **** 
 120:SerialExample.c **** //#if (USART_CHANNELS & CHANNEL_0)
 121:SerialExample.c **** 
 122:SerialExample.c **** //tell the ground station I am OK by sending a "1" 10 times a second
 123:SerialExample.c **** AVRX_GCC_TASKDEF(getUAVStatus, 76, 4)
 124:SerialExample.c **** {	
 591               	.LM36:
 592               	/* prologue: frame size=6 */
 593 014e CF93      		push r28
 594 0150 DF93      		push r29
 595 0152 CDB7      		in r28,__SP_L__
 596 0154 DEB7      		in r29,__SP_H__
 597 0156 2697      		sbiw r28,6
 598 0158 0FB6      		in __tmp_reg__,__SREG__
 599 015a F894      		cli
 600 015c DEBF      		out __SP_H__,r29
 601 015e 0FBE      		out __SREG__,__tmp_reg__
 602 0160 CDBF      		out __SP_L__,r28
 603               	/* prologue end (size=10) */
 604               	.L35:
 125:SerialExample.c **** 	TimerControlBlock timer;
 126:SerialExample.c **** 	
 127:SerialExample.c **** 	while(1)
 128:SerialExample.c **** 	{
 129:SerialExample.c **** 		printf_P(PSTR("1"));
 606               	.LM37:
 607 0162 80E0      		ldi r24,lo8(__c.1886)
 608 0164 90E0      		ldi r25,hi8(__c.1886)
 609 0166 9F93      		push r25
 610 0168 8F93      		push r24
 611 016a 0E94 0000 		call printf_P
 130:SerialExample.c **** 		putchar('\r');
 613               	.LM38:
 614 016e 6091 0000 		lds r22,__iob+2
 615 0172 7091 0000 		lds r23,(__iob+2)+1
 616 0176 8DE0      		ldi r24,lo8(13)
 617 0178 90E0      		ldi r25,hi8(13)
 618 017a 0E94 0000 		call fputc
 131:SerialExample.c **** 		if (DEBUG) putchar('\n');
 620               	.LM39:
 621 017e 6091 0000 		lds r22,__iob+2
 622 0182 7091 0000 		lds r23,(__iob+2)+1
 623 0186 8AE0      		ldi r24,lo8(10)
 624 0188 90E0      		ldi r25,hi8(10)
 625 018a 0E94 0000 		call fputc
 132:SerialExample.c **** 		AvrXDelay(&timer, 250);
 627               	.LM40:
 628 018e 6AEF      		ldi r22,lo8(250)
 629 0190 70E0      		ldi r23,hi8(250)
 630 0192 CE01      		movw r24,r28
 631 0194 0196      		adiw r24,1
 632 0196 0E94 0000 		call AvrXDelay
 133:SerialExample.c **** 		printf_P(PSTR("c %d,"), 120);   	// c/3 evaluates to an int, even it c is not a multiple of
 634               	.LM41:
 635 019a 88E7      		ldi r24,lo8(120)
 636 019c 90E0      		ldi r25,hi8(120)
 637 019e 9F93      		push r25
 638 01a0 8F93      		push r24
 639 01a2 80E0      		ldi r24,lo8(__c.1888)
 640 01a4 90E0      		ldi r25,hi8(__c.1888)
 641 01a6 9F93      		push r25
 642 01a8 8F93      		push r24
 643 01aa 0E94 0000 		call printf_P
 134:SerialExample.c **** 		printf_P(PSTR("a 072.5759E,")); 
 645               	.LM42:
 646 01ae 80E0      		ldi r24,lo8(__c.1890)
 647 01b0 90E0      		ldi r25,hi8(__c.1890)
 648 01b2 9F93      		push r25
 649 01b4 8F93      		push r24
 650 01b6 0E94 0000 		call printf_P
 135:SerialExample.c **** 		printf_P(PSTR("a 043.3223n,")); 
 652               	.LM43:
 653 01ba 80E0      		ldi r24,lo8(__c.1892)
 654 01bc 90E0      		ldi r25,hi8(__c.1892)
 655 01be 9F93      		push r25
 656 01c0 8F93      		push r24
 657 01c2 0E94 0000 		call printf_P
 136:SerialExample.c **** 		AvrXDelay(&timer, 250);
 659               	.LM44:
 660 01c6 6AEF      		ldi r22,lo8(250)
 661 01c8 70E0      		ldi r23,hi8(250)
 662 01ca CE01      		movw r24,r28
 663 01cc 0196      		adiw r24,1
 664 01ce 0E94 0000 		call AvrXDelay
 137:SerialExample.c **** 		printf_P(PSTR("s %d,"), 3);  
 666               	.LM45:
 667 01d2 83E0      		ldi r24,lo8(3)
 668 01d4 90E0      		ldi r25,hi8(3)
 669 01d6 9F93      		push r25
 670 01d8 8F93      		push r24
 671 01da 80E0      		ldi r24,lo8(__c.1894)
 672 01dc 90E0      		ldi r25,hi8(__c.1894)
 673 01de 9F93      		push r25
 674 01e0 8F93      		push r24
 675 01e2 0E94 0000 		call printf_P
 138:SerialExample.c **** 		printf_P(PSTR("g %d,"), 5);
 677               	.LM46:
 678 01e6 85E0      		ldi r24,lo8(5)
 679 01e8 90E0      		ldi r25,hi8(5)
 680 01ea 9F93      		push r25
 681 01ec 8F93      		push r24
 682 01ee 80E0      		ldi r24,lo8(__c.1896)
 683 01f0 90E0      		ldi r25,hi8(__c.1896)
 684 01f2 9F93      		push r25
 685 01f4 8F93      		push r24
 686 01f6 0E94 0000 		call printf_P
 139:SerialExample.c **** 		printf_P(PSTR("f %d,"), 80); 
 688               	.LM47:
 689 01fa 80E5      		ldi r24,lo8(80)
 690 01fc 90E0      		ldi r25,hi8(80)
 691 01fe 9F93      		push r25
 692 0200 8F93      		push r24
 693 0202 80E0      		ldi r24,lo8(__c.1898)
 694 0204 90E0      		ldi r25,hi8(__c.1898)
 695 0206 9F93      		push r25
 696 0208 8F93      		push r24
 697 020a 0E94 0000 		call printf_P
 140:SerialExample.c **** 		printf_P(PSTR("b %d,"), 35); 
 699               	.LM48:
 700 020e 83E2      		ldi r24,lo8(35)
 701 0210 90E0      		ldi r25,hi8(35)
 702 0212 9F93      		push r25
 703 0214 8F93      		push r24
 704 0216 80E0      		ldi r24,lo8(__c.1900)
 705 0218 90E0      		ldi r25,hi8(__c.1900)
 706 021a 9F93      		push r25
 707 021c 8F93      		push r24
 708 021e 0E94 0000 		call printf_P
 141:SerialExample.c **** 		printf_P(PSTR("q %d,"), 23);  
 710               	.LM49:
 711 0222 87E1      		ldi r24,lo8(23)
 712 0224 90E0      		ldi r25,hi8(23)
 713 0226 9F93      		push r25
 714 0228 8F93      		push r24
 715 022a 80E0      		ldi r24,lo8(__c.1902)
 716 022c 90E0      		ldi r25,hi8(__c.1902)
 717 022e 9F93      		push r25
 718 0230 8F93      		push r24
 719 0232 0E94 0000 		call printf_P
 142:SerialExample.c **** 		printf_P(PSTR("w %d,"), 70);
 721               	.LM50:
 722 0236 86E4      		ldi r24,lo8(70)
 723 0238 90E0      		ldi r25,hi8(70)
 724 023a 9F93      		push r25
 725 023c 8F93      		push r24
 726 023e 80E0      		ldi r24,lo8(__c.1904)
 727 0240 90E0      		ldi r25,hi8(__c.1904)
 728 0242 9F93      		push r25
 729 0244 8F93      		push r24
 730 0246 0E94 0000 		call printf_P
 143:SerialExample.c **** 	}
 732               	.LM51:
 733 024a 8DB7      		in r24,__SP_L__
 734 024c 9EB7      		in r25,__SP_H__
 735 024e 8296      		adiw r24,34
 736 0250 0FB6      		in __tmp_reg__,__SREG__
 737 0252 F894      		cli
 738 0254 9EBF      		out __SP_H__,r25
 739 0256 0FBE      		out __SREG__,__tmp_reg__
 740 0258 8DBF      		out __SP_L__,r24
 741 025a 83CF      		rjmp .L35
 742               	/* epilogue: frame size=6 */
 743               	/* epilogue: noreturn */
 744               	/* epilogue end (size=0) */
 745               	/* function getUAVStatus size 135 (125) */
 750               	.Lscope9:
 752               		.stabd	78,0,0
 754               	.global	getCommands
 756               	getCommands:
 757               		.stabd	46,0,0
 144:SerialExample.c **** }
 145:SerialExample.c **** 
 146:SerialExample.c **** 
 147:SerialExample.c **** 
 148:SerialExample.c **** 
 149:SerialExample.c **** 
 150:SerialExample.c **** 
 151:SerialExample.c **** 
 152:SerialExample.c **** AVRX_GCC_TASKDEF(getCommands, 100, 1)
 153:SerialExample.c **** {	
 759               	.LM52:
 760               	/* prologue: frame size=6 */
 761 025c CF93      		push r28
 762 025e DF93      		push r29
 763 0260 CDB7      		in r28,__SP_L__
 764 0262 DEB7      		in r29,__SP_H__
 765 0264 2697      		sbiw r28,6
 766 0266 0FB6      		in __tmp_reg__,__SREG__
 767 0268 F894      		cli
 768 026a DEBF      		out __SP_H__,r29
 769 026c 0FBE      		out __SREG__,__tmp_reg__
 770 026e CDBF      		out __SP_L__,r28
 771               	/* prologue end (size=10) */
 772 0270 16C0      		rjmp .L50
 773               	.L40:
 154:SerialExample.c **** 	int c;		
 155:SerialExample.c **** 	TimerControlBlock timer;
 156:SerialExample.c **** 	
 157:SerialExample.c **** 	while (1)
 158:SerialExample.c **** 	{
 159:SerialExample.c **** 		while ((c = getchar()) != EOF)
 160:SerialExample.c **** 		{	
 161:SerialExample.c **** 			if (c == '\r')
 775               	.LM53:
 776 0272 0D30      		cpi r16,13
 777 0274 1105      		cpc r17,__zero_reg__
 778 0276 81F4      		brne .L41
 162:SerialExample.c **** 			{	putchar('\r');
 780               	.LM54:
 781 0278 6091 0000 		lds r22,__iob+2
 782 027c 7091 0000 		lds r23,(__iob+2)+1
 783 0280 8DE0      		ldi r24,lo8(13)
 784 0282 90E0      		ldi r25,hi8(13)
 785 0284 0E94 0000 		call fputc
 163:SerialExample.c **** 				putchar('\n');
 787               	.LM55:
 788 0288 6091 0000 		lds r22,__iob+2
 789 028c 7091 0000 		lds r23,(__iob+2)+1
 790 0290 8AE0      		ldi r24,lo8(10)
 791 0292 90E0      		ldi r25,hi8(10)
 792 0294 0E94 0000 		call fputc
 793               	.L41:
 164:SerialExample.c **** 			}
 165:SerialExample.c **** 			parserInputFunc(c);
 795               	.LM56:
 796 0298 802F      		mov r24,r16
 797 029a 0E94 0000 		call parserInputFunc
 798               	.L50:
 800               	.LM57:
 801 029e 8091 0000 		lds r24,__iob
 802 02a2 9091 0000 		lds r25,(__iob)+1
 803 02a6 0E94 0000 		call fgetc
 804 02aa 8C01      		movw r16,r24
 805 02ac 8FEF      		ldi r24,hi8(-1)
 806 02ae 0F3F      		cpi r16,lo8(-1)
 807 02b0 1807      		cpc r17,r24
 808 02b2 F9F6      		brne .L40
 166:SerialExample.c **** 		}
 167:SerialExample.c **** 		AvrXDelay(&timer, 5);
 810               	.LM58:
 811 02b4 65E0      		ldi r22,lo8(5)
 812 02b6 70E0      		ldi r23,hi8(5)
 813 02b8 CE01      		movw r24,r28
 814 02ba 0196      		adiw r24,1
 815 02bc 0E94 0000 		call AvrXDelay
 816 02c0 EECF      		rjmp .L50
 817               	/* epilogue: frame size=6 */
 818               	/* epilogue: noreturn */
 819               	/* epilogue end (size=0) */
 820               	/* function getCommands size 51 (41) */
 826               	.Lscope10:
 828               		.stabd	78,0,0
 830               	.global	parserGetArgInt
 832               	parserGetArgInt:
 833               		.stabd	46,0,0
 835               	.Ltext3:
 108:parser.c      **** 
 109:parser.c      **** //return argument as a long
 110:parser.c      **** int parserGetArgInt(void)
 111:parser.c      **** {
 837               	.LM59:
 838               	/* prologue: frame size=0 */
 839               	/* prologue end (size=0) */
 112:parser.c      **** 	char* endptr;
 113:parser.c      **** 	return atoi(parserGetArgStr());
 841               	.LM60:
 842 02c2 80E0      		ldi r24,lo8(parserBuffer+2)
 843 02c4 90E0      		ldi r25,hi8(parserBuffer+2)
 844 02c6 0E94 0000 		call atoi
 845               	/* epilogue: frame size=0 */
 846 02ca 0895      		ret
 847               	/* epilogue end (size=1) */
 848               	/* function parserGetArgInt size 5 (4) */
 850               	.Lscope11:
 852               		.stabd	78,0,0
 853               		.data
 854               	.LC0:
 855 0002 4361 6D65 		.string	"Camera Tilt Servo Set: %d"
 855      7261 2054 
 855      696C 7420 
 855      5365 7276 
 855      6F20 5365 
 856               		.text
 858               	.global	setCamTiltServo
 860               	setCamTiltServo:
 861               		.stabd	46,0,0
 863               	.Ltext4:
 168:SerialExample.c **** 	}
 169:SerialExample.c **** }
 170:SerialExample.c **** 
 171:SerialExample.c **** 
 172:SerialExample.c **** 	
 173:SerialExample.c **** 
 174:SerialExample.c **** 
 175:SerialExample.c **** int main(void)
 176:SerialExample.c **** {
 177:SerialExample.c ****     AvrXSetKernelStack(0);
 178:SerialExample.c **** 
 179:SerialExample.c **** 	MCUCR = _BV(SE);
 180:SerialExample.c **** 	TCNT0 = TCNT0_INIT;
 181:SerialExample.c **** #if defined (__AVR_ATmega103__) || defined (__ATmega103__)
 182:SerialExample.c **** 	TCCR0 =  ((1<<CS02) | (1<<CS01));
 183:SerialExample.c **** #elif defined (__AVR_ATmega128__) || defined (__ATmega128__) || defined (__AVR_ATmega64__) || defin
 184:SerialExample.c **** 	TCCR0 =  ((1<<CS2) | (1<<CS1));
 185:SerialExample.c **** #else	// Most other chips...  Note: some are TCCR0 and some are TCCR0B...
 186:SerialExample.c **** 	TCCR0 =  (1<<CS02);
 187:SerialExample.c **** #endif
 188:SerialExample.c **** 	TIMSK = _BV(TOIE0);
 189:SerialExample.c **** 
 190:SerialExample.c ****     InitSerial0(BAUD(57600));
 191:SerialExample.c ****     fdevopen(put_char0, get_c0,0);		// Set up standard I/O
 192:SerialExample.c **** 
 193:SerialExample.c **** 	// initialize parser system
 194:SerialExample.c **** 	parserInit();
 195:SerialExample.c **** 	// direct output to uart (serial port)
 196:SerialExample.c **** 	parserSetOutputFunc(put_char0);
 197:SerialExample.c **** 	// add commands to the command database
 198:SerialExample.c **** 	parserAddCommand("l",		setLeftServo);
 199:SerialExample.c **** 	parserAddCommand("r",		setRightServo);
 200:SerialExample.c ****     parserAddCommand("t", 		setThrottleServo);
 201:SerialExample.c **** 	parserAddCommand("p", 		setCamPanServo);
 202:SerialExample.c **** 	parserAddCommand("i", 		setCamTiltServo);
 203:SerialExample.c **** 	
 204:SerialExample.c **** 	// initialize the timer system -- FROM AVRLIB
 205:SerialExample.c **** 	//timerInit();
 206:SerialExample.c **** 	
 207:SerialExample.c **** 	//////////////////////////////////////////////////Servos//////////////////////////
 208:SerialExample.c **** 	servoInit();
 209:SerialExample.c **** 	// setup servo output channel-to-I/Opin mapping
 210:SerialExample.c **** 	// format is servoSetChannelIO( CHANNEL#, PORT, PIN );
 211:SerialExample.c **** 	servoSetChannelIO(0, _SFR_IO_ADDR(PORTC), PC0);
 212:SerialExample.c **** 	servoSetChannelIO(1, _SFR_IO_ADDR(PORTC), PC1);
 213:SerialExample.c **** 	servoSetChannelIO(2, _SFR_IO_ADDR(PORTC), PC2);
 214:SerialExample.c **** 	servoSetChannelIO(3, _SFR_IO_ADDR(PORTC), PC3);
 215:SerialExample.c **** 	servoSetChannelIO(4, _SFR_IO_ADDR(PORTC), PC4);
 216:SerialExample.c **** 
 217:SerialExample.c **** 	// set port pins to output
 218:SerialExample.c **** 	outb(DDRC, 0x1F);
 219:SerialExample.c **** 
 220:SerialExample.c **** 	
 221:SerialExample.c **** 	#define SPEED_SERVO	1
 222:SerialExample.c **** 	//////////////////////////////////////////////////////////////////////////////////
 223:SerialExample.c **** 	
 224:SerialExample.c **** 	AvrXRunTask(TCB(getCommands));
 225:SerialExample.c **** 	AvrXRunTask(TCB(getUAVStatus));
 226:SerialExample.c **** 
 227:SerialExample.c ****     
 228:SerialExample.c **** 	Epilog();
 229:SerialExample.c **** 	return(0);
 230:SerialExample.c **** }
 231:SerialExample.c **** 
 232:SerialExample.c **** void setLeftServo(void)
 233:SerialExample.c **** {	
 234:SerialExample.c **** 	leftServoPos = parserGetArgInt();
 235:SerialExample.c **** 	servoSetPosition(LEFT_SERVO_CHAN, (char)leftServoPos);
 236:SerialExample.c **** 	if (DEBUG)
 237:SerialExample.c **** 	{	printf("e0");
 238:SerialExample.c **** 		putchar('\r');
 239:SerialExample.c **** 		putchar('\n');
 240:SerialExample.c **** 	}
 241:SerialExample.c **** }
 242:SerialExample.c **** 
 243:SerialExample.c **** void setRightServo(void)
 244:SerialExample.c **** {	
 245:SerialExample.c **** 	rightServoPos = parserGetArgInt();
 246:SerialExample.c **** 	servoSetPosition(RIGHT_SERVO_CHAN, (char)rightServoPos);
 247:SerialExample.c **** 	if (DEBUG)
 248:SerialExample.c **** 	{	printf("e0");
 249:SerialExample.c **** 		putchar('\r');
 250:SerialExample.c **** 		putchar('\n');
 251:SerialExample.c **** 	}
 252:SerialExample.c **** }
 253:SerialExample.c **** 
 254:SerialExample.c **** void setThrottleServo(void)
 255:SerialExample.c **** {
 256:SerialExample.c **** 	throttleServoPos = parserGetArgInt();
 257:SerialExample.c **** 	servoSetPosition(THROTTLE_SERVO_CHAN, (char)throttleServoPos);
 258:SerialExample.c **** 	if (DEBUG)
 259:SerialExample.c **** 	{	printf("e0");
 260:SerialExample.c **** 		putchar('\r');
 261:SerialExample.c **** 		putchar('\n');
 262:SerialExample.c **** 	}
 263:SerialExample.c **** }
 264:SerialExample.c **** 
 265:SerialExample.c **** void setCamPanServo(void)
 266:SerialExample.c **** {
 267:SerialExample.c **** 	camPanServoPos = parserGetArgInt();
 268:SerialExample.c **** 	servoSetPosition(CAM_PAN_SERVO_CHAN, (char)camPanServoPos);
 269:SerialExample.c **** 	if (DEBUG)
 270:SerialExample.c **** 	{	printf("e0");
 271:SerialExample.c **** 		putchar('\r');
 272:SerialExample.c **** 		putchar('\n');
 273:SerialExample.c **** 	}
 274:SerialExample.c **** }
 275:SerialExample.c **** 
 276:SerialExample.c **** void setCamTiltServo(void)
 277:SerialExample.c **** {
 865               	.LM61:
 866               	/* prologue: frame size=0 */
 867               	/* prologue end (size=0) */
 278:SerialExample.c **** 	camTiltServoPos = parserGetArgInt();
 869               	.LM62:
 870 02cc 0E94 0000 		call parserGetArgInt
 871 02d0 9093 0000 		sts (camTiltServoPos)+1,r25
 872 02d4 8093 0000 		sts camTiltServoPos,r24
 279:SerialExample.c **** 	servoSetPosition(CAM_TILT_SERVO_CHAN, (char)camTiltServoPos);
 874               	.LM63:
 875 02d8 9927      		clr r25
 876 02da 87FD      		sbrc r24,7
 877 02dc 9095      		com r25
 878 02de BC01      		movw r22,r24
 879 02e0 84E0      		ldi r24,lo8(4)
 880 02e2 90E0      		ldi r25,hi8(4)
 881 02e4 0E94 0000 		call servoSetPosition
 280:SerialExample.c **** 	if (DEBUG)
 281:SerialExample.c **** 	{	printf("Camera Tilt Servo Set: %d", camTiltServoPos);
 883               	.LM64:
 884 02e8 8091 0000 		lds r24,camTiltServoPos
 885 02ec 9091 0000 		lds r25,(camTiltServoPos)+1
 886 02f0 9F93      		push r25
 887 02f2 8F93      		push r24
 888 02f4 80E0      		ldi r24,lo8(.LC0)
 889 02f6 90E0      		ldi r25,hi8(.LC0)
 890 02f8 9F93      		push r25
 891 02fa 8F93      		push r24
 892 02fc 0E94 0000 		call printf
 282:SerialExample.c **** 		putchar('\r');
 894               	.LM65:
 895 0300 6091 0000 		lds r22,__iob+2
 896 0304 7091 0000 		lds r23,(__iob+2)+1
 897 0308 8DE0      		ldi r24,lo8(13)
 898 030a 90E0      		ldi r25,hi8(13)
 899 030c 0E94 0000 		call fputc
 283:SerialExample.c **** 		putchar('\n');
 901               	.LM66:
 902 0310 6091 0000 		lds r22,__iob+2
 903 0314 7091 0000 		lds r23,(__iob+2)+1
 904 0318 8AE0      		ldi r24,lo8(10)
 905 031a 90E0      		ldi r25,hi8(10)
 906 031c 0E94 0000 		call fputc
 907 0320 0F90      		pop __tmp_reg__
 908 0322 0F90      		pop __tmp_reg__
 909 0324 0F90      		pop __tmp_reg__
 910 0326 0F90      		pop __tmp_reg__
 911               	/* epilogue: frame size=0 */
 912 0328 0895      		ret
 913               	/* epilogue end (size=1) */
 914               	/* function setCamTiltServo size 47 (46) */
 916               	.Lscope12:
 918               		.stabd	78,0,0
 919               		.data
 920               	.LC1:
 921 001c 6530 00   		.string	"e0"
 922               		.text
 924               	.global	setCamPanServo
 926               	setCamPanServo:
 927               		.stabd	46,0,0
 929               	.LM67:
 930               	/* prologue: frame size=0 */
 931               	/* prologue end (size=0) */
 933               	.LM68:
 934 032a 0E94 0000 		call parserGetArgInt
 935 032e 9093 0000 		sts (camPanServoPos)+1,r25
 936 0332 8093 0000 		sts camPanServoPos,r24
 938               	.LM69:
 939 0336 9927      		clr r25
 940 0338 87FD      		sbrc r24,7
 941 033a 9095      		com r25
 942 033c BC01      		movw r22,r24
 943 033e 83E0      		ldi r24,lo8(3)
 944 0340 90E0      		ldi r25,hi8(3)
 945 0342 0E94 0000 		call servoSetPosition
 947               	.LM70:
 948 0346 80E0      		ldi r24,lo8(.LC1)
 949 0348 90E0      		ldi r25,hi8(.LC1)
 950 034a 9F93      		push r25
 951 034c 8F93      		push r24
 952 034e 0E94 0000 		call printf
 954               	.LM71:
 955 0352 6091 0000 		lds r22,__iob+2
 956 0356 7091 0000 		lds r23,(__iob+2)+1
 957 035a 8DE0      		ldi r24,lo8(13)
 958 035c 90E0      		ldi r25,hi8(13)
 959 035e 0E94 0000 		call fputc
 961               	.LM72:
 962 0362 6091 0000 		lds r22,__iob+2
 963 0366 7091 0000 		lds r23,(__iob+2)+1
 964 036a 8AE0      		ldi r24,lo8(10)
 965 036c 90E0      		ldi r25,hi8(10)
 966 036e 0E94 0000 		call fputc
 967 0372 0F90      		pop __tmp_reg__
 968 0374 0F90      		pop __tmp_reg__
 969               	/* epilogue: frame size=0 */
 970 0376 0895      		ret
 971               	/* epilogue end (size=1) */
 972               	/* function setCamPanServo size 39 (38) */
 974               	.Lscope13:
 976               		.stabd	78,0,0
 978               	.global	setThrottleServo
 980               	setThrottleServo:
 981               		.stabd	46,0,0
 983               	.LM73:
 984               	/* prologue: frame size=0 */
 985               	/* prologue end (size=0) */
 987               	.LM74:
 988 0378 0E94 0000 		call parserGetArgInt
 989 037c 9093 0000 		sts (throttleServoPos)+1,r25
 990 0380 8093 0000 		sts throttleServoPos,r24
 992               	.LM75:
 993 0384 9927      		clr r25
 994 0386 87FD      		sbrc r24,7
 995 0388 9095      		com r25
 996 038a BC01      		movw r22,r24
 997 038c 82E0      		ldi r24,lo8(2)
 998 038e 90E0      		ldi r25,hi8(2)
 999 0390 0E94 0000 		call servoSetPosition
 1001               	.LM76:
 1002 0394 80E0      		ldi r24,lo8(.LC1)
 1003 0396 90E0      		ldi r25,hi8(.LC1)
 1004 0398 9F93      		push r25
 1005 039a 8F93      		push r24
 1006 039c 0E94 0000 		call printf
 1008               	.LM77:
 1009 03a0 6091 0000 		lds r22,__iob+2
 1010 03a4 7091 0000 		lds r23,(__iob+2)+1
 1011 03a8 8DE0      		ldi r24,lo8(13)
 1012 03aa 90E0      		ldi r25,hi8(13)
 1013 03ac 0E94 0000 		call fputc
 1015               	.LM78:
 1016 03b0 6091 0000 		lds r22,__iob+2
 1017 03b4 7091 0000 		lds r23,(__iob+2)+1
 1018 03b8 8AE0      		ldi r24,lo8(10)
 1019 03ba 90E0      		ldi r25,hi8(10)
 1020 03bc 0E94 0000 		call fputc
 1021 03c0 0F90      		pop __tmp_reg__
 1022 03c2 0F90      		pop __tmp_reg__
 1023               	/* epilogue: frame size=0 */
 1024 03c4 0895      		ret
 1025               	/* epilogue end (size=1) */
 1026               	/* function setThrottleServo size 39 (38) */
 1028               	.Lscope14:
 1030               		.stabd	78,0,0
 1032               	.global	setRightServo
 1034               	setRightServo:
 1035               		.stabd	46,0,0
 1037               	.LM79:
 1038               	/* prologue: frame size=0 */
 1039               	/* prologue end (size=0) */
 1041               	.LM80:
 1042 03c6 0E94 0000 		call parserGetArgInt
 1043 03ca 9093 0000 		sts (rightServoPos)+1,r25
 1044 03ce 8093 0000 		sts rightServoPos,r24
 1046               	.LM81:
 1047 03d2 9927      		clr r25
 1048 03d4 87FD      		sbrc r24,7
 1049 03d6 9095      		com r25
 1050 03d8 BC01      		movw r22,r24
 1051 03da 81E0      		ldi r24,lo8(1)
 1052 03dc 90E0      		ldi r25,hi8(1)
 1053 03de 0E94 0000 		call servoSetPosition
 1055               	.LM82:
 1056 03e2 80E0      		ldi r24,lo8(.LC1)
 1057 03e4 90E0      		ldi r25,hi8(.LC1)
 1058 03e6 9F93      		push r25
 1059 03e8 8F93      		push r24
 1060 03ea 0E94 0000 		call printf
 1062               	.LM83:
 1063 03ee 6091 0000 		lds r22,__iob+2
 1064 03f2 7091 0000 		lds r23,(__iob+2)+1
 1065 03f6 8DE0      		ldi r24,lo8(13)
 1066 03f8 90E0      		ldi r25,hi8(13)
 1067 03fa 0E94 0000 		call fputc
 1069               	.LM84:
 1070 03fe 6091 0000 		lds r22,__iob+2
 1071 0402 7091 0000 		lds r23,(__iob+2)+1
 1072 0406 8AE0      		ldi r24,lo8(10)
 1073 0408 90E0      		ldi r25,hi8(10)
 1074 040a 0E94 0000 		call fputc
 1075 040e 0F90      		pop __tmp_reg__
 1076 0410 0F90      		pop __tmp_reg__
 1077               	/* epilogue: frame size=0 */
 1078 0412 0895      		ret
 1079               	/* epilogue end (size=1) */
 1080               	/* function setRightServo size 39 (38) */
 1082               	.Lscope15:
 1084               		.stabd	78,0,0
 1086               	.global	setLeftServo
 1088               	setLeftServo:
 1089               		.stabd	46,0,0
 1091               	.LM85:
 1092               	/* prologue: frame size=0 */
 1093               	/* prologue end (size=0) */
 1095               	.LM86:
 1096 0414 0E94 0000 		call parserGetArgInt
 1097 0418 9093 0000 		sts (leftServoPos)+1,r25
 1098 041c 8093 0000 		sts leftServoPos,r24
 1100               	.LM87:
 1101 0420 9927      		clr r25
 1102 0422 87FD      		sbrc r24,7
 1103 0424 9095      		com r25
 1104 0426 BC01      		movw r22,r24
 1105 0428 80E0      		ldi r24,lo8(0)
 1106 042a 90E0      		ldi r25,hi8(0)
 1107 042c 0E94 0000 		call servoSetPosition
 1109               	.LM88:
 1110 0430 80E0      		ldi r24,lo8(.LC1)
 1111 0432 90E0      		ldi r25,hi8(.LC1)
 1112 0434 9F93      		push r25
 1113 0436 8F93      		push r24
 1114 0438 0E94 0000 		call printf
 1116               	.LM89:
 1117 043c 6091 0000 		lds r22,__iob+2
 1118 0440 7091 0000 		lds r23,(__iob+2)+1
 1119 0444 8DE0      		ldi r24,lo8(13)
 1120 0446 90E0      		ldi r25,hi8(13)
 1121 0448 0E94 0000 		call fputc
 1123               	.LM90:
 1124 044c 6091 0000 		lds r22,__iob+2
 1125 0450 7091 0000 		lds r23,(__iob+2)+1
 1126 0454 8AE0      		ldi r24,lo8(10)
 1127 0456 90E0      		ldi r25,hi8(10)
 1128 0458 0E94 0000 		call fputc
 1129 045c 0F90      		pop __tmp_reg__
 1130 045e 0F90      		pop __tmp_reg__
 1131               	/* epilogue: frame size=0 */
 1132 0460 0895      		ret
 1133               	/* epilogue end (size=1) */
 1134               	/* function setLeftServo size 39 (38) */
 1136               	.Lscope16:
 1138               		.stabd	78,0,0
 1139               		.data
 1140               	.LC2:
 1141 001f 6C00      		.string	"l"
 1142               	.LC3:
 1143 0021 7200      		.string	"r"
 1144               	.LC4:
 1145 0023 7400      		.string	"t"
 1146               	.LC5:
 1147 0025 7000      		.string	"p"
 1148               	.LC6:
 1149 0027 6900      		.string	"i"
 1150               		.text
 1152               	.global	main
 1154               	main:
 1155               		.stabd	46,0,0
 1157               	.LM91:
 1158               	/* prologue: frame size=0 */
 1159 0462 C0E0      		ldi r28,lo8(__stack - 0)
 1160 0464 D0E0      		ldi r29,hi8(__stack - 0)
 1161 0466 DEBF      		out __SP_H__,r29
 1162 0468 CDBF      		out __SP_L__,r28
 1163               	/* prologue end (size=4) */
 1165               	.LM92:
 1166 046a 80E0      		ldi r24,lo8(0)
 1167 046c 90E0      		ldi r25,hi8(0)
 1168 046e 0E94 0000 		call AvrXSetKernelStack
 1170               	.LM93:
 1171 0472 80E8      		ldi r24,lo8(-128)
 1172 0474 85BF      		out 85-0x20,r24
 1174               	.LM94:
 1175 0476 81EC      		ldi r24,lo8(-63)
 1176 0478 82BF      		out 82-0x20,r24
 1178               	.LM95:
 1179 047a 84E0      		ldi r24,lo8(4)
 1180 047c 83BF      		out 83-0x20,r24
 1182               	.LM96:
 1183 047e 81E0      		ldi r24,lo8(1)
 1184 0480 89BF      		out 89-0x20,r24
 1186               	.LM97:
 1187 0482 81E2      		ldi r24,lo8(33)
 1188 0484 90E0      		ldi r25,hi8(33)
 1189 0486 0E94 0000 		call InitSerial0
 1191               	.LM98:
 1192 048a 00E0      		ldi r16,lo8(pm(put_char0))
 1193 048c 10E0      		ldi r17,hi8(pm(put_char0))
 1194 048e 40E0      		ldi r20,lo8(0)
 1195 0490 50E0      		ldi r21,hi8(0)
 1196 0492 60E0      		ldi r22,lo8(pm(get_c0))
 1197 0494 70E0      		ldi r23,hi8(pm(get_c0))
 1198 0496 C801      		movw r24,r16
 1199 0498 0E94 0000 		call fdevopen
 1200               	.LBB4:
 1202               	.Ltext5:
 1204               	.LM99:
 1205 049c 1092 0000 		sts parserBufferLength,__zero_reg__
 1207               	.LM100:
 1208 04a0 1092 0000 		sts (ParserExecFunction)+1,__zero_reg__
 1209 04a4 1092 0000 		sts ParserExecFunction,__zero_reg__
 1211               	.LM101:
 1212 04a8 1092 0000 		sts parserNumCommands,__zero_reg__
 1213               	.LBE4:
 1214               	.LBB5:
 1216               	.LM102:
 1217 04ac 1093 0000 		sts (parserOutputFunc)+1,r17
 1218 04b0 0093 0000 		sts parserOutputFunc,r16
 1219               	.LBE5:
 1221               	.Ltext6:
 1223               	.LM103:
 1224 04b4 60E0      		ldi r22,lo8(pm(setLeftServo))
 1225 04b6 70E0      		ldi r23,hi8(pm(setLeftServo))
 1226 04b8 80E0      		ldi r24,lo8(.LC2)
 1227 04ba 90E0      		ldi r25,hi8(.LC2)
 1228 04bc 0E94 0000 		call parserAddCommand
 1230               	.LM104:
 1231 04c0 60E0      		ldi r22,lo8(pm(setRightServo))
 1232 04c2 70E0      		ldi r23,hi8(pm(setRightServo))
 1233 04c4 80E0      		ldi r24,lo8(.LC3)
 1234 04c6 90E0      		ldi r25,hi8(.LC3)
 1235 04c8 0E94 0000 		call parserAddCommand
 1237               	.LM105:
 1238 04cc 60E0      		ldi r22,lo8(pm(setThrottleServo))
 1239 04ce 70E0      		ldi r23,hi8(pm(setThrottleServo))
 1240 04d0 80E0      		ldi r24,lo8(.LC4)
 1241 04d2 90E0      		ldi r25,hi8(.LC4)
 1242 04d4 0E94 0000 		call parserAddCommand
 1244               	.LM106:
 1245 04d8 60E0      		ldi r22,lo8(pm(setCamPanServo))
 1246 04da 70E0      		ldi r23,hi8(pm(setCamPanServo))
 1247 04dc 80E0      		ldi r24,lo8(.LC5)
 1248 04de 90E0      		ldi r25,hi8(.LC5)
 1249 04e0 0E94 0000 		call parserAddCommand
 1251               	.LM107:
 1252 04e4 60E0      		ldi r22,lo8(pm(setCamTiltServo))
 1253 04e6 70E0      		ldi r23,hi8(pm(setCamTiltServo))
 1254 04e8 80E0      		ldi r24,lo8(.LC6)
 1255 04ea 90E0      		ldi r25,hi8(.LC6)
 1256 04ec 0E94 0000 		call parserAddCommand
 1258               	.LM108:
 1259 04f0 0E94 0000 		call servoInit
 1261               	.LM109:
 1262 04f4 40E0      		ldi r20,lo8(0)
 1263 04f6 50E0      		ldi r21,hi8(0)
 1264 04f8 65E1      		ldi r22,lo8(21)
 1265 04fa 70E0      		ldi r23,hi8(21)
 1266 04fc 80E0      		ldi r24,lo8(0)
 1267 04fe 90E0      		ldi r25,hi8(0)
 1268 0500 0E94 0000 		call servoSetChannelIO
 1270               	.LM110:
 1271 0504 41E0      		ldi r20,lo8(1)
 1272 0506 50E0      		ldi r21,hi8(1)
 1273 0508 65E1      		ldi r22,lo8(21)
 1274 050a 70E0      		ldi r23,hi8(21)
 1275 050c 81E0      		ldi r24,lo8(1)
 1276 050e 90E0      		ldi r25,hi8(1)
 1277 0510 0E94 0000 		call servoSetChannelIO
 1279               	.LM111:
 1280 0514 42E0      		ldi r20,lo8(2)
 1281 0516 50E0      		ldi r21,hi8(2)
 1282 0518 65E1      		ldi r22,lo8(21)
 1283 051a 70E0      		ldi r23,hi8(21)
 1284 051c 82E0      		ldi r24,lo8(2)
 1285 051e 90E0      		ldi r25,hi8(2)
 1286 0520 0E94 0000 		call servoSetChannelIO
 1288               	.LM112:
 1289 0524 43E0      		ldi r20,lo8(3)
 1290 0526 50E0      		ldi r21,hi8(3)
 1291 0528 65E1      		ldi r22,lo8(21)
 1292 052a 70E0      		ldi r23,hi8(21)
 1293 052c 83E0      		ldi r24,lo8(3)
 1294 052e 90E0      		ldi r25,hi8(3)
 1295 0530 0E94 0000 		call servoSetChannelIO
 1297               	.LM113:
 1298 0534 44E0      		ldi r20,lo8(4)
 1299 0536 50E0      		ldi r21,hi8(4)
 1300 0538 65E1      		ldi r22,lo8(21)
 1301 053a 70E0      		ldi r23,hi8(21)
 1302 053c 84E0      		ldi r24,lo8(4)
 1303 053e 90E0      		ldi r25,hi8(4)
 1304 0540 0E94 0000 		call servoSetChannelIO
 1306               	.LM114:
 1307 0544 8FE1      		ldi r24,lo8(31)
 1308 0546 84BB      		out 52-0x20,r24
 1310               	.LM115:
 1311 0548 80E0      		ldi r24,lo8(getCommandsTcb)
 1312 054a 90E0      		ldi r25,hi8(getCommandsTcb)
 1313 054c 0E94 0000 		call AvrXRunTask
 1315               	.LM116:
 1316 0550 80E0      		ldi r24,lo8(getUAVStatusTcb)
 1317 0552 90E0      		ldi r25,hi8(getUAVStatusTcb)
 1318 0554 0E94 0000 		call AvrXRunTask
 1320               	.LM117:
 1321 0558 0E94 0000 		call Epilog
 1323               	.LM118:
 1324 055c 80E0      		ldi r24,lo8(0)
 1325 055e 90E0      		ldi r25,hi8(0)
 1326               	/* epilogue: frame size=0 */
 1327 0560 0C94 0000 		jmp exit
 1328               	/* epilogue end (size=2) */
 1329               	/* function main size 129 (123) */
 1331               	.Lscope17:
 1333               		.stabd	78,0,0
 1352               		.comm getCommandsPid,6,1
 1353               		.comm getCommandsStk,135,1
 1354               		.comm getUAVStatusPid,6,1
 1355               		.comm getUAVStatusStk,111,1
 1356               		.comm camTiltServoPos,2,1
 1357               		.comm camPanServoPos,2,1
 1358               		.comm throttleServoPos,2,1
 1359               		.comm rightServoPos,2,1
 1360               		.comm parserOutputFunc,2,1
 1361               		.comm ParserExecFunction,2,1
 1362               		.comm parserBuffer,15,1
 1363               		.comm parserBufferLength,1,1
 1364               		.comm parserNumCommands,1,1
 1365               		.comm ParserFunctionList,20,1
 1366               		.comm CommandList,150,1
 1368               	.Letext0:
 1369               	/* File "SerialExample.c": code  696 = 0x02b8 ( 633), prologues  36, epilogues  27 */
DEFINED SYMBOLS
                            *ABS*:00000000 SerialExample.c
/var/tmp//ccCpPzUl.s:3      *ABS*:0000003f __SREG__
/var/tmp//ccCpPzUl.s:4      *ABS*:0000003e __SP_H__
/var/tmp//ccCpPzUl.s:5      *ABS*:0000003d __SP_L__
/var/tmp//ccCpPzUl.s:6      *ABS*:00000000 __tmp_reg__
/var/tmp//ccCpPzUl.s:7      *ABS*:00000001 __zero_reg__
/var/tmp//ccCpPzUl.s:138    .progmem.data:00000000 getCommandsTcb
                            *COM*:00000087 getCommandsStk
/var/tmp//ccCpPzUl.s:756    .text:0000025c getCommands
                            *COM*:00000006 getCommandsPid
/var/tmp//ccCpPzUl.s:146    .progmem.data:00000007 getUAVStatusTcb
                            *COM*:0000006f getUAVStatusStk
/var/tmp//ccCpPzUl.s:588    .text:0000014e getUAVStatus
                            *COM*:00000006 getUAVStatusPid
/var/tmp//ccCpPzUl.s:155    .data:00000000 leftServoPos
/var/tmp//ccCpPzUl.s:161    .text:00000000 parserInit
                            *COM*:00000001 parserBufferLength
                            *COM*:00000002 ParserExecFunction
                            *COM*:00000001 parserNumCommands
/var/tmp//ccCpPzUl.s:192    .text:00000012 parserAddCommand
                            *COM*:00000096 CommandList
                            *COM*:00000014 ParserFunctionList
/var/tmp//ccCpPzUl.s:242    .text:00000050 parserSetOutputFunc
                            *COM*:00000002 parserOutputFunc
/var/tmp//ccCpPzUl.s:263    .text:0000005a parserProcessInputString
                            *COM*:0000000f parserBuffer
/var/tmp//ccCpPzUl.s:337    .text:000000b8 parserInputFunc
/var/tmp//ccCpPzUl.s:386    .text:000000e6 parserGetArgStr
/var/tmp//ccCpPzUl.s:407    .text:000000ec __vector_11
/var/tmp//ccCpPzUl.s:443    .text:000000fe myputs
/var/tmp//ccCpPzUl.s:485    .text:00000122 myputs_P
/var/tmp//ccCpPzUl.s:546    .progmem.data:0000000e __c.1904
/var/tmp//ccCpPzUl.s:550    .progmem.data:00000014 __c.1902
/var/tmp//ccCpPzUl.s:554    .progmem.data:0000001a __c.1900
/var/tmp//ccCpPzUl.s:558    .progmem.data:00000020 __c.1898
/var/tmp//ccCpPzUl.s:562    .progmem.data:00000026 __c.1896
/var/tmp//ccCpPzUl.s:566    .progmem.data:0000002c __c.1894
/var/tmp//ccCpPzUl.s:570    .progmem.data:00000032 __c.1892
/var/tmp//ccCpPzUl.s:574    .progmem.data:0000003f __c.1890
/var/tmp//ccCpPzUl.s:578    .progmem.data:0000004c __c.1888
/var/tmp//ccCpPzUl.s:582    .progmem.data:00000052 __c.1886
/var/tmp//ccCpPzUl.s:832    .text:000002c2 parserGetArgInt
/var/tmp//ccCpPzUl.s:860    .text:000002cc setCamTiltServo
                            *COM*:00000002 camTiltServoPos
/var/tmp//ccCpPzUl.s:926    .text:0000032a setCamPanServo
                            *COM*:00000002 camPanServoPos
/var/tmp//ccCpPzUl.s:980    .text:00000378 setThrottleServo
                            *COM*:00000002 throttleServoPos
/var/tmp//ccCpPzUl.s:1034   .text:000003c6 setRightServo
                            *COM*:00000002 rightServoPos
/var/tmp//ccCpPzUl.s:1088   .text:00000414 setLeftServo
/var/tmp//ccCpPzUl.s:1154   .text:00000462 main

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
strcpy
IntProlog
AvrXTimerHandler
Epilog
printf_P
__iob
fputc
AvrXDelay
fgetc
atoi
servoSetPosition
printf
__stack
AvrXSetKernelStack
InitSerial0
put_char0
get_c0
fdevopen
servoInit
servoSetChannelIO
AvrXRunTask
exit
