   1               		.file	"AvrXSimpleSerial.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
  80               	.global	InitSerial0
  82               	InitSerial0:
  83               		.stabd	46,0,0
   1:AvrXSimpleSerial.c **** /*
   2:AvrXSimpleSerial.c **** 	AvrXSimpleSerial.c
   3:AvrXSimpleSerial.c **** 
   4:AvrXSimpleSerial.c **** 	Sample code for simple unbuffered (except for hardware)
   5:AvrXSimpleSerial.c **** 	serial I/O for most (all?) Avr single and dual U(S)ART
   6:AvrXSimpleSerial.c **** 	capable processors with >= 8k FLASH.
   7:AvrXSimpleSerial.c **** 
   8:AvrXSimpleSerial.c **** 	There is a natural three charactor buffer for Rx data: the hardware is
   9:AvrXSimpleSerial.c **** 	double buffered and the input shift register.  The Tx is double
  10:AvrXSimpleSerial.c **** 	buffered in hardware.  It is easy to make Rx triple buffered by reading
  11:AvrXSimpleSerial.c **** 	in UDR in the interrupt handler and using that stored value instead of UDR
  12:AvrXSimpleSerial.c **** 	in the get_c and get_char routines.
  13:AvrXSimpleSerial.c **** 
  14:AvrXSimpleSerial.c **** 	NB: The value in the shift register will be overwritten by additional
  15:AvrXSimpleSerial.c **** 	incoming data.
  16:AvrXSimpleSerial.c **** 
  17:AvrXSimpleSerial.c **** 	Author: Larry Barello (larry@barello.net)
  18:AvrXSimpleSerial.c **** 
  19:AvrXSimpleSerial.c **** 	Revision History:
  20:AvrXSimpleSerial.c **** 	09-13-2005	- Initial version
  21:AvrXSimpleSerial.c **** 
  22:AvrXSimpleSerial.c **** */
  23:AvrXSimpleSerial.c **** 
  24:AvrXSimpleSerial.c **** //------------------------------------------------------------------------------
  25:AvrXSimpleSerial.c **** #include <avr/io.h>
  26:AvrXSimpleSerial.c **** #include <avr/interrupt.h>
  27:AvrXSimpleSerial.c **** #include "avrx.h"
  28:AvrXSimpleSerial.c **** #include "AvrXSerialIo.h"
  29:AvrXSimpleSerial.c **** 
  30:AvrXSimpleSerial.c **** #if USART_CHANNELS & CHANNEL_0
  31:AvrXSimpleSerial.c **** 
  32:AvrXSimpleSerial.c **** Mutex Rx0Ready, Tx0Ready;
  33:AvrXSimpleSerial.c **** 
  34:AvrXSimpleSerial.c **** void InitSerial0(uint16_t ubrr)
  35:AvrXSimpleSerial.c **** {
  85               	.LM0:
  86               	/* prologue: frame size=0 */
  87               	/* prologue end (size=0) */
  36:AvrXSimpleSerial.c **** // Two USARTs, not shared
  37:AvrXSimpleSerial.c **** #if defined(__AVR_ATmega128__) || defined(__AVR_ATmega64__) | defined(__AVR_ATcan128__)
  38:AvrXSimpleSerial.c **** 	UBRR0L = ubrr;
  39:AvrXSimpleSerial.c **** 	UBRR0H = (uint8_t)(ubrr>>8);
  40:AvrXSimpleSerial.c **** 	UCSR0A = (BAUDX == 8)?(1<<U2X):0;
  41:AvrXSimpleSerial.c **** 	UCSR0B = ((1<<TXEN) | (1<<RXEN) | (1<<RXCIE) | (1<<UDRIE));
  42:AvrXSimpleSerial.c **** 	UCSR0C = ((1<<UCSZ1) | (1<<UCSZ0));
  43:AvrXSimpleSerial.c **** 
  44:AvrXSimpleSerial.c **** // Dual USART, old shared UCSRC & UBRRH
  45:AvrXSimpleSerial.c **** #elif defined(__AVR_ATmega162__) | defined(__AVR_ATmega161__)
  46:AvrXSimpleSerial.c **** 	UBRR0L = ubrr;
  47:AvrXSimpleSerial.c **** 	UBRR0H = (uint8_t)(ubrr>>8);
  48:AvrXSimpleSerial.c **** 	UCSR0A = (BAUDX == 8)?(1<<U2X):0;
  49:AvrXSimpleSerial.c **** 	UCSR0B = ((1<<TXEN) | (1<<RXEN) | (1<<RXCIE) | (1<<UDRIE));
  50:AvrXSimpleSerial.c **** #	ifdef (__AVR_ATmega162__)
  51:AvrXSimpleSerial.c **** 	UCSR0C = (1<<URSEL0) | (1<<UCSZ1) | (1<<UCSZ0);
  52:AvrXSimpleSerial.c **** #	endif
  53:AvrXSimpleSerial.c **** 
  54:AvrXSimpleSerial.c **** // One UART (note the missing C register)
  55:AvrXSimpleSerial.c **** #elif defined(__AVR_ATmega163__)
  56:AvrXSimpleSerial.c **** 	UBRR   = ubrr;
  57:AvrXSimpleSerial.c **** 	UBRRHI = (uint8_t)(ubrr>>8);
  58:AvrXSimpleSerial.c **** 	UCSRA  = (BAUDX == 8)?(1<<U2X):0;
  59:AvrXSimpleSerial.c **** 	UCSRB  = ((1<<TXEN) | (1<<RXEN) | (1<<RXCIE) | (1<<UDRIE));
  60:AvrXSimpleSerial.c **** 
  61:AvrXSimpleSerial.c **** // One UART, (Classic)
  62:AvrXSimpleSerial.c **** #elif defined(__AVR_AT90S4414__) | defined(__AVR_AT90S8515__)| defined(__AVR_AT90S8535__)
  63:AvrXSimpleSerial.c **** 	UBRR	= ubrr;
  64:AvrXSimpleSerial.c **** 	UCR		= ((1<<TXEN) | (1<<RXEN) | (1<<RXCIE) | (1<<UDRIE));
  65:AvrXSimpleSerial.c **** #	define UCSRB UCR
  66:AvrXSimpleSerial.c **** 
  67:AvrXSimpleSerial.c **** // One USART, (C register shared)
  68:AvrXSimpleSerial.c **** #elif defined(__AVR_ATmega8__)   | defined(__AVR_ATmega16__)  | defined(__AVR_ATmega32__)  | \
  69:AvrXSimpleSerial.c **** 	  defined(__AVR_ATmega323__) | defined(__AVR_ATmega8515__)| defined(__AVR_ATmega8535__)
  70:AvrXSimpleSerial.c **** 	UBRRL = ubrr;
  89               	.LM1:
  90 0000 89B9      		out 41-0x20,r24
  71:AvrXSimpleSerial.c **** 	UBRRH = (uint8_t)(ubrr>>8);
  92               	.LM2:
  93 0002 892F      		mov r24,r25
  94 0004 9927      		clr r25
  95 0006 80BD      		out 64-0x20,r24
  72:AvrXSimpleSerial.c **** 	UCSRA = (BAUDX == 8)?(1<<U2X):0;
  97               	.LM3:
  98 0008 82E0      		ldi r24,lo8(2)
  99 000a 8BB9      		out 43-0x20,r24
  73:AvrXSimpleSerial.c **** 	UCSRB = ((1<<TXEN) | (1<<RXEN) | (1<<RXCIE) | (1<<UDRIE));
 101               	.LM4:
 102 000c 88EB      		ldi r24,lo8(-72)
 103 000e 8AB9      		out 42-0x20,r24
  74:AvrXSimpleSerial.c **** 	UCSRC = ((1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0));
 105               	.LM5:
 106 0010 86E8      		ldi r24,lo8(-122)
 107 0012 80BD      		out 64-0x20,r24
 108               	/* epilogue: frame size=0 */
 109 0014 0895      		ret
 110               	/* epilogue end (size=1) */
 111               	/* function InitSerial0 size 11 (10) */
 113               	.Lscope0:
 115               		.stabd	78,0,0
 118               	.global	put_c0
 120               	put_c0:
 121               		.stabd	46,0,0
  75:AvrXSimpleSerial.c **** 
  76:AvrXSimpleSerial.c **** // One USART, (C register not shared)
  77:AvrXSimpleSerial.c **** #elif defined(__AVR_ATmega169__) | defined(__AVR_ATmega165__) | defined(__AVR_IOtn2313__)
  78:AvrXSimpleSerial.c **** 	UBRRL = ubrr;
  79:AvrXSimpleSerial.c **** 	UBRRH = (uint8_t)(ubrr>>8);
  80:AvrXSimpleSerial.c **** 	UCSRA = (BAUDX == 8)?(1<<U2X):0;
  81:AvrXSimpleSerial.c **** 	UCSRB = ((1<<TXEN) | (1<<RXEN) | (1<<RXCIE) | (1<<UDRIE));
  82:AvrXSimpleSerial.c **** 	UCSRC = ((1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0));
  83:AvrXSimpleSerial.c **** #else
  84:AvrXSimpleSerial.c **** #   ERROR Dont know about that CPU!
  85:AvrXSimpleSerial.c **** #endif
  86:AvrXSimpleSerial.c **** #ifndef UCSRB
  87:AvrXSimpleSerial.c **** #   define UCSRB UCSR0B
  88:AvrXSimpleSerial.c **** #endif
  89:AvrXSimpleSerial.c **** #ifndef UDR
  90:AvrXSimpleSerial.c **** #	define UDR UDR0
  91:AvrXSimpleSerial.c **** #endif
  92:AvrXSimpleSerial.c **** }
  93:AvrXSimpleSerial.c **** 
  94:AvrXSimpleSerial.c **** int put_c0(char c)	// Non blocking output
  95:AvrXSimpleSerial.c **** {
 123               	.LM6:
 124               	/* prologue: frame size=0 */
 125 0016 1F93      		push r17
 126               	/* prologue end (size=1) */
 127 0018 182F      		mov r17,r24
  96:AvrXSimpleSerial.c **** 	if (AvrXTestSemaphore(&Tx0Ready) == SEM_DONE)
 129               	.LM7:
 130 001a 80E0      		ldi r24,lo8(Tx0Ready)
 131 001c 90E0      		ldi r25,hi8(Tx0Ready)
 132 001e 0E94 0000 		call AvrXTestSemaphore
 133 0022 0197      		sbiw r24,1
 134 0024 19F0      		breq .L4
 136               	.LM8:
 137 0026 8FEF      		ldi r24,lo8(-1)
 138 0028 9FEF      		ldi r25,hi8(-1)
 139 002a 04C0      		rjmp .L6
 140               	.L4:
  97:AvrXSimpleSerial.c **** 	{
  98:AvrXSimpleSerial.c **** 		UDR = c;
 142               	.LM9:
 143 002c 1CB9      		out 44-0x20,r17
  99:AvrXSimpleSerial.c **** 		UCSRB |= (1<<UDRIE);
 145               	.LM10:
 146 002e 559A      		sbi 42-0x20,5
 147 0030 80E0      		ldi r24,lo8(0)
 148 0032 90E0      		ldi r25,hi8(0)
 149               	.L6:
 150               	/* epilogue: frame size=0 */
 151 0034 1F91      		pop r17
 152 0036 0895      		ret
 153               	/* epilogue end (size=2) */
 154               	/* function put_c0 size 18 (15) */
 156               	.Lscope1:
 158               		.stabd	78,0,0
 161               	.global	put_char0
 163               	put_char0:
 164               		.stabd	46,0,0
 100:AvrXSimpleSerial.c **** 		return 0;
 101:AvrXSimpleSerial.c **** 	}
 102:AvrXSimpleSerial.c **** 	else
 103:AvrXSimpleSerial.c **** 		return FIFO_ERR;
 104:AvrXSimpleSerial.c **** }
 105:AvrXSimpleSerial.c **** 
 106:AvrXSimpleSerial.c **** int put_char0( char c)	// Blocking output
 107:AvrXSimpleSerial.c **** {
 166               	.LM11:
 167               	/* prologue: frame size=0 */
 168 0038 1F93      		push r17
 169               	/* prologue end (size=1) */
 170 003a 182F      		mov r17,r24
 108:AvrXSimpleSerial.c **** 	AvrXWaitSemaphore(&Tx0Ready);
 172               	.LM12:
 173 003c 80E0      		ldi r24,lo8(Tx0Ready)
 174 003e 90E0      		ldi r25,hi8(Tx0Ready)
 175 0040 0E94 0000 		call AvrXWaitSemaphore
 109:AvrXSimpleSerial.c **** 	UDR = c;
 177               	.LM13:
 178 0044 1CB9      		out 44-0x20,r17
 110:AvrXSimpleSerial.c **** 	UCSRB |= (1<<UDRIE);
 180               	.LM14:
 181 0046 559A      		sbi 42-0x20,5
 111:AvrXSimpleSerial.c **** 	return 0;
 112:AvrXSimpleSerial.c **** }
 183               	.LM15:
 184 0048 80E0      		ldi r24,lo8(0)
 185 004a 90E0      		ldi r25,hi8(0)
 186               	/* epilogue: frame size=0 */
 187 004c 1F91      		pop r17
 188 004e 0895      		ret
 189               	/* epilogue end (size=2) */
 190               	/* function put_char0 size 12 (9) */
 192               	.Lscope2:
 194               		.stabd	78,0,0
 196               	.global	get_c0
 198               	get_c0:
 199               		.stabd	46,0,0
 113:AvrXSimpleSerial.c **** 
 114:AvrXSimpleSerial.c **** int get_c0(void)	// Non blocking, return status outside of char range
 115:AvrXSimpleSerial.c **** {
 201               	.LM16:
 202               	/* prologue: frame size=0 */
 203               	/* prologue end (size=0) */
 116:AvrXSimpleSerial.c **** 	if (AvrXTestSemaphore(&Rx0Ready) == SEM_DONE)
 205               	.LM17:
 206 0050 80E0      		ldi r24,lo8(Rx0Ready)
 207 0052 90E0      		ldi r25,hi8(Rx0Ready)
 208 0054 0E94 0000 		call AvrXTestSemaphore
 209 0058 0197      		sbiw r24,1
 210 005a 19F0      		breq .L11
 212               	.LM18:
 213 005c 8FEF      		ldi r24,lo8(-1)
 214 005e 9FEF      		ldi r25,hi8(-1)
 215 0060 0895      		ret
 216               	.L11:
 217               	.LBB2:
 117:AvrXSimpleSerial.c **** 	{
 118:AvrXSimpleSerial.c **** 		uint8_t c = UDR;
 219               	.LM19:
 220 0062 8CB1      		in r24,44-0x20
 119:AvrXSimpleSerial.c **** 		UCSRB |= (1<<RXCIE);	// Enable getting the next charactor
 222               	.LM20:
 223 0064 579A      		sbi 42-0x20,7
 120:AvrXSimpleSerial.c **** 		return c;
 225               	.LM21:
 226 0066 9927      		clr r25
 227               	.LBE2:
 121:AvrXSimpleSerial.c **** 	}
 122:AvrXSimpleSerial.c **** 	else
 123:AvrXSimpleSerial.c **** 		return FIFO_ERR;
 124:AvrXSimpleSerial.c **** }
 229               	.LM22:
 230 0068 0895      		ret
 231               	/* epilogue: frame size=0 */
 232               	/* epilogue: noreturn */
 233               	/* epilogue end (size=0) */
 234               	/* function get_c0 size 14 (14) */
 239               	.Lscope3:
 241               		.stabd	78,0,0
 243               	.global	get_char0
 245               	get_char0:
 246               		.stabd	46,0,0
 125:AvrXSimpleSerial.c **** 
 126:AvrXSimpleSerial.c **** int get_char0(void)	// Blocks waiting for something
 127:AvrXSimpleSerial.c **** {
 248               	.LM23:
 249               	/* prologue: frame size=0 */
 250               	/* prologue end (size=0) */
 128:AvrXSimpleSerial.c **** 	AvrXWaitSemaphore(&Rx0Ready);
 252               	.LM24:
 253 006a 80E0      		ldi r24,lo8(Rx0Ready)
 254 006c 90E0      		ldi r25,hi8(Rx0Ready)
 255 006e 0E94 0000 		call AvrXWaitSemaphore
 129:AvrXSimpleSerial.c **** 	uint8_t c = UDR;
 257               	.LM25:
 258 0072 8CB1      		in r24,44-0x20
 130:AvrXSimpleSerial.c **** 	UCSRB |= (1<<RXCIE);	// Enable getting the next charactor
 260               	.LM26:
 261 0074 579A      		sbi 42-0x20,7
 131:AvrXSimpleSerial.c **** 	return c;
 132:AvrXSimpleSerial.c **** }
 263               	.LM27:
 264 0076 9927      		clr r25
 265               	/* epilogue: frame size=0 */
 266 0078 0895      		ret
 267               	/* epilogue end (size=1) */
 268               	/* function get_char0 size 8 (7) */
 273               	.Lscope4:
 275               		.stabd	78,0,0
 277               	.global	__vector_13
 279               	__vector_13:
 280               		.stabd	46,0,0
 133:AvrXSimpleSerial.c **** /*
 134:AvrXSimpleSerial.c **** This handler will buffer up to three characters in hardware. (double buffer +
 135:AvrXSimpleSerial.c **** input shift register).  The semaphore is used to signal the task that one or more
 136:AvrXSimpleSerial.c **** characters are ready.  The task routines re-enables the interrupt to fetch the next
 137:AvrXSimpleSerial.c **** character.  By using SetSemaphore & TestSemaphore the processing overhead is very
 138:AvrXSimpleSerial.c **** light.  The only time it gets heavy is when the receiving task blocks.
 139:AvrXSimpleSerial.c **** */
 140:AvrXSimpleSerial.c **** 
 141:AvrXSimpleSerial.c **** #if defined(SIG_UART_RECV) && !defined(SIG_UART0_RECV)
 142:AvrXSimpleSerial.c **** #  define SIG_UART0_RECV SIG_UART_RECV
 143:AvrXSimpleSerial.c **** #  define SIG_UART0_DATA SIG_UART_DATA
 144:AvrXSimpleSerial.c **** #endif
 145:AvrXSimpleSerial.c **** 
 146:AvrXSimpleSerial.c **** AVRX_SIGINT(SIG_UART0_RECV)
 147:AvrXSimpleSerial.c **** {
 282               	.LM28:
 283               	/* prologue: frame size=0 */
 284               	/* prologue: naked */
 285               	/* prologue end (size=0) */
 148:AvrXSimpleSerial.c ****     IntProlog();
 287               	.LM29:
 288 007a 0E94 0000 		call IntProlog
 149:AvrXSimpleSerial.c ****     UCSRB &= ~(1<<RXCIE);	// Disable Rx interrupt
 290               	.LM30:
 291 007e 5798      		cbi 42-0x20,7
 150:AvrXSimpleSerial.c ****     sei();					// Allow other interrupt activity to occur
 293               	.LM31:
 294               	/* #APP */
 295 0080 7894      		sei
 151:AvrXSimpleSerial.c **** 	AvrXSetSemaphore(&Rx0Ready);
 297               	.LM32:
 298               	/* #NOAPP */
 299 0082 80E0      		ldi r24,lo8(Rx0Ready)
 300 0084 90E0      		ldi r25,hi8(Rx0Ready)
 301 0086 0E94 0000 		call AvrXSetSemaphore
 152:AvrXSimpleSerial.c **** 	Epilog();
 303               	.LM33:
 304 008a 0E94 0000 		call Epilog
 305               	/* epilogue: frame size=0 */
 306               	/* epilogue: naked */
 307               	/* epilogue end (size=0) */
 308               	/* function __vector_13 size 11 (11) */
 310               	.Lscope5:
 312               		.stabd	78,0,0
 314               	.global	__vector_14
 316               	__vector_14:
 317               		.stabd	46,0,0
 153:AvrXSimpleSerial.c **** }
 154:AvrXSimpleSerial.c **** 
 155:AvrXSimpleSerial.c **** AVRX_SIGINT(SIG_UART0_DATA)
 156:AvrXSimpleSerial.c **** {
 319               	.LM34:
 320               	/* prologue: frame size=0 */
 321               	/* prologue: naked */
 322               	/* prologue end (size=0) */
 157:AvrXSimpleSerial.c ****     IntProlog();
 324               	.LM35:
 325 008e 0E94 0000 		call IntProlog
 158:AvrXSimpleSerial.c ****     UCSRB &= ~(1<<UDRIE);			// Disable UDRE interrupt
 327               	.LM36:
 328 0092 5598      		cbi 42-0x20,5
 159:AvrXSimpleSerial.c ****     sei();							// Allow other stuff to happen
 330               	.LM37:
 331               	/* #APP */
 332 0094 7894      		sei
 160:AvrXSimpleSerial.c **** 	AvrXSetSemaphore(&Tx0Ready);
 334               	.LM38:
 335               	/* #NOAPP */
 336 0096 80E0      		ldi r24,lo8(Tx0Ready)
 337 0098 90E0      		ldi r25,hi8(Tx0Ready)
 338 009a 0E94 0000 		call AvrXSetSemaphore
 161:AvrXSimpleSerial.c **** 	Epilog();
 340               	.LM39:
 341 009e 0E94 0000 		call Epilog
 342               	/* epilogue: frame size=0 */
 343               	/* epilogue: naked */
 344               	/* epilogue end (size=0) */
 345               	/* function __vector_14 size 11 (11) */
 347               	.Lscope6:
 349               		.stabd	78,0,0
 352               		.comm Tx0Ready,2,1
 353               		.comm Rx0Ready,2,1
 355               	.Letext0:
 356               	/* File "AvrXSimpleSerial.c": code   85 = 0x0055 (  77), prologues   2, epilogues   6 */
DEFINED SYMBOLS
                            *ABS*:00000000 AvrXSimpleSerial.c
/var/tmp//ccQ9GvqK.s:3      *ABS*:0000003f __SREG__
/var/tmp//ccQ9GvqK.s:4      *ABS*:0000003e __SP_H__
/var/tmp//ccQ9GvqK.s:5      *ABS*:0000003d __SP_L__
/var/tmp//ccQ9GvqK.s:6      *ABS*:00000000 __tmp_reg__
/var/tmp//ccQ9GvqK.s:7      *ABS*:00000001 __zero_reg__
/var/tmp//ccQ9GvqK.s:82     .text:00000000 InitSerial0
/var/tmp//ccQ9GvqK.s:120    .text:00000016 put_c0
                            *COM*:00000002 Tx0Ready
/var/tmp//ccQ9GvqK.s:163    .text:00000038 put_char0
/var/tmp//ccQ9GvqK.s:198    .text:00000050 get_c0
                            *COM*:00000002 Rx0Ready
/var/tmp//ccQ9GvqK.s:245    .text:0000006a get_char0
/var/tmp//ccQ9GvqK.s:279    .text:0000007a __vector_13
/var/tmp//ccQ9GvqK.s:316    .text:0000008e __vector_14

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
AvrXTestSemaphore
AvrXWaitSemaphore
IntProlog
AvrXSetSemaphore
Epilog
