   1               		.file	"SerialExample.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
 145               	.global	marktribeTcb
 146               		.section	.progmem.data,"a",@progbits
 149               	marktribeTcb:
 150 0000 0000      		.word	marktribeStk+104
 151 0002 0000      		.word	pm(marktribe)
 152 0004 0000      		.word	marktribePid
 153 0006 03        		.byte	3
 154               	.global	getCommandsTcb
 157               	getCommandsTcb:
 158 0007 0000      		.word	getCommandsStk+134
 159 0009 0000      		.word	pm(getCommands)
 160 000b 0000      		.word	getCommandsPid
 161 000d 05        		.byte	5
 162               	.global	getPitchAndRollTcb
 165               	getPitchAndRollTcb:
 166 000e 0000      		.word	getPitchAndRollStk+110
 167 0010 0000      		.word	pm(getPitchAndRoll)
 168 0012 0000      		.word	getPitchAndRollPid
 169 0014 04        		.byte	4
 170               	.global	getFuelAndBatteryTcb
 173               	getFuelAndBatteryTcb:
 174 0015 0000      		.word	getFuelAndBatteryStk+110
 175 0017 0000      		.word	pm(getFuelAndBattery)
 176 0019 0000      		.word	getFuelAndBatteryPid
 177 001b 04        		.byte	4
 178               	.global	getGPSDataTcb
 181               	getGPSDataTcb:
 182 001c 0000      		.word	getGPSDataStk+110
 183 001e 0000      		.word	pm(getGPSData)
 184 0020 0000      		.word	getGPSDataPid
 185 0022 04        		.byte	4
 186               	.global	getGroundspeedTcb
 189               	getGroundspeedTcb:
 190 0023 0000      		.word	getGroundspeedStk+110
 191 0025 0000      		.word	pm(getGroundspeed)
 192 0027 0000      		.word	getGroundspeedPid
 193 0029 04        		.byte	4
 194               	.global	getAirspeedTcb
 197               	getAirspeedTcb:
 198 002a 0000      		.word	getAirspeedStk+110
 199 002c 0000      		.word	pm(getAirspeed)
 200 002e 0000      		.word	getAirspeedPid
 201 0030 04        		.byte	4
 202               	.global	getCompassHeadingTcb
 205               	getCompassHeadingTcb:
 206 0031 0000      		.word	getCompassHeadingStk+110
 207 0033 0000      		.word	pm(getCompassHeading)
 208 0035 0000      		.word	getCompassHeadingPid
 209 0037 04        		.byte	4
 210               	.global	getUAVStatusTcb
 213               	getUAVStatusTcb:
 214 0038 0000      		.word	getUAVStatusStk+110
 215 003a 0000      		.word	pm(getUAVStatus)
 216 003c 0000      		.word	getUAVStatusPid
 217 003e 04        		.byte	4
 218               	.global	leftServoPos
 219               		.data
 222               	leftServoPos:
 223 0000 3200      		.word	50
 224               	.global	TimerRTCPrescaleFactor
 225               		.section	.progmem.data
 228               	TimerRTCPrescaleFactor:
 229 003f 0000      		.word	0
 230 0041 0100      		.word	1
 231 0043 0800      		.word	8
 232 0045 2000      		.word	32
 233 0047 4000      		.word	64
 234 0049 8000      		.word	128
 235 004b 0001      		.word	256
 236 004d 0004      		.word	1024
 237               	.global	TimerPrescaleFactor
 240               	TimerPrescaleFactor:
 241 004f 0000      		.word	0
 242 0051 0100      		.word	1
 243 0053 0800      		.word	8
 244 0055 4000      		.word	64
 245 0057 0001      		.word	256
 246 0059 0004      		.word	1024
 247               		.text
 249               	.global	parserInit
 251               	parserInit:
 253               	.Ltext1:
   1:parser.c      **** #include <avr/io.h>			// include I/O definitions (port names, pin names, etc)
   2:parser.c      **** #include <avr/interrupt.h>	// include interrupt support
   3:parser.c      **** #include <avr/pgmspace.h>	// include AVR program memory support
   4:parser.c      **** #include <string.h>			// include standard C string functions
   5:parser.c      **** #include <stdlib.h>			// include stdlib for string conversion functions
   6:parser.c      **** 
   7:parser.c      **** 
   8:parser.c      **** #include "parser.h"
   9:parser.c      **** #include "parserconf.h"
  10:parser.c      **** 
  11:parser.c      **** 
  12:parser.c      **** 
  13:parser.c      **** // command list
  14:parser.c      **** char CommandList[MAX_COMMANDS][MAX_CMD_LENGTH];
  15:parser.c      **** // command function pointer list
  16:parser.c      **** ParserFuncPtrType ParserFunctionList[MAX_COMMANDS];
  17:parser.c      **** // number of commands currently registered
  18:parser.c      **** unsigned char parserNumCommands;
  19:parser.c      **** //current length of input buffer
  20:parser.c      **** unsigned char parserBufferLength;
  21:parser.c      **** //buffer into which commands are written as they come through
  22:parser.c      **** unsigned char parserBuffer[BUFFERSIZE];
  23:parser.c      **** 
  24:parser.c      **** ParserFuncPtrType ParserExecFunction;
  25:parser.c      **** 
  26:parser.c      **** // function pointer to single character output routine
  27:parser.c      **** void (*parserOutputFunc)(unsigned char c);
  28:parser.c      **** 
  29:parser.c      **** 
  30:parser.c      **** void parserInit(void)
  31:parser.c      **** {
 255               	.LM1:
 256               	/* prologue: frame size=0 */
 257               	/* prologue end (size=0) */
  32:parser.c      **** 	// initialize input buffer
  33:parser.c      **** 	parserBufferLength = 0;
 259               	.LM2:
 260 0000 1092 0000 		sts parserBufferLength,__zero_reg__
  34:parser.c      **** 	// initialize executing function
  35:parser.c      **** 	ParserExecFunction = 0;
 262               	.LM3:
 263 0004 1092 0000 		sts (ParserExecFunction)+1,__zero_reg__
 264 0008 1092 0000 		sts ParserExecFunction,__zero_reg__
  36:parser.c      **** 	// initialize command list
  37:parser.c      **** 	parserNumCommands = 0;
 266               	.LM4:
 267 000c 1092 0000 		sts parserNumCommands,__zero_reg__
 268               	/* epilogue: frame size=0 */
 269 0010 0895      		ret
 270               	/* epilogue end (size=1) */
 271               	/* function parserInit size 9 (8) */
 273               	.Lscope0:
 278               	.global	parserAddCommand
 280               	parserAddCommand:
  38:parser.c      **** }
  39:parser.c      **** 
  40:parser.c      **** 
  41:parser.c      **** void parserAddCommand(unsigned char* newCmdString, ParserFuncPtrType newCmdFuncPtr)
  42:parser.c      **** {
 282               	.LM5:
 283               	/* prologue: frame size=0 */
 284 0012 0F93      		push r16
 285 0014 1F93      		push r17
 286               	/* prologue end (size=2) */
 287 0016 9C01      		movw r18,r24
 288 0018 8B01      		movw r16,r22
  43:parser.c      **** 	// add command string to end of command list
  44:parser.c      **** 	strcpy(CommandList[parserNumCommands], newCmdString);
 290               	.LM6:
 291 001a 9091 0000 		lds r25,parserNumCommands
 292 001e 8FE0      		ldi r24,lo8(15)
 293 0020 989F      		mul r25,r24
 294 0022 C001      		movw r24,r0
 295 0024 1124      		clr r1
 296 0026 B901      		movw r22,r18
 297 0028 8050      		subi r24,lo8(-(CommandList))
 298 002a 9040      		sbci r25,hi8(-(CommandList))
 299 002c 0E94 0000 		call strcpy
  45:parser.c      **** 	// add command function ptr to end of function list
  46:parser.c      **** 	ParserFunctionList[parserNumCommands] = newCmdFuncPtr;
 301               	.LM7:
 302 0030 8091 0000 		lds r24,parserNumCommands
 303 0034 E82F      		mov r30,r24
 304 0036 FF27      		clr r31
 305 0038 EE0F      		add r30,r30
 306 003a FF1F      		adc r31,r31
 307 003c E050      		subi r30,lo8(-(ParserFunctionList))
 308 003e F040      		sbci r31,hi8(-(ParserFunctionList))
 309 0040 1183      		std Z+1,r17
 310 0042 0083      		st Z,r16
  47:parser.c      **** 	// increment number of registered commands
  48:parser.c      **** 	parserNumCommands++;
 312               	.LM8:
 313 0044 8F5F      		subi r24,lo8(-(1))
 314 0046 8093 0000 		sts parserNumCommands,r24
 315               	/* epilogue: frame size=0 */
 316 004a 1F91      		pop r17
 317 004c 0F91      		pop r16
 318 004e 0895      		ret
 319               	/* epilogue end (size=3) */
 320               	/* function parserAddCommand size 31 (26) */
 322               	.Lscope1:
 326               	.global	parserSetOutputFunc
 328               	parserSetOutputFunc:
  49:parser.c      **** }
  50:parser.c      **** 
  51:parser.c      **** 
  52:parser.c      **** void parserSetOutputFunc(void (*output_func)(unsigned char c))
  53:parser.c      **** {
 330               	.LM9:
 331               	/* prologue: frame size=0 */
 332               	/* prologue end (size=0) */
  54:parser.c      **** 	// set new output function
  55:parser.c      **** 	parserOutputFunc = output_func;
 334               	.LM10:
 335 0050 9093 0000 		sts (parserOutputFunc)+1,r25
 336 0054 8093 0000 		sts parserOutputFunc,r24
 337               	/* epilogue: frame size=0 */
 338 0058 0895      		ret
 339               	/* epilogue end (size=1) */
 340               	/* function parserSetOutputFunc size 5 (4) */
 342               	.Lscope2:
 345               	.global	parserProcessInputString
 347               	parserProcessInputString:
  56:parser.c      **** }
  57:parser.c      **** 
  58:parser.c      **** 
  59:parser.c      **** void parserInputFunc(unsigned char c)
  60:parser.c      **** {
  61:parser.c      **** 	// process the received character
  62:parser.c      **** 	
  63:parser.c      **** 	if (c != '\r')		//anything other than return character must be a part of the command
  64:parser.c      **** 	{	
  65:parser.c      **** 		// echo character to the output
  66:parser.c      **** //		parserOutputFunc(c);
  67:parser.c      **** 		// add it to the command line buffer
  68:parser.c      **** 		parserBuffer[parserBufferLength] = c;
  69:parser.c      **** 		// update buffer length
  70:parser.c      **** 		parserBufferLength++;
  71:parser.c      **** 	}
  72:parser.c      **** 	else				//return character -> process command
  73:parser.c      **** 	{
  74:parser.c      **** 		// add null termination to command
  75:parser.c      **** 		parserBuffer[parserBufferLength] = 0;
  76:parser.c      **** 		// command is complete, process it
  77:parser.c      **** 		parserProcessInputString();
  78:parser.c      **** 		// reset buffer
  79:parser.c      **** 		parserBufferLength = 0;
  80:parser.c      **** 	}
  81:parser.c      **** }
  82:parser.c      **** 
  83:parser.c      **** 
  84:parser.c      **** void parserProcessInputString(void)
  85:parser.c      **** {
 349               	.LM11:
 350               	/* prologue: frame size=0 */
 351 005a 1F93      		push r17
 352 005c CF93      		push r28
 353 005e DF93      		push r29
 354               	/* prologue end (size=3) */
  86:parser.c      **** 	unsigned char cmdIndex;
  87:parser.c      **** 
  88:parser.c      **** 	// search command list for match with entered command
  89:parser.c      **** 	for(cmdIndex=0; cmdIndex<parserNumCommands; cmdIndex++)
 356               	.LM12:
 357 0060 10E0      		ldi r17,lo8(0)
 358 0062 8091 0000 		lds r24,parserNumCommands
 359 0066 1817      		cp r17,r24
 360 0068 48F5      		brsh .L11
 361               	.L9:
  90:parser.c      **** 	{
  91:parser.c      **** 		if( !strncmp(CommandList[cmdIndex], parserBuffer, 1) )		//command is first char of buffer
 363               	.LM13:
 364 006a A12F      		mov r26,r17
 365 006c BB27      		clr r27
 366 006e FD01      		movw r30,r26
 367 0070 84E0      		ldi r24,4
 368 0072 EE0F      	1:	lsl r30
 369 0074 FF1F      		rol r31
 370 0076 8A95      		dec r24
 371 0078 E1F7      		brne 1b
 372 007a EA1B      		sub r30,r26
 373 007c FB0B      		sbc r31,r27
 374 007e E050      		subi r30,lo8(-(CommandList))
 375 0080 F040      		sbci r31,hi8(-(CommandList))
 376 0082 8081      		ld r24,Z
 377 0084 C82F      		mov r28,r24
 378 0086 DD27      		clr r29
 379 0088 8091 0000 		lds r24,parserBuffer
 380 008c C81B      		sub r28,r24
 381 008e D109      		sbc r29,__zero_reg__
 382 0090 2097      		sbiw r28,0
 383 0092 79F4      		brne .L7
  92:parser.c      **** 		{
  93:parser.c      **** 			// user-entered command matched a command in the list (database)
  94:parser.c      **** 			ParserExecFunction = ParserFunctionList[cmdIndex];
 385               	.LM14:
 386 0094 AA0F      		add r26,r26
 387 0096 BB1F      		adc r27,r27
 388 0098 A050      		subi r26,lo8(-(ParserFunctionList))
 389 009a B040      		sbci r27,hi8(-(ParserFunctionList))
 390 009c ED91      		ld r30,X+
 391 009e FC91      		ld r31,X
 392 00a0 F093 0000 		sts (ParserExecFunction)+1,r31
 393 00a4 E093 0000 		sts ParserExecFunction,r30
  95:parser.c      **** 			// run the corresponding function
  96:parser.c      **** 			ParserExecFunction();
 395               	.LM15:
 396 00a8 0995      		icall
  97:parser.c      **** 			// reset
  98:parser.c      **** 			ParserExecFunction = 0;
 398               	.LM16:
 399 00aa D093 0000 		sts (ParserExecFunction)+1,r29
 400 00ae C093 0000 		sts ParserExecFunction,r28
 401               	.L7:
 403               	.LM17:
 404 00b2 1F5F      		subi r17,lo8(-(1))
 405 00b4 8091 0000 		lds r24,parserNumCommands
 406 00b8 1817      		cp r17,r24
 407 00ba B8F2      		brlo .L9
 408               	.L11:
 409               	/* epilogue: frame size=0 */
 410 00bc DF91      		pop r29
 411 00be CF91      		pop r28
 412 00c0 1F91      		pop r17
 413 00c2 0895      		ret
 414               	/* epilogue end (size=4) */
 415               	/* function parserProcessInputString size 53 (46) */
 420               	.Lscope3:
 424               	.global	parserInputFunc
 426               	parserInputFunc:
 428               	.LM18:
 429               	/* prologue: frame size=0 */
 430               	/* prologue end (size=0) */
 431 00c4 9091 0000 		lds r25,parserBufferLength
 433               	.LM19:
 434 00c8 8D30      		cpi r24,lo8(13)
 435 00ca 49F0      		breq .L13
 437               	.LM20:
 438 00cc E92F      		mov r30,r25
 439 00ce FF27      		clr r31
 440 00d0 E050      		subi r30,lo8(-(parserBuffer))
 441 00d2 F040      		sbci r31,hi8(-(parserBuffer))
 442 00d4 8083      		st Z,r24
 444               	.LM21:
 445 00d6 9F5F      		subi r25,lo8(-(1))
 446 00d8 9093 0000 		sts parserBufferLength,r25
 447 00dc 0895      		ret
 448               	.L13:
 450               	.LM22:
 451 00de E92F      		mov r30,r25
 452 00e0 FF27      		clr r31
 453 00e2 E050      		subi r30,lo8(-(parserBuffer))
 454 00e4 F040      		sbci r31,hi8(-(parserBuffer))
 455 00e6 1082      		st Z,__zero_reg__
 457               	.LM23:
 458 00e8 0E94 0000 		call parserProcessInputString
 460               	.LM24:
 461 00ec 1092 0000 		sts parserBufferLength,__zero_reg__
 462 00f0 0895      		ret
 463               	/* epilogue: frame size=0 */
 464               	/* epilogue: noreturn */
 465               	/* epilogue end (size=0) */
 466               	/* function parserInputFunc size 23 (23) */
 468               	.Lscope4:
 471               	.global	parserGetArgStr
 473               	parserGetArgStr:
  99:parser.c      **** 		}
 100:parser.c      **** 	}
 101:parser.c      **** }
 102:parser.c      **** 
 103:parser.c      **** // return string pointer to argument [argnum]
 104:parser.c      **** unsigned char* parserGetArgStr(void)
 105:parser.c      **** {
 475               	.LM25:
 476               	/* prologue: frame size=0 */
 477               	/* prologue end (size=0) */
 106:parser.c      **** 	return &parserBuffer[2];		//spec states that commands are 1 char followed by a space followed by t
 107:parser.c      **** }									//arg must start at idx 2
 479               	.LM26:
 480 00f2 80E0      		ldi r24,lo8(parserBuffer+2)
 481 00f4 90E0      		ldi r25,hi8(parserBuffer+2)
 482               	/* epilogue: frame size=0 */
 483 00f6 0895      		ret
 484               	/* epilogue end (size=1) */
 485               	/* function parserGetArgStr size 3 (2) */
 487               	.Lscope5:
 490               	.global	parserGetArgInt
 492               	parserGetArgInt:
 108:parser.c      **** 
 109:parser.c      **** //return argument as a long
 110:parser.c      **** int parserGetArgInt(void)
 111:parser.c      **** {
 494               	.LM27:
 495               	/* prologue: frame size=0 */
 496               	/* prologue end (size=0) */
 112:parser.c      **** 	char* endptr;
 113:parser.c      **** 	return atoi(parserGetArgStr());
 498               	.LM28:
 499 00f8 0E94 0000 		call parserGetArgStr
 500 00fc 0E94 0000 		call atoi
 501               	/* epilogue: frame size=0 */
 502 0100 0895      		ret
 503               	/* epilogue end (size=1) */
 504               	/* function parserGetArgInt size 5 (4) */
 506               	.Lscope6:
 510               	.global	delay_us
 512               	delay_us:
 514               	.Ltext2:
   1:timer.c       **** /*! \file timer.c \brief System Timer function library. */
   2:timer.c       **** //*****************************************************************************
   3:timer.c       **** //
   4:timer.c       **** // File Name	: 'timer.c'
   5:timer.c       **** // Title		: System Timer function library
   6:timer.c       **** // Author		: Pascal Stang - Copyright (C) 2000-2002
   7:timer.c       **** // Created		: 11/22/2000
   8:timer.c       **** // Revised		: 07/09/2003
   9:timer.c       **** // Version		: 1.1
  10:timer.c       **** // Target MCU	: Atmel AVR Series
  11:timer.c       **** // Editor Tabs	: 4
  12:timer.c       **** //
  13:timer.c       **** // This code is distributed under the GNU Public License
  14:timer.c       **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
  15:timer.c       **** //
  16:timer.c       **** //*****************************************************************************
  17:timer.c       **** 
  18:timer.c       **** #ifndef WIN32
  19:timer.c       **** 	#include <avr/io.h>
  20:timer.c       **** 	#include <avr/signal.h>
  21:timer.c       **** 	#include <avr/interrupt.h>
  22:timer.c       **** 	#include <avr/pgmspace.h>
  23:timer.c       **** 	#include <avr/sleep.h>
  24:timer.c       **** #endif
  25:timer.c       **** 
  26:timer.c       **** #include "global.h"
  27:timer.c       **** #include "timer.h"
  28:timer.c       **** 
  29:timer.c       **** //#include "rprintf.h"
  30:timer.c       **** 
  31:timer.c       **** // Program ROM constants
  32:timer.c       **** // the prescale division values stored in order of timer control register index
  33:timer.c       **** // STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024
  34:timer.c       **** unsigned short __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,1,8,64,256,1024};
  35:timer.c       **** // the prescale division values stored in order of timer control register index
  36:timer.c       **** // STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024
  37:timer.c       **** unsigned short __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,1,8,32,64,128,256,1024};
  38:timer.c       **** 
  39:timer.c       **** // Global variables
  40:timer.c       **** // time registers
  41:timer.c       **** volatile unsigned long TimerPauseReg;
  42:timer.c       **** volatile unsigned long Timer0Reg0;
  43:timer.c       **** volatile unsigned long Timer2Reg0;
  44:timer.c       **** 
  45:timer.c       **** typedef void (*voidFuncPtr)(void);
  46:timer.c       **** volatile static voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
  47:timer.c       **** 
  48:timer.c       **** // delay for a minimum of <us> microseconds 
  49:timer.c       **** // the time resolution is dependent on the time the loop takes 
  50:timer.c       **** // e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us 
  51:timer.c       **** void delay_us(unsigned short time_us) 
  52:timer.c       **** {
 516               	.LM29:
 517               	/* prologue: frame size=0 */
 518               	/* prologue end (size=0) */
  53:timer.c       **** 	unsigned short delay_loops;
  54:timer.c       **** 	register unsigned short i;
  55:timer.c       **** 
  56:timer.c       **** 	delay_loops = (time_us+3)/5*CYCLES_PER_US; // +3 for rounding up (dirty) 
 520               	.LM30:
 521 0102 0396      		adiw r24,3
 522 0104 65E0      		ldi r22,lo8(5)
 523 0106 70E0      		ldi r23,hi8(5)
 524 0108 0E94 0000 		call __udivmodhi4
 525 010c CB01      		movw r24,r22
 526 010e AA27      		clr r26
 527 0110 BB27      		clr r27
 528 0112 24E0      		ldi r18,4
 529 0114 880F      	1:	lsl r24
 530 0116 991F      		rol r25
 531 0118 AA1F      		rol r26
 532 011a BB1F      		rol r27
 533 011c 2A95      		dec r18
 534 011e D1F7      		brne 1b
 535               	.L24:
  57:timer.c       **** 
  58:timer.c       **** 	// one loop takes 5 cpu cycles 
  59:timer.c       **** 	for (i=0; i < delay_loops; i++) {};
 537               	.LM31:
 538 0120 0097      		sbiw r24,0
 539 0122 11F0      		breq .L23
 540 0124 0197      		sbiw r24,1
 541 0126 FCCF      		rjmp .L24
 542               	.L23:
 543 0128 0895      		ret
 544               	/* epilogue: frame size=0 */
 545               	/* epilogue: noreturn */
 546               	/* epilogue end (size=0) */
 547               	/* function delay_us size 20 (20) */
 553               	.Lscope7:
 557               	.global	timerDetach
 559               	timerDetach:
  60:timer.c       **** }
  61:timer.c       **** /*
  62:timer.c       **** void delay_ms(unsigned char time_ms)
  63:timer.c       **** {
  64:timer.c       **** 	unsigned short delay_count = F_CPU / 4000;
  65:timer.c       **** 
  66:timer.c       **** 	unsigned short cnt;
  67:timer.c       **** 	asm volatile ("\n"
  68:timer.c       ****                   "L_dl1%=:\n\t"
  69:timer.c       ****                   "mov %A0, %A2\n\t"
  70:timer.c       ****                   "mov %B0, %B2\n"
  71:timer.c       ****                   "L_dl2%=:\n\t"
  72:timer.c       ****                   "sbiw %A0, 1\n\t"
  73:timer.c       ****                   "brne L_dl2%=\n\t"
  74:timer.c       ****                   "dec %1\n\t" "brne L_dl1%=\n\t":"=&w" (cnt)
  75:timer.c       ****                   :"r"(time_ms), "r"((unsigned short) (delay_count))
  76:timer.c       **** 	);
  77:timer.c       **** }
  78:timer.c       **** */
  79:timer.c       **** void timerInit(void)
  80:timer.c       **** {
  81:timer.c       **** 	u08 intNum;
  82:timer.c       **** 	// detach all user functions from interrupts
  83:timer.c       **** 	for(intNum=0; intNum<TIMER_NUM_INTERRUPTS; intNum++)
  84:timer.c       **** 		timerDetach(intNum);
  85:timer.c       **** 
  86:timer.c       **** 	// initialize all timers
  87:timer.c       **** 	timer0Init();
  88:timer.c       **** 	timer1Init();
  89:timer.c       **** 	#ifdef TCNT2	// support timer2 only if it exists
  90:timer.c       **** 	timer2Init();
  91:timer.c       **** 	#endif
  92:timer.c       **** 	// enable interrupts
  93:timer.c       **** 	sei();
  94:timer.c       **** }
  95:timer.c       **** 
  96:timer.c       **** void timer0Init()
  97:timer.c       **** {
  98:timer.c       **** 	// initialize timer 0
  99:timer.c       **** 	timer0SetPrescaler( TIMER0PRESCALE );	// set prescaler
 100:timer.c       **** 	outb(TCNT0, 0);							// reset TCNT0
 101:timer.c       **** 	sbi(TIMSK, TOIE0);						// enable TCNT0 overflow interrupt
 102:timer.c       **** 
 103:timer.c       **** 	timer0ClearOverflowCount();				// initialize time registers
 104:timer.c       **** }
 105:timer.c       **** 
 106:timer.c       **** void timer1Init(void)
 107:timer.c       **** {
 108:timer.c       **** 	// initialize timer 1
 109:timer.c       **** 	timer1SetPrescaler( TIMER1PRESCALE );	// set prescaler
 110:timer.c       **** 	outb(TCNT1H, 0);						// reset TCNT1
 111:timer.c       **** 	outb(TCNT1L, 0);
 112:timer.c       **** 	sbi(TIMSK, TOIE1);						// enable TCNT1 overflow
 113:timer.c       **** }
 114:timer.c       **** 
 115:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 116:timer.c       **** void timer2Init(void)
 117:timer.c       **** {
 118:timer.c       **** 	// initialize timer 2
 119:timer.c       **** 	timer2SetPrescaler( TIMER2PRESCALE );	// set prescaler
 120:timer.c       **** 	outb(TCNT2, 0);							// reset TCNT2
 121:timer.c       **** 	sbi(TIMSK, TOIE2);						// enable TCNT2 overflow
 122:timer.c       **** 
 123:timer.c       **** 	timer2ClearOverflowCount();				// initialize time registers
 124:timer.c       **** }
 125:timer.c       **** #endif
 126:timer.c       **** 
 127:timer.c       **** void timer0SetPrescaler(u08 prescale)
 128:timer.c       **** {
 129:timer.c       **** 	// set prescaler on timer 0
 130:timer.c       **** 	outb(TCCR0, (inb(TCCR0) & ~TIMER_PRESCALE_MASK) | prescale);
 131:timer.c       **** }
 132:timer.c       **** 
 133:timer.c       **** void timer1SetPrescaler(u08 prescale)
 134:timer.c       **** {
 135:timer.c       **** 	// set prescaler on timer 1
 136:timer.c       **** 	outb(TCCR1B, (inb(TCCR1B) & ~TIMER_PRESCALE_MASK) | prescale);
 137:timer.c       **** }
 138:timer.c       **** 
 139:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 140:timer.c       **** void timer2SetPrescaler(u08 prescale)
 141:timer.c       **** {
 142:timer.c       **** 	// set prescaler on timer 2
 143:timer.c       **** 	outb(TCCR2, (inb(TCCR2) & ~TIMER_PRESCALE_MASK) | prescale);
 144:timer.c       **** }
 145:timer.c       **** #endif
 146:timer.c       **** 
 147:timer.c       **** u16 timer0GetPrescaler(void)
 148:timer.c       **** {
 149:timer.c       **** 	// get the current prescaler setting
 150:timer.c       **** 	return (pgm_read_word(TimerPrescaleFactor+(inb(TCCR0) & TIMER_PRESCALE_MASK)));
 151:timer.c       **** }
 152:timer.c       **** 
 153:timer.c       **** u16 timer1GetPrescaler(void)
 154:timer.c       **** {
 155:timer.c       **** 	// get the current prescaler setting
 156:timer.c       **** 	return (pgm_read_word(TimerPrescaleFactor+(inb(TCCR1B) & TIMER_PRESCALE_MASK)));
 157:timer.c       **** }
 158:timer.c       **** 
 159:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 160:timer.c       **** u16 timer2GetPrescaler(void)
 161:timer.c       **** {
 162:timer.c       **** 	//TODO: can we assume for all 3-timer AVR processors,
 163:timer.c       **** 	// that timer2 is the RTC timer?
 164:timer.c       **** 
 165:timer.c       **** 	// get the current prescaler setting
 166:timer.c       **** 	return (pgm_read_word(TimerRTCPrescaleFactor+(inb(TCCR2) & TIMER_PRESCALE_MASK)));
 167:timer.c       **** }
 168:timer.c       **** #endif
 169:timer.c       **** 
 170:timer.c       **** void timerAttach(u08 interruptNum, void (*userFunc)(void) )
 171:timer.c       **** {
 172:timer.c       **** 	// make sure the interrupt number is within bounds
 173:timer.c       **** 	if(interruptNum < TIMER_NUM_INTERRUPTS)
 174:timer.c       **** 	{
 175:timer.c       **** 		// set the interrupt function to run
 176:timer.c       **** 		// the supplied user's function
 177:timer.c       **** 		TimerIntFunc[interruptNum] = userFunc;
 178:timer.c       **** 	}
 179:timer.c       **** }
 180:timer.c       **** 
 181:timer.c       **** void timerDetach(u08 interruptNum)
 182:timer.c       **** {
 561               	.LM32:
 562               	/* prologue: frame size=0 */
 563               	/* prologue end (size=0) */
 183:timer.c       **** 	// make sure the interrupt number is within bounds
 184:timer.c       **** 	if(interruptNum < TIMER_NUM_INTERRUPTS)
 565               	.LM33:
 566 012a 8830      		cpi r24,lo8(8)
 567 012c 40F4      		brsh .L25
 185:timer.c       **** 	{
 186:timer.c       **** 		// set the interrupt function to run nothing
 187:timer.c       **** 		TimerIntFunc[interruptNum] = 0;
 569               	.LM34:
 570 012e E82F      		mov r30,r24
 571 0130 FF27      		clr r31
 572 0132 EE0F      		add r30,r30
 573 0134 FF1F      		adc r31,r31
 574 0136 E050      		subi r30,lo8(-(TimerIntFunc))
 575 0138 F040      		sbci r31,hi8(-(TimerIntFunc))
 576 013a 1182      		std Z+1,__zero_reg__
 577 013c 1082      		st Z,__zero_reg__
 578               	.L25:
 579 013e 0895      		ret
 580               	/* epilogue: frame size=0 */
 581               	/* epilogue: noreturn */
 582               	/* epilogue end (size=0) */
 583               	/* function timerDetach size 11 (11) */
 585               	.Lscope8:
 589               	.global	timer0SetPrescaler
 591               	timer0SetPrescaler:
 593               	.LM35:
 594               	/* prologue: frame size=0 */
 595               	/* prologue end (size=0) */
 597               	.LM36:
 598 0140 93B7      		in r25,83-0x20
 599 0142 987F      		andi r25,lo8(-8)
 600 0144 982B      		or r25,r24
 601 0146 93BF      		out 83-0x20,r25
 602               	/* epilogue: frame size=0 */
 603 0148 0895      		ret
 604               	/* epilogue end (size=1) */
 605               	/* function timer0SetPrescaler size 5 (4) */
 607               	.Lscope9:
 610               	.global	timer0ClearOverflowCount
 612               	timer0ClearOverflowCount:
 188:timer.c       **** 	}
 189:timer.c       **** }
 190:timer.c       **** /*
 191:timer.c       **** u32 timerMsToTics(u16 ms)
 192:timer.c       **** {
 193:timer.c       **** 	// calculate the prescaler division rate
 194:timer.c       **** 	u16 prescaleDiv = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));
 195:timer.c       **** 	// calculate the number of timer tics in x milliseconds
 196:timer.c       **** 	return (ms*(F_CPU/(prescaleDiv*256)))/1000;
 197:timer.c       **** }
 198:timer.c       **** 
 199:timer.c       **** u16 timerTicsToMs(u32 tics)
 200:timer.c       **** {
 201:timer.c       **** 	// calculate the prescaler division rate
 202:timer.c       **** 	u16 prescaleDiv = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));
 203:timer.c       **** 	// calculate the number of milliseconds in x timer tics
 204:timer.c       **** 	return (tics*1000*(prescaleDiv*256))/F_CPU;
 205:timer.c       **** }
 206:timer.c       **** */
 207:timer.c       **** void timerPause(unsigned short pause_ms)
 208:timer.c       **** {
 209:timer.c       **** 	// pauses for exactly <pause_ms> number of milliseconds
 210:timer.c       **** 	u08 timerThres;
 211:timer.c       **** 	u32 ticRateHz;
 212:timer.c       **** 	u32 pause;
 213:timer.c       **** 
 214:timer.c       **** 	// capture current pause timer value
 215:timer.c       **** 	timerThres = inb(TCNT0);
 216:timer.c       **** 	// reset pause timer overflow count
 217:timer.c       **** 	TimerPauseReg = 0;
 218:timer.c       **** 	// calculate delay for [pause_ms] milliseconds
 219:timer.c       **** 	// prescaler division = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)))
 220:timer.c       **** 	ticRateHz = F_CPU/timer0GetPrescaler();
 221:timer.c       **** 	// precision management
 222:timer.c       **** 	// prevent overflow and precision underflow
 223:timer.c       **** 	//	-could add more conditions to improve accuracy
 224:timer.c       **** 	if( ((ticRateHz < 429497) && (pause_ms <= 10000)) )
 225:timer.c       **** 		pause = (pause_ms*ticRateHz)/1000;
 226:timer.c       **** 	else
 227:timer.c       **** 		pause = pause_ms*(ticRateHz/1000);
 228:timer.c       **** 
 229:timer.c       **** 	// loop until time expires
 230:timer.c       **** 	while( ((TimerPauseReg<<8) | inb(TCNT0)) < (pause+timerThres) )
 231:timer.c       **** 	{
 232:timer.c       **** 		if( TimerPauseReg < (pause>>8));
 233:timer.c       **** 		{
 234:timer.c       **** 			// save power by idling the processor
 235:timer.c       **** 			set_sleep_mode(SLEEP_MODE_IDLE);
 236:timer.c       **** 			sleep_mode();
 237:timer.c       **** 		}
 238:timer.c       **** 	}
 239:timer.c       **** 
 240:timer.c       **** 	/* old inaccurate code, for reference
 241:timer.c       **** 	
 242:timer.c       **** 	// calculate delay for [pause_ms] milliseconds
 243:timer.c       **** 	u16 prescaleDiv = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));
 244:timer.c       **** 	u32 pause = (pause_ms*(F_CPU/(prescaleDiv*256)))/1000;
 245:timer.c       **** 	
 246:timer.c       **** 	TimerPauseReg = 0;
 247:timer.c       **** 	while(TimerPauseReg < pause);
 248:timer.c       **** 
 249:timer.c       **** 	*/
 250:timer.c       **** }
 251:timer.c       **** 
 252:timer.c       **** void timer0ClearOverflowCount(void)
 253:timer.c       **** {
 614               	.LM37:
 615               	/* prologue: frame size=0 */
 616               	/* prologue end (size=0) */
 254:timer.c       **** 	// clear the timer overflow counter registers
 255:timer.c       **** 	Timer0Reg0 = 0;	// initialize time registers
 618               	.LM38:
 619 014a 1092 0000 		sts Timer0Reg0,__zero_reg__
 620 014e 1092 0000 		sts (Timer0Reg0)+1,__zero_reg__
 621 0152 1092 0000 		sts (Timer0Reg0)+2,__zero_reg__
 622 0156 1092 0000 		sts (Timer0Reg0)+3,__zero_reg__
 623               	/* epilogue: frame size=0 */
 624 015a 0895      		ret
 625               	/* epilogue end (size=1) */
 626               	/* function timer0ClearOverflowCount size 9 (8) */
 628               	.Lscope10:
 631               	.global	timer0Init
 633               	timer0Init:
 635               	.LM39:
 636               	/* prologue: frame size=0 */
 637               	/* prologue end (size=0) */
 639               	.LM40:
 640 015c 82E0      		ldi r24,lo8(2)
 641 015e 0E94 0000 		call timer0SetPrescaler
 643               	.LM41:
 644 0162 12BE      		out 82-0x20,__zero_reg__
 646               	.LM42:
 647 0164 89B7      		in r24,89-0x20
 648 0166 8160      		ori r24,lo8(1)
 649 0168 89BF      		out 89-0x20,r24
 651               	.LM43:
 652 016a 0E94 0000 		call timer0ClearOverflowCount
 653               	/* epilogue: frame size=0 */
 654 016e 0895      		ret
 655               	/* epilogue end (size=1) */
 656               	/* function timer0Init size 10 (9) */
 658               	.Lscope11:
 662               	.global	timer1SetPrescaler
 664               	timer1SetPrescaler:
 666               	.LM44:
 667               	/* prologue: frame size=0 */
 668               	/* prologue end (size=0) */
 670               	.LM45:
 671 0170 9EB5      		in r25,78-0x20
 672 0172 987F      		andi r25,lo8(-8)
 673 0174 982B      		or r25,r24
 674 0176 9EBD      		out 78-0x20,r25
 675               	/* epilogue: frame size=0 */
 676 0178 0895      		ret
 677               	/* epilogue end (size=1) */
 678               	/* function timer1SetPrescaler size 5 (4) */
 680               	.Lscope12:
 683               	.global	timer1Init
 685               	timer1Init:
 687               	.LM46:
 688               	/* prologue: frame size=0 */
 689               	/* prologue end (size=0) */
 691               	.LM47:
 692 017a 83E0      		ldi r24,lo8(3)
 693 017c 0E94 0000 		call timer1SetPrescaler
 695               	.LM48:
 696 0180 1DBC      		out 77-0x20,__zero_reg__
 698               	.LM49:
 699 0182 1CBC      		out 76-0x20,__zero_reg__
 701               	.LM50:
 702 0184 89B7      		in r24,89-0x20
 703 0186 8460      		ori r24,lo8(4)
 704 0188 89BF      		out 89-0x20,r24
 705               	/* epilogue: frame size=0 */
 706 018a 0895      		ret
 707               	/* epilogue end (size=1) */
 708               	/* function timer1Init size 9 (8) */
 710               	.Lscope13:
 714               	.global	timer2SetPrescaler
 716               	timer2SetPrescaler:
 718               	.LM51:
 719               	/* prologue: frame size=0 */
 720               	/* prologue end (size=0) */
 722               	.LM52:
 723 018c 95B5      		in r25,69-0x20
 724 018e 987F      		andi r25,lo8(-8)
 725 0190 982B      		or r25,r24
 726 0192 95BD      		out 69-0x20,r25
 727               	/* epilogue: frame size=0 */
 728 0194 0895      		ret
 729               	/* epilogue end (size=1) */
 730               	/* function timer2SetPrescaler size 5 (4) */
 732               	.Lscope14:
 735               	.global	timer2ClearOverflowCount
 737               	timer2ClearOverflowCount:
 256:timer.c       **** }
 257:timer.c       **** 
 258:timer.c       **** long timer0GetOverflowCount(void)
 259:timer.c       **** {
 260:timer.c       **** 	// return the current timer overflow count
 261:timer.c       **** 	// (this is since the last timer0ClearOverflowCount() command was called)
 262:timer.c       **** 	return Timer0Reg0;
 263:timer.c       **** }
 264:timer.c       **** 
 265:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 266:timer.c       **** void timer2ClearOverflowCount(void)
 267:timer.c       **** {
 739               	.LM53:
 740               	/* prologue: frame size=0 */
 741               	/* prologue end (size=0) */
 268:timer.c       **** 	// clear the timer overflow counter registers
 269:timer.c       **** 	Timer2Reg0 = 0;	// initialize time registers
 743               	.LM54:
 744 0196 1092 0000 		sts Timer2Reg0,__zero_reg__
 745 019a 1092 0000 		sts (Timer2Reg0)+1,__zero_reg__
 746 019e 1092 0000 		sts (Timer2Reg0)+2,__zero_reg__
 747 01a2 1092 0000 		sts (Timer2Reg0)+3,__zero_reg__
 748               	/* epilogue: frame size=0 */
 749 01a6 0895      		ret
 750               	/* epilogue end (size=1) */
 751               	/* function timer2ClearOverflowCount size 9 (8) */
 753               	.Lscope15:
 756               	.global	timer2Init
 758               	timer2Init:
 760               	.LM55:
 761               	/* prologue: frame size=0 */
 762               	/* prologue end (size=0) */
 764               	.LM56:
 765 01a8 84E0      		ldi r24,lo8(4)
 766 01aa 0E94 0000 		call timer2SetPrescaler
 768               	.LM57:
 769 01ae 14BC      		out 68-0x20,__zero_reg__
 771               	.LM58:
 772 01b0 89B7      		in r24,89-0x20
 773 01b2 8064      		ori r24,lo8(64)
 774 01b4 89BF      		out 89-0x20,r24
 776               	.LM59:
 777 01b6 0E94 0000 		call timer2ClearOverflowCount
 778               	/* epilogue: frame size=0 */
 779 01ba 0895      		ret
 780               	/* epilogue end (size=1) */
 781               	/* function timer2Init size 10 (9) */
 783               	.Lscope16:
 786               	.global	timerInit
 788               	timerInit:
 790               	.LM60:
 791               	/* prologue: frame size=0 */
 792 01bc CF93      		push r28
 793               	/* prologue end (size=1) */
 795               	.LM61:
 796 01be C0E0      		ldi r28,lo8(0)
 797               	.L39:
 799               	.LM62:
 800 01c0 8C2F      		mov r24,r28
 801 01c2 0E94 0000 		call timerDetach
 803               	.LM63:
 804 01c6 CF5F      		subi r28,lo8(-(1))
 805 01c8 C830      		cpi r28,lo8(8)
 806 01ca D0F3      		brlo .L39
 808               	.LM64:
 809 01cc 0E94 0000 		call timer0Init
 811               	.LM65:
 812 01d0 0E94 0000 		call timer1Init
 814               	.LM66:
 815 01d4 0E94 0000 		call timer2Init
 817               	.LM67:
 818               	/* #APP */
 819 01d8 7894      		sei
 820               	/* #NOAPP */
 821               	/* epilogue: frame size=0 */
 822 01da CF91      		pop r28
 823 01dc 0895      		ret
 824               	/* epilogue end (size=2) */
 825               	/* function timerInit size 18 (15) */
 830               	.Lscope17:
 833               	.global	timer0GetPrescaler
 835               	timer0GetPrescaler:
 837               	.LM68:
 838               	/* prologue: frame size=0 */
 839               	/* prologue end (size=0) */
 840               	.LBB2:
 842               	.LM69:
 843 01de 83B7      		in r24,83-0x20
 844 01e0 E82F      		mov r30,r24
 845 01e2 FF27      		clr r31
 846 01e4 E770      		andi r30,lo8(7)
 847 01e6 F070      		andi r31,hi8(7)
 848 01e8 EE0F      		add r30,r30
 849 01ea FF1F      		adc r31,r31
 850 01ec E050      		subi r30,lo8(-(TimerPrescaleFactor))
 851 01ee F040      		sbci r31,hi8(-(TimerPrescaleFactor))
 852               	.LBE2:
 854               	.LM70:
 855               	/* #APP */
 856 01f0 8591      		lpm r24, Z+
 857 01f2 9491      		lpm r25, Z
 858               		
 859               	/* #NOAPP */
 860               	/* epilogue: frame size=0 */
 861 01f4 0895      		ret
 862               	/* epilogue end (size=1) */
 863               	/* function timer0GetPrescaler size 16 (15) */
 868               	.Lscope18:
 871               	.global	timer1GetPrescaler
 873               	timer1GetPrescaler:
 875               	.LM71:
 876               	/* prologue: frame size=0 */
 877               	/* prologue end (size=0) */
 878               	.LBB3:
 880               	.LM72:
 881 01f6 8EB5      		in r24,78-0x20
 882 01f8 E82F      		mov r30,r24
 883 01fa FF27      		clr r31
 884 01fc E770      		andi r30,lo8(7)
 885 01fe F070      		andi r31,hi8(7)
 886 0200 EE0F      		add r30,r30
 887 0202 FF1F      		adc r31,r31
 888 0204 E050      		subi r30,lo8(-(TimerPrescaleFactor))
 889 0206 F040      		sbci r31,hi8(-(TimerPrescaleFactor))
 890               	.LBE3:
 892               	.LM73:
 893               	/* #APP */
 894 0208 8591      		lpm r24, Z+
 895 020a 9491      		lpm r25, Z
 896               		
 897               	/* #NOAPP */
 898               	/* epilogue: frame size=0 */
 899 020c 0895      		ret
 900               	/* epilogue end (size=1) */
 901               	/* function timer1GetPrescaler size 16 (15) */
 906               	.Lscope19:
 909               	.global	timer2GetPrescaler
 911               	timer2GetPrescaler:
 913               	.LM74:
 914               	/* prologue: frame size=0 */
 915               	/* prologue end (size=0) */
 916               	.LBB4:
 918               	.LM75:
 919 020e 85B5      		in r24,69-0x20
 920 0210 E82F      		mov r30,r24
 921 0212 FF27      		clr r31
 922 0214 E770      		andi r30,lo8(7)
 923 0216 F070      		andi r31,hi8(7)
 924 0218 EE0F      		add r30,r30
 925 021a FF1F      		adc r31,r31
 926 021c E050      		subi r30,lo8(-(TimerRTCPrescaleFactor))
 927 021e F040      		sbci r31,hi8(-(TimerRTCPrescaleFactor))
 928               	.LBE4:
 930               	.LM76:
 931               	/* #APP */
 932 0220 8591      		lpm r24, Z+
 933 0222 9491      		lpm r25, Z
 934               		
 935               	/* #NOAPP */
 936               	/* epilogue: frame size=0 */
 937 0224 0895      		ret
 938               	/* epilogue end (size=1) */
 939               	/* function timer2GetPrescaler size 16 (15) */
 944               	.Lscope20:
 949               	.global	timerAttach
 951               	timerAttach:
 953               	.LM77:
 954               	/* prologue: frame size=0 */
 955               	/* prologue end (size=0) */
 957               	.LM78:
 958 0226 8830      		cpi r24,lo8(8)
 959 0228 40F4      		brsh .L45
 961               	.LM79:
 962 022a E82F      		mov r30,r24
 963 022c FF27      		clr r31
 964 022e EE0F      		add r30,r30
 965 0230 FF1F      		adc r31,r31
 966 0232 E050      		subi r30,lo8(-(TimerIntFunc))
 967 0234 F040      		sbci r31,hi8(-(TimerIntFunc))
 968 0236 7183      		std Z+1,r23
 969 0238 6083      		st Z,r22
 970               	.L45:
 971 023a 0895      		ret
 972               	/* epilogue: frame size=0 */
 973               	/* epilogue: noreturn */
 974               	/* epilogue end (size=0) */
 975               	/* function timerAttach size 11 (11) */
 977               	.Lscope21:
 981               	.global	timerPause
 983               	timerPause:
 985               	.LM80:
 986               	/* prologue: frame size=0 */
 987 023c DF92      		push r13
 988 023e EF92      		push r14
 989 0240 FF92      		push r15
 990 0242 0F93      		push r16
 991 0244 1F93      		push r17
 992 0246 CF93      		push r28
 993 0248 DF93      		push r29
 994               	/* prologue end (size=7) */
 995 024a EC01      		movw r28,r24
 997               	.LM81:
 998 024c D2B6      		in r13,82-0x20
 1000               	.LM82:
 1001 024e 1092 0000 		sts TimerPauseReg,__zero_reg__
 1002 0252 1092 0000 		sts (TimerPauseReg)+1,__zero_reg__
 1003 0256 1092 0000 		sts (TimerPauseReg)+2,__zero_reg__
 1004 025a 1092 0000 		sts (TimerPauseReg)+3,__zero_reg__
 1006               	.LM83:
 1007 025e 0E94 0000 		call timer0GetPrescaler
 1008 0262 9C01      		movw r18,r24
 1009 0264 4427      		clr r20
 1010 0266 5527      		clr r21
 1011 0268 60E0      		ldi r22,lo8(16000000)
 1012 026a 74E2      		ldi r23,hi8(16000000)
 1013 026c 84EF      		ldi r24,hlo8(16000000)
 1014 026e 90E0      		ldi r25,hhi8(16000000)
 1015 0270 0E94 0000 		call __divmodsi4
 1017               	.LM84:
 1018 0274 293B      		cpi r18,lo8(429497)
 1019 0276 8DE8      		ldi r24,hi8(429497)
 1020 0278 3807      		cpc r19,r24
 1021 027a 86E0      		ldi r24,hlo8(429497)
 1022 027c 4807      		cpc r20,r24
 1023 027e 80E0      		ldi r24,hhi8(429497)
 1024 0280 5807      		cpc r21,r24
 1025 0282 C0F4      		brsh .L48
 1027               	.LM85:
 1028 0284 87E2      		ldi r24,hi8(10001)
 1029 0286 C131      		cpi r28,lo8(10001)
 1030 0288 D807      		cpc r29,r24
 1031 028a A0F4      		brsh .L48
 1033               	.LM86:
 1034 028c CE01      		movw r24,r28
 1035 028e AA27      		clr r26
 1036 0290 BB27      		clr r27
 1037 0292 BC01      		movw r22,r24
 1038 0294 CD01      		movw r24,r26
 1039 0296 0E94 0000 		call __mulsi3
 1040 029a DC01      		movw r26,r24
 1041 029c CB01      		movw r24,r22
 1042 029e BC01      		movw r22,r24
 1043 02a0 CD01      		movw r24,r26
 1044 02a2 28EE      		ldi r18,lo8(1000)
 1045 02a4 33E0      		ldi r19,hi8(1000)
 1046 02a6 40E0      		ldi r20,hlo8(1000)
 1047 02a8 50E0      		ldi r21,hhi8(1000)
 1048 02aa 0E94 0000 		call __udivmodsi4
 1049 02ae FA01      		movw r30,r20
 1050 02b0 E901      		movw r28,r18
 1051 02b2 11C0      		rjmp .L49
 1052               	.L48:
 1054               	.LM87:
 1055 02b4 7E01      		movw r14,r28
 1056 02b6 0027      		clr r16
 1057 02b8 1127      		clr r17
 1058 02ba CA01      		movw r24,r20
 1059 02bc B901      		movw r22,r18
 1060 02be 28EE      		ldi r18,lo8(1000)
 1061 02c0 33E0      		ldi r19,hi8(1000)
 1062 02c2 40E0      		ldi r20,hlo8(1000)
 1063 02c4 50E0      		ldi r21,hhi8(1000)
 1064 02c6 0E94 0000 		call __udivmodsi4
 1065 02ca C801      		movw r24,r16
 1066 02cc B701      		movw r22,r14
 1067 02ce 0E94 0000 		call __mulsi3
 1068 02d2 FC01      		movw r30,r24
 1069 02d4 EB01      		movw r28,r22
 1070               	.L49:
 1072               	.LM88:
 1073 02d6 8091 0000 		lds r24,TimerPauseReg
 1074 02da 9091 0000 		lds r25,(TimerPauseReg)+1
 1075 02de A091 0000 		lds r26,(TimerPauseReg)+2
 1076 02e2 B091 0000 		lds r27,(TimerPauseReg)+3
 1077 02e6 2227      		clr r18
 1078 02e8 382F      		mov r19,r24
 1079 02ea 492F      		mov r20,r25
 1080 02ec 5A2F      		mov r21,r26
 1081 02ee 82B7      		in r24,82-0x20
 1082 02f0 9927      		clr r25
 1083 02f2 AA27      		clr r26
 1084 02f4 BB27      		clr r27
 1085 02f6 282B      		or r18,r24
 1086 02f8 392B      		or r19,r25
 1087 02fa 4A2B      		or r20,r26
 1088 02fc 5B2B      		or r21,r27
 1089 02fe CD0D      		add r28,r13
 1090 0300 D11D      		adc r29,__zero_reg__
 1091 0302 E11D      		adc r30,__zero_reg__
 1092 0304 F11D      		adc r31,__zero_reg__
 1093 0306 2C17      		cp r18,r28
 1094 0308 3D07      		cpc r19,r29
 1095 030a 4E07      		cpc r20,r30
 1096 030c 5F07      		cpc r21,r31
 1097 030e 58F5      		brsh .L57
 1098               	.L55:
 1100               	.LM89:
 1101 0310 8091 0000 		lds r24,TimerPauseReg
 1102 0314 9091 0000 		lds r25,(TimerPauseReg)+1
 1103 0318 A091 0000 		lds r26,(TimerPauseReg)+2
 1104 031c B091 0000 		lds r27,(TimerPauseReg)+3
 1106               	.LM90:
 1107 0320 85B7      		in r24,85-0x20
 1108 0322 8F78      		andi r24,lo8(-113)
 1109 0324 85BF      		out 85-0x20,r24
 1111               	.LM91:
 1112 0326 85B7      		in r24,85-0x20
 1113 0328 8068      		ori r24,lo8(-128)
 1114 032a 85BF      		out 85-0x20,r24
 1115               	/* #APP */
 1116 032c 8895      		sleep
 1117               		
 1118               	/* #NOAPP */
 1119 032e 85B7      		in r24,85-0x20
 1120 0330 8F77      		andi r24,lo8(127)
 1121 0332 85BF      		out 85-0x20,r24
 1122 0334 8091 0000 		lds r24,TimerPauseReg
 1123 0338 9091 0000 		lds r25,(TimerPauseReg)+1
 1124 033c A091 0000 		lds r26,(TimerPauseReg)+2
 1125 0340 B091 0000 		lds r27,(TimerPauseReg)+3
 1126 0344 BA2F      		mov r27,r26
 1127 0346 A92F      		mov r26,r25
 1128 0348 982F      		mov r25,r24
 1129 034a 8827      		clr r24
 1130 034c 22B7      		in r18,82-0x20
 1131 034e 3327      		clr r19
 1132 0350 4427      		clr r20
 1133 0352 5527      		clr r21
 1134 0354 822B      		or r24,r18
 1135 0356 932B      		or r25,r19
 1136 0358 A42B      		or r26,r20
 1137 035a B52B      		or r27,r21
 1138 035c 8C17      		cp r24,r28
 1139 035e 9D07      		cpc r25,r29
 1140 0360 AE07      		cpc r26,r30
 1141 0362 BF07      		cpc r27,r31
 1142 0364 A8F2      		brlo .L55
 1143               	.L57:
 1144               	/* epilogue: frame size=0 */
 1145 0366 DF91      		pop r29
 1146 0368 CF91      		pop r28
 1147 036a 1F91      		pop r17
 1148 036c 0F91      		pop r16
 1149 036e FF90      		pop r15
 1150 0370 EF90      		pop r14
 1151 0372 DF90      		pop r13
 1152 0374 0895      		ret
 1153               	/* epilogue end (size=8) */
 1154               	/* function timerPause size 160 (145) */
 1161               	.Lscope22:
 1164               	.global	timer0GetOverflowCount
 1166               	timer0GetOverflowCount:
 1168               	.LM92:
 1169               	/* prologue: frame size=0 */
 1170               	/* prologue end (size=0) */
 1172               	.LM93:
 1173 0376 8091 0000 		lds r24,Timer0Reg0
 1174 037a 9091 0000 		lds r25,(Timer0Reg0)+1
 1175 037e A091 0000 		lds r26,(Timer0Reg0)+2
 1176 0382 B091 0000 		lds r27,(Timer0Reg0)+3
 1178               	.LM94:
 1179 0386 BC01      		movw r22,r24
 1180 0388 CD01      		movw r24,r26
 1181               	/* epilogue: frame size=0 */
 1182 038a 0895      		ret
 1183               	/* epilogue end (size=1) */
 1184               	/* function timer0GetOverflowCount size 11 (10) */
 1186               	.Lscope23:
 1189               	.global	timer2GetOverflowCount
 1191               	timer2GetOverflowCount:
 270:timer.c       **** }
 271:timer.c       **** 
 272:timer.c       **** long timer2GetOverflowCount(void)
 273:timer.c       **** {
 1193               	.LM95:
 1194               	/* prologue: frame size=0 */
 1195               	/* prologue end (size=0) */
 274:timer.c       **** 	// return the current timer overflow count
 275:timer.c       **** 	// (this is since the last timer2ClearOverflowCount() command was called)
 276:timer.c       **** 	return Timer2Reg0;
 1197               	.LM96:
 1198 038c 8091 0000 		lds r24,Timer2Reg0
 1199 0390 9091 0000 		lds r25,(Timer2Reg0)+1
 1200 0394 A091 0000 		lds r26,(Timer2Reg0)+2
 1201 0398 B091 0000 		lds r27,(Timer2Reg0)+3
 277:timer.c       **** }
 1203               	.LM97:
 1204 039c BC01      		movw r22,r24
 1205 039e CD01      		movw r24,r26
 1206               	/* epilogue: frame size=0 */
 1207 03a0 0895      		ret
 1208               	/* epilogue end (size=1) */
 1209               	/* function timer2GetOverflowCount size 11 (10) */
 1211               	.Lscope24:
 1215               	.global	timer1PWMInit
 1217               	timer1PWMInit:
 278:timer.c       **** #endif
 279:timer.c       **** 
 280:timer.c       **** void timer1PWMInit(u08 bitRes)
 281:timer.c       **** {
 1219               	.LM98:
 1220               	/* prologue: frame size=0 */
 1221               	/* prologue end (size=0) */
 282:timer.c       **** 	// configures timer1 for use with PWM output
 283:timer.c       **** 	// on OC1A and OC1B pins
 284:timer.c       **** 
 285:timer.c       **** 	// enable timer1 as 8,9,10bit PWM
 286:timer.c       **** 	if(bitRes == 9)
 1223               	.LM99:
 1224 03a2 8930      		cpi r24,lo8(9)
 1225 03a4 31F4      		brne .L61
 287:timer.c       **** 	{	// 9bit mode
 288:timer.c       **** 		sbi(TCCR1A,PWM11);
 1227               	.LM100:
 1228 03a6 8FB5      		in r24,79-0x20
 1229 03a8 8260      		ori r24,lo8(2)
 1230 03aa 8FBD      		out 79-0x20,r24
 289:timer.c       **** 		cbi(TCCR1A,PWM10);
 1232               	.LM101:
 1233 03ac 8FB5      		in r24,79-0x20
 1234 03ae 8E7F      		andi r24,lo8(-2)
 1235 03b0 0AC0      		rjmp .L66
 1236               	.L61:
 290:timer.c       **** 	}
 291:timer.c       **** 	else if( bitRes == 10 )
 1238               	.LM102:
 1239 03b2 8A30      		cpi r24,lo8(10)
 1240 03b4 19F4      		brne .L63
 292:timer.c       **** 	{	// 10bit mode
 293:timer.c       **** 		sbi(TCCR1A,PWM11);
 1242               	.LM103:
 1243 03b6 8FB5      		in r24,79-0x20
 1244 03b8 8260      		ori r24,lo8(2)
 1245 03ba 02C0      		rjmp .L65
 1246               	.L63:
 294:timer.c       **** 		sbi(TCCR1A,PWM10);
 295:timer.c       **** 	}
 296:timer.c       **** 	else
 297:timer.c       **** 	{	// default 8bit mode
 298:timer.c       **** 		cbi(TCCR1A,PWM11);
 1248               	.LM104:
 1249 03bc 8FB5      		in r24,79-0x20
 1250 03be 8D7F      		andi r24,lo8(-3)
 1251               	.L65:
 1252 03c0 8FBD      		out 79-0x20,r24
 299:timer.c       **** 		sbi(TCCR1A,PWM10);
 1254               	.LM105:
 1255 03c2 8FB5      		in r24,79-0x20
 1256 03c4 8160      		ori r24,lo8(1)
 1257               	.L66:
 1258 03c6 8FBD      		out 79-0x20,r24
 300:timer.c       **** 	}
 301:timer.c       **** 
 302:timer.c       **** 	// clear output compare value A
 303:timer.c       **** 	outb(OCR1AH, 0);
 1260               	.LM106:
 1261 03c8 1BBC      		out 75-0x20,__zero_reg__
 304:timer.c       **** 	outb(OCR1AL, 0);
 1263               	.LM107:
 1264 03ca 1ABC      		out 74-0x20,__zero_reg__
 305:timer.c       **** 	// clear output compare value B
 306:timer.c       **** 	outb(OCR1BH, 0);
 1266               	.LM108:
 1267 03cc 19BC      		out 73-0x20,__zero_reg__
 307:timer.c       **** 	outb(OCR1BL, 0);
 1269               	.LM109:
 1270 03ce 18BC      		out 72-0x20,__zero_reg__
 1271               	/* epilogue: frame size=0 */
 1272 03d0 0895      		ret
 1273               	/* epilogue end (size=1) */
 1274               	/* function timer1PWMInit size 24 (23) */
 1276               	.Lscope25:
 1280               	.global	timer1PWMInitICR
 1282               	timer1PWMInitICR:
 308:timer.c       **** }
 309:timer.c       **** 
 310:timer.c       **** #ifdef WGM10
 311:timer.c       **** // include support for arbitrary top-count PWM
 312:timer.c       **** // on new AVR processors that support it
 313:timer.c       **** void timer1PWMInitICR(u16 topcount)
 314:timer.c       **** {
 1284               	.LM110:
 1285               	/* prologue: frame size=0 */
 1286               	/* prologue end (size=0) */
 1287 03d2 9C01      		movw r18,r24
 315:timer.c       **** 	// set PWM mode with ICR top-count
 316:timer.c       **** 	cbi(TCCR1A,WGM10);
 1289               	.LM111:
 1290 03d4 8FB5      		in r24,79-0x20
 1291 03d6 8E7F      		andi r24,lo8(-2)
 1292 03d8 8FBD      		out 79-0x20,r24
 317:timer.c       **** 	sbi(TCCR1A,WGM11);
 1294               	.LM112:
 1295 03da 8FB5      		in r24,79-0x20
 1296 03dc 8260      		ori r24,lo8(2)
 1297 03de 8FBD      		out 79-0x20,r24
 318:timer.c       **** 	sbi(TCCR1B,WGM12);
 1299               	.LM113:
 1300 03e0 8EB5      		in r24,78-0x20
 1301 03e2 8860      		ori r24,lo8(8)
 1302 03e4 8EBD      		out 78-0x20,r24
 319:timer.c       **** 	sbi(TCCR1B,WGM13);
 1304               	.LM114:
 1305 03e6 8EB5      		in r24,78-0x20
 1306 03e8 8061      		ori r24,lo8(16)
 1307 03ea 8EBD      		out 78-0x20,r24
 320:timer.c       **** 	
 321:timer.c       **** 	// set top count value
 322:timer.c       **** 	ICR1 = topcount;
 1309               	.LM115:
 1310 03ec 37BD      		out (70)+1-0x20,r19
 1311 03ee 26BD      		out 70-0x20,r18
 323:timer.c       **** 	
 324:timer.c       **** 	// clear output compare value A
 325:timer.c       **** 	OCR1A = 0;
 1313               	.LM116:
 1314 03f0 1BBC      		out (74)+1-0x20,__zero_reg__
 1315 03f2 1ABC      		out 74-0x20,__zero_reg__
 326:timer.c       **** 	// clear output compare value B
 327:timer.c       **** 	OCR1B = 0;
 1317               	.LM117:
 1318 03f4 19BC      		out (72)+1-0x20,__zero_reg__
 1319 03f6 18BC      		out 72-0x20,__zero_reg__
 1320               	/* epilogue: frame size=0 */
 1321 03f8 0895      		ret
 1322               	/* epilogue end (size=1) */
 1323               	/* function timer1PWMInitICR size 20 (19) */
 1325               	.Lscope26:
 1328               	.global	timer1PWMAOff
 1330               	timer1PWMAOff:
 328:timer.c       **** 
 329:timer.c       **** }
 330:timer.c       **** #endif
 331:timer.c       **** 
 332:timer.c       **** void timer1PWMOff(void)
 333:timer.c       **** {
 334:timer.c       **** 	// turn off timer1 PWM mode
 335:timer.c       **** 	cbi(TCCR1A,PWM11);
 336:timer.c       **** 	cbi(TCCR1A,PWM10);
 337:timer.c       **** 	// set PWM1A/B (OutputCompare action) to none
 338:timer.c       **** 	timer1PWMAOff();
 339:timer.c       **** 	timer1PWMBOff();
 340:timer.c       **** }
 341:timer.c       **** 
 342:timer.c       **** void timer1PWMAOn(void)
 343:timer.c       **** {
 344:timer.c       **** 	// turn on channel A (OC1A) PWM output
 345:timer.c       **** 	// set OC1A as non-inverted PWM
 346:timer.c       **** 	sbi(TCCR1A,COM1A1);
 347:timer.c       **** 	cbi(TCCR1A,COM1A0);
 348:timer.c       **** }
 349:timer.c       **** 
 350:timer.c       **** void timer1PWMBOn(void)
 351:timer.c       **** {
 352:timer.c       **** 	// turn on channel B (OC1B) PWM output
 353:timer.c       **** 	// set OC1B as non-inverted PWM
 354:timer.c       **** 	sbi(TCCR1A,COM1B1);
 355:timer.c       **** 	cbi(TCCR1A,COM1B0);
 356:timer.c       **** }
 357:timer.c       **** 
 358:timer.c       **** void timer1PWMAOff(void)
 359:timer.c       **** {
 1332               	.LM118:
 1333               	/* prologue: frame size=0 */
 1334               	/* prologue end (size=0) */
 360:timer.c       **** 	// turn off channel A (OC1A) PWM output
 361:timer.c       **** 	// set OC1A (OutputCompare action) to none
 362:timer.c       **** 	cbi(TCCR1A,COM1A1);
 1336               	.LM119:
 1337 03fa 8FB5      		in r24,79-0x20
 1338 03fc 8F77      		andi r24,lo8(127)
 1339 03fe 8FBD      		out 79-0x20,r24
 363:timer.c       **** 	cbi(TCCR1A,COM1A0);
 1341               	.LM120:
 1342 0400 8FB5      		in r24,79-0x20
 1343 0402 8F7B      		andi r24,lo8(-65)
 1344 0404 8FBD      		out 79-0x20,r24
 1345               	/* epilogue: frame size=0 */
 1346 0406 0895      		ret
 1347               	/* epilogue end (size=1) */
 1348               	/* function timer1PWMAOff size 7 (6) */
 1350               	.Lscope27:
 1353               	.global	timer1PWMBOff
 1355               	timer1PWMBOff:
 364:timer.c       **** }
 365:timer.c       **** 
 366:timer.c       **** void timer1PWMBOff(void)
 367:timer.c       **** {
 1357               	.LM121:
 1358               	/* prologue: frame size=0 */
 1359               	/* prologue end (size=0) */
 368:timer.c       **** 	// turn off channel B (OC1B) PWM output
 369:timer.c       **** 	// set OC1B (OutputCompare action) to none
 370:timer.c       **** 	cbi(TCCR1A,COM1B1);
 1361               	.LM122:
 1362 0408 8FB5      		in r24,79-0x20
 1363 040a 8F7D      		andi r24,lo8(-33)
 1364 040c 8FBD      		out 79-0x20,r24
 371:timer.c       **** 	cbi(TCCR1A,COM1B0);
 1366               	.LM123:
 1367 040e 8FB5      		in r24,79-0x20
 1368 0410 8F7E      		andi r24,lo8(-17)
 1369 0412 8FBD      		out 79-0x20,r24
 1370               	/* epilogue: frame size=0 */
 1371 0414 0895      		ret
 1372               	/* epilogue end (size=1) */
 1373               	/* function timer1PWMBOff size 7 (6) */
 1375               	.Lscope28:
 1378               	.global	timer1PWMOff
 1380               	timer1PWMOff:
 1382               	.LM124:
 1383               	/* prologue: frame size=0 */
 1384               	/* prologue end (size=0) */
 1386               	.LM125:
 1387 0416 8FB5      		in r24,79-0x20
 1388 0418 8D7F      		andi r24,lo8(-3)
 1389 041a 8FBD      		out 79-0x20,r24
 1391               	.LM126:
 1392 041c 8FB5      		in r24,79-0x20
 1393 041e 8E7F      		andi r24,lo8(-2)
 1394 0420 8FBD      		out 79-0x20,r24
 1396               	.LM127:
 1397 0422 0E94 0000 		call timer1PWMAOff
 1399               	.LM128:
 1400 0426 0E94 0000 		call timer1PWMBOff
 1401               	/* epilogue: frame size=0 */
 1402 042a 0895      		ret
 1403               	/* epilogue end (size=1) */
 1404               	/* function timer1PWMOff size 11 (10) */
 1406               	.Lscope29:
 1409               	.global	timer1PWMAOn
 1411               	timer1PWMAOn:
 1413               	.LM129:
 1414               	/* prologue: frame size=0 */
 1415               	/* prologue end (size=0) */
 1417               	.LM130:
 1418 042c 8FB5      		in r24,79-0x20
 1419 042e 8068      		ori r24,lo8(-128)
 1420 0430 8FBD      		out 79-0x20,r24
 1422               	.LM131:
 1423 0432 8FB5      		in r24,79-0x20
 1424 0434 8F7B      		andi r24,lo8(-65)
 1425 0436 8FBD      		out 79-0x20,r24
 1426               	/* epilogue: frame size=0 */
 1427 0438 0895      		ret
 1428               	/* epilogue end (size=1) */
 1429               	/* function timer1PWMAOn size 7 (6) */
 1431               	.Lscope30:
 1434               	.global	timer1PWMBOn
 1436               	timer1PWMBOn:
 1438               	.LM132:
 1439               	/* prologue: frame size=0 */
 1440               	/* prologue end (size=0) */
 1442               	.LM133:
 1443 043a 8FB5      		in r24,79-0x20
 1444 043c 8062      		ori r24,lo8(32)
 1445 043e 8FBD      		out 79-0x20,r24
 1447               	.LM134:
 1448 0440 8FB5      		in r24,79-0x20
 1449 0442 8F7E      		andi r24,lo8(-17)
 1450 0444 8FBD      		out 79-0x20,r24
 1451               	/* epilogue: frame size=0 */
 1452 0446 0895      		ret
 1453               	/* epilogue end (size=1) */
 1454               	/* function timer1PWMBOn size 7 (6) */
 1456               	.Lscope31:
 1460               	.global	timer1PWMASet
 1462               	timer1PWMASet:
 372:timer.c       **** }
 373:timer.c       **** 
 374:timer.c       **** void timer1PWMASet(u16 pwmDuty)
 375:timer.c       **** {
 1464               	.LM135:
 1465               	/* prologue: frame size=0 */
 1466               	/* prologue end (size=0) */
 376:timer.c       **** 	// set PWM (output compare) duty for channel A
 377:timer.c       **** 	// this PWM output is generated on OC1A pin
 378:timer.c       **** 	// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
 379:timer.c       **** 	//			pwmDuty should be in the range 0-511 for 9bit PWM
 380:timer.c       **** 	//			pwmDuty should be in the range 0-1023 for 10bit PWM
 381:timer.c       **** 	//outp( (pwmDuty>>8), OCR1AH);		// set the high 8bits of OCR1A
 382:timer.c       **** 	//outp( (pwmDuty&0x00FF), OCR1AL);	// set the low 8bits of OCR1A
 383:timer.c       **** 	OCR1A = pwmDuty;
 1468               	.LM136:
 1469 0448 9BBD      		out (74)+1-0x20,r25
 1470 044a 8ABD      		out 74-0x20,r24
 1471               	/* epilogue: frame size=0 */
 1472 044c 0895      		ret
 1473               	/* epilogue end (size=1) */
 1474               	/* function timer1PWMASet size 3 (2) */
 1476               	.Lscope32:
 1480               	.global	timer1PWMBSet
 1482               	timer1PWMBSet:
 384:timer.c       **** }
 385:timer.c       **** 
 386:timer.c       **** void timer1PWMBSet(u16 pwmDuty)
 387:timer.c       **** {
 1484               	.LM137:
 1485               	/* prologue: frame size=0 */
 1486               	/* prologue end (size=0) */
 388:timer.c       **** 	// set PWM (output compare) duty for channel B
 389:timer.c       **** 	// this PWM output is generated on OC1B pin
 390:timer.c       **** 	// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
 391:timer.c       **** 	//			pwmDuty should be in the range 0-511 for 9bit PWM
 392:timer.c       **** 	//			pwmDuty should be in the range 0-1023 for 10bit PWM
 393:timer.c       **** 	//outp( (pwmDuty>>8), OCR1BH);		// set the high 8bits of OCR1B
 394:timer.c       **** 	//outp( (pwmDuty&0x00FF), OCR1BL);	// set the low 8bits of OCR1B
 395:timer.c       **** 	OCR1B = pwmDuty;
 1488               	.LM138:
 1489 044e 99BD      		out (72)+1-0x20,r25
 1490 0450 88BD      		out 72-0x20,r24
 1491               	/* epilogue: frame size=0 */
 1492 0452 0895      		ret
 1493               	/* epilogue end (size=1) */
 1494               	/* function timer1PWMBSet size 3 (2) */
 1496               	.Lscope33:
 1499               	.global	__vector_9
 1501               	__vector_9:
 396:timer.c       **** }
 397:timer.c       **** /*
 398:timer.c       **** //! Interrupt handler for tcnt0 overflow interrupt
 399:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
 400:timer.c       **** {
 401:timer.c       **** 	Timer0Reg0++;			// increment low-order counter
 402:timer.c       **** 
 403:timer.c       **** 	// increment pause counter
 404:timer.c       **** 	TimerPauseReg++;
 405:timer.c       **** 
 406:timer.c       **** 	// if a user function is defined, execute it too
 407:timer.c       **** 	if(TimerIntFunc[TIMER0OVERFLOW_INT])
 408:timer.c       **** 		TimerIntFunc[TIMER0OVERFLOW_INT]();
 409:timer.c       **** }
 410:timer.c       **** */
 411:timer.c       **** 
 412:timer.c       **** //! Interrupt handler for tcnt1 overflow interrupt
 413:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
 414:timer.c       **** {
 1503               	.LM139:
 1504               	/* prologue: frame size=0 */
 1505 0454 1F92      		push __zero_reg__
 1506 0456 0F92      		push __tmp_reg__
 1507 0458 0FB6      		in __tmp_reg__,__SREG__
 1508 045a 0F92      		push __tmp_reg__
 1509 045c 1124      		clr __zero_reg__
 1510 045e 2F93      		push r18
 1511 0460 3F93      		push r19
 1512 0462 4F93      		push r20
 1513 0464 5F93      		push r21
 1514 0466 6F93      		push r22
 1515 0468 7F93      		push r23
 1516 046a 8F93      		push r24
 1517 046c 9F93      		push r25
 1518 046e AF93      		push r26
 1519 0470 BF93      		push r27
 1520 0472 EF93      		push r30
 1521 0474 FF93      		push r31
 1522               	/* prologue end (size=17) */
 415:timer.c       **** 	// if a user function is defined, execute it
 416:timer.c       **** 	if(TimerIntFunc[TIMER1OVERFLOW_INT])
 1524               	.LM140:
 1525 0476 8091 0000 		lds r24,TimerIntFunc+2
 1526 047a 9091 0000 		lds r25,(TimerIntFunc+2)+1
 1527 047e 892B      		or r24,r25
 1528 0480 29F0      		breq .L75
 417:timer.c       **** 		TimerIntFunc[TIMER1OVERFLOW_INT]();
 1530               	.LM141:
 1531 0482 E091 0000 		lds r30,TimerIntFunc+2
 1532 0486 F091 0000 		lds r31,(TimerIntFunc+2)+1
 1533 048a 0995      		icall
 1534               	.L75:
 1535               	/* epilogue: frame size=0 */
 1536 048c FF91      		pop r31
 1537 048e EF91      		pop r30
 1538 0490 BF91      		pop r27
 1539 0492 AF91      		pop r26
 1540 0494 9F91      		pop r25
 1541 0496 8F91      		pop r24
 1542 0498 7F91      		pop r23
 1543 049a 6F91      		pop r22
 1544 049c 5F91      		pop r21
 1545 049e 4F91      		pop r20
 1546 04a0 3F91      		pop r19
 1547 04a2 2F91      		pop r18
 1548 04a4 0F90      		pop __tmp_reg__
 1549 04a6 0FBE      		out __SREG__,__tmp_reg__
 1550 04a8 0F90      		pop __tmp_reg__
 1551 04aa 1F90      		pop __zero_reg__
 1552 04ac 1895      		reti
 1553               	/* epilogue end (size=17) */
 1554               	/* function __vector_9 size 45 (11) */
 1556               	.Lscope34:
 1559               	.global	__vector_5
 1561               	__vector_5:
 418:timer.c       **** }
 419:timer.c       **** 
 420:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 421:timer.c       **** //! Interrupt handler for tcnt2 overflow interrupt
 422:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
 423:timer.c       **** {
 1563               	.LM142:
 1564               	/* prologue: frame size=0 */
 1565 04ae 1F92      		push __zero_reg__
 1566 04b0 0F92      		push __tmp_reg__
 1567 04b2 0FB6      		in __tmp_reg__,__SREG__
 1568 04b4 0F92      		push __tmp_reg__
 1569 04b6 1124      		clr __zero_reg__
 1570 04b8 2F93      		push r18
 1571 04ba 3F93      		push r19
 1572 04bc 4F93      		push r20
 1573 04be 5F93      		push r21
 1574 04c0 6F93      		push r22
 1575 04c2 7F93      		push r23
 1576 04c4 8F93      		push r24
 1577 04c6 9F93      		push r25
 1578 04c8 AF93      		push r26
 1579 04ca BF93      		push r27
 1580 04cc EF93      		push r30
 1581 04ce FF93      		push r31
 1582               	/* prologue end (size=17) */
 424:timer.c       **** 	Timer2Reg0++;			// increment low-order counter
 1584               	.LM143:
 1585 04d0 8091 0000 		lds r24,Timer2Reg0
 1586 04d4 9091 0000 		lds r25,(Timer2Reg0)+1
 1587 04d8 A091 0000 		lds r26,(Timer2Reg0)+2
 1588 04dc B091 0000 		lds r27,(Timer2Reg0)+3
 1589 04e0 0196      		adiw r24,1
 1590 04e2 A11D      		adc r26,__zero_reg__
 1591 04e4 B11D      		adc r27,__zero_reg__
 1592 04e6 8093 0000 		sts Timer2Reg0,r24
 1593 04ea 9093 0000 		sts (Timer2Reg0)+1,r25
 1594 04ee A093 0000 		sts (Timer2Reg0)+2,r26
 1595 04f2 B093 0000 		sts (Timer2Reg0)+3,r27
 425:timer.c       **** 
 426:timer.c       **** 	// if a user function is defined, execute it
 427:timer.c       **** 	if(TimerIntFunc[TIMER2OVERFLOW_INT])
 1597               	.LM144:
 1598 04f6 8091 0000 		lds r24,TimerIntFunc+10
 1599 04fa 9091 0000 		lds r25,(TimerIntFunc+10)+1
 1600 04fe 892B      		or r24,r25
 1601 0500 29F0      		breq .L77
 428:timer.c       **** 		TimerIntFunc[TIMER2OVERFLOW_INT]();
 1603               	.LM145:
 1604 0502 E091 0000 		lds r30,TimerIntFunc+10
 1605 0506 F091 0000 		lds r31,(TimerIntFunc+10)+1
 1606 050a 0995      		icall
 1607               	.L77:
 1608               	/* epilogue: frame size=0 */
 1609 050c FF91      		pop r31
 1610 050e EF91      		pop r30
 1611 0510 BF91      		pop r27
 1612 0512 AF91      		pop r26
 1613 0514 9F91      		pop r25
 1614 0516 8F91      		pop r24
 1615 0518 7F91      		pop r23
 1616 051a 6F91      		pop r22
 1617 051c 5F91      		pop r21
 1618 051e 4F91      		pop r20
 1619 0520 3F91      		pop r19
 1620 0522 2F91      		pop r18
 1621 0524 0F90      		pop __tmp_reg__
 1622 0526 0FBE      		out __SREG__,__tmp_reg__
 1623 0528 0F90      		pop __tmp_reg__
 1624 052a 1F90      		pop __zero_reg__
 1625 052c 1895      		reti
 1626               	/* epilogue end (size=17) */
 1627               	/* function __vector_5 size 64 (30) */
 1629               	.Lscope35:
 1632               	.global	__vector_10
 1634               	__vector_10:
 429:timer.c       **** }
 430:timer.c       **** #endif
 431:timer.c       **** 
 432:timer.c       **** #ifdef OCR0
 433:timer.c       **** // include support for Output Compare 0 for new AVR processors that support it
 434:timer.c       **** //! Interrupt handler for OutputCompare0 match (OC0) interrupt
 435:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
 436:timer.c       **** {
 1636               	.LM146:
 1637               	/* prologue: frame size=0 */
 1638 052e 1F92      		push __zero_reg__
 1639 0530 0F92      		push __tmp_reg__
 1640 0532 0FB6      		in __tmp_reg__,__SREG__
 1641 0534 0F92      		push __tmp_reg__
 1642 0536 1124      		clr __zero_reg__
 1643 0538 2F93      		push r18
 1644 053a 3F93      		push r19
 1645 053c 4F93      		push r20
 1646 053e 5F93      		push r21
 1647 0540 6F93      		push r22
 1648 0542 7F93      		push r23
 1649 0544 8F93      		push r24
 1650 0546 9F93      		push r25
 1651 0548 AF93      		push r26
 1652 054a BF93      		push r27
 1653 054c EF93      		push r30
 1654 054e FF93      		push r31
 1655               	/* prologue end (size=17) */
 437:timer.c       **** 	// if a user function is defined, execute it
 438:timer.c       **** 	if(TimerIntFunc[TIMER0OUTCOMPARE_INT])
 1657               	.LM147:
 1658 0550 8091 0000 		lds r24,TimerIntFunc+14
 1659 0554 9091 0000 		lds r25,(TimerIntFunc+14)+1
 1660 0558 892B      		or r24,r25
 1661 055a 29F0      		breq .L79
 439:timer.c       **** 		TimerIntFunc[TIMER0OUTCOMPARE_INT]();
 1663               	.LM148:
 1664 055c E091 0000 		lds r30,TimerIntFunc+14
 1665 0560 F091 0000 		lds r31,(TimerIntFunc+14)+1
 1666 0564 0995      		icall
 1667               	.L79:
 1668               	/* epilogue: frame size=0 */
 1669 0566 FF91      		pop r31
 1670 0568 EF91      		pop r30
 1671 056a BF91      		pop r27
 1672 056c AF91      		pop r26
 1673 056e 9F91      		pop r25
 1674 0570 8F91      		pop r24
 1675 0572 7F91      		pop r23
 1676 0574 6F91      		pop r22
 1677 0576 5F91      		pop r21
 1678 0578 4F91      		pop r20
 1679 057a 3F91      		pop r19
 1680 057c 2F91      		pop r18
 1681 057e 0F90      		pop __tmp_reg__
 1682 0580 0FBE      		out __SREG__,__tmp_reg__
 1683 0582 0F90      		pop __tmp_reg__
 1684 0584 1F90      		pop __zero_reg__
 1685 0586 1895      		reti
 1686               	/* epilogue end (size=17) */
 1687               	/* function __vector_10 size 45 (11) */
 1689               	.Lscope36:
 1692               	.global	__vector_7
 1694               	__vector_7:
 440:timer.c       **** }
 441:timer.c       **** #endif
 442:timer.c       **** 
 443:timer.c       **** //! Interrupt handler for CutputCompare1A match (OC1A) interrupt
 444:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
 445:timer.c       **** {
 1696               	.LM149:
 1697               	/* prologue: frame size=0 */
 1698 0588 1F92      		push __zero_reg__
 1699 058a 0F92      		push __tmp_reg__
 1700 058c 0FB6      		in __tmp_reg__,__SREG__
 1701 058e 0F92      		push __tmp_reg__
 1702 0590 1124      		clr __zero_reg__
 1703 0592 2F93      		push r18
 1704 0594 3F93      		push r19
 1705 0596 4F93      		push r20
 1706 0598 5F93      		push r21
 1707 059a 6F93      		push r22
 1708 059c 7F93      		push r23
 1709 059e 8F93      		push r24
 1710 05a0 9F93      		push r25
 1711 05a2 AF93      		push r26
 1712 05a4 BF93      		push r27
 1713 05a6 EF93      		push r30
 1714 05a8 FF93      		push r31
 1715               	/* prologue end (size=17) */
 446:timer.c       **** 	// if a user function is defined, execute it
 447:timer.c       **** 	if(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
 1717               	.LM150:
 1718 05aa 8091 0000 		lds r24,TimerIntFunc+4
 1719 05ae 9091 0000 		lds r25,(TimerIntFunc+4)+1
 1720 05b2 892B      		or r24,r25
 1721 05b4 29F0      		breq .L81
 448:timer.c       **** 		TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
 1723               	.LM151:
 1724 05b6 E091 0000 		lds r30,TimerIntFunc+4
 1725 05ba F091 0000 		lds r31,(TimerIntFunc+4)+1
 1726 05be 0995      		icall
 1727               	.L81:
 1728               	/* epilogue: frame size=0 */
 1729 05c0 FF91      		pop r31
 1730 05c2 EF91      		pop r30
 1731 05c4 BF91      		pop r27
 1732 05c6 AF91      		pop r26
 1733 05c8 9F91      		pop r25
 1734 05ca 8F91      		pop r24
 1735 05cc 7F91      		pop r23
 1736 05ce 6F91      		pop r22
 1737 05d0 5F91      		pop r21
 1738 05d2 4F91      		pop r20
 1739 05d4 3F91      		pop r19
 1740 05d6 2F91      		pop r18
 1741 05d8 0F90      		pop __tmp_reg__
 1742 05da 0FBE      		out __SREG__,__tmp_reg__
 1743 05dc 0F90      		pop __tmp_reg__
 1744 05de 1F90      		pop __zero_reg__
 1745 05e0 1895      		reti
 1746               	/* epilogue end (size=17) */
 1747               	/* function __vector_7 size 45 (11) */
 1749               	.Lscope37:
 1752               	.global	__vector_8
 1754               	__vector_8:
 449:timer.c       **** }
 450:timer.c       **** 
 451:timer.c       **** //! Interrupt handler for OutputCompare1B match (OC1B) interrupt
 452:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
 453:timer.c       **** {
 1756               	.LM152:
 1757               	/* prologue: frame size=0 */
 1758 05e2 1F92      		push __zero_reg__
 1759 05e4 0F92      		push __tmp_reg__
 1760 05e6 0FB6      		in __tmp_reg__,__SREG__
 1761 05e8 0F92      		push __tmp_reg__
 1762 05ea 1124      		clr __zero_reg__
 1763 05ec 2F93      		push r18
 1764 05ee 3F93      		push r19
 1765 05f0 4F93      		push r20
 1766 05f2 5F93      		push r21
 1767 05f4 6F93      		push r22
 1768 05f6 7F93      		push r23
 1769 05f8 8F93      		push r24
 1770 05fa 9F93      		push r25
 1771 05fc AF93      		push r26
 1772 05fe BF93      		push r27
 1773 0600 EF93      		push r30
 1774 0602 FF93      		push r31
 1775               	/* prologue end (size=17) */
 454:timer.c       **** 	// if a user function is defined, execute it
 455:timer.c       **** 	if(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
 1777               	.LM153:
 1778 0604 8091 0000 		lds r24,TimerIntFunc+6
 1779 0608 9091 0000 		lds r25,(TimerIntFunc+6)+1
 1780 060c 892B      		or r24,r25
 1781 060e 29F0      		breq .L83
 456:timer.c       **** 		TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
 1783               	.LM154:
 1784 0610 E091 0000 		lds r30,TimerIntFunc+6
 1785 0614 F091 0000 		lds r31,(TimerIntFunc+6)+1
 1786 0618 0995      		icall
 1787               	.L83:
 1788               	/* epilogue: frame size=0 */
 1789 061a FF91      		pop r31
 1790 061c EF91      		pop r30
 1791 061e BF91      		pop r27
 1792 0620 AF91      		pop r26
 1793 0622 9F91      		pop r25
 1794 0624 8F91      		pop r24
 1795 0626 7F91      		pop r23
 1796 0628 6F91      		pop r22
 1797 062a 5F91      		pop r21
 1798 062c 4F91      		pop r20
 1799 062e 3F91      		pop r19
 1800 0630 2F91      		pop r18
 1801 0632 0F90      		pop __tmp_reg__
 1802 0634 0FBE      		out __SREG__,__tmp_reg__
 1803 0636 0F90      		pop __tmp_reg__
 1804 0638 1F90      		pop __zero_reg__
 1805 063a 1895      		reti
 1806               	/* epilogue end (size=17) */
 1807               	/* function __vector_8 size 45 (11) */
 1809               	.Lscope38:
 1812               	.global	__vector_6
 1814               	__vector_6:
 457:timer.c       **** }
 458:timer.c       **** 
 459:timer.c       **** //! Interrupt handler for InputCapture1 (IC1) interrupt
 460:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
 461:timer.c       **** {
 1816               	.LM155:
 1817               	/* prologue: frame size=0 */
 1818 063c 1F92      		push __zero_reg__
 1819 063e 0F92      		push __tmp_reg__
 1820 0640 0FB6      		in __tmp_reg__,__SREG__
 1821 0642 0F92      		push __tmp_reg__
 1822 0644 1124      		clr __zero_reg__
 1823 0646 2F93      		push r18
 1824 0648 3F93      		push r19
 1825 064a 4F93      		push r20
 1826 064c 5F93      		push r21
 1827 064e 6F93      		push r22
 1828 0650 7F93      		push r23
 1829 0652 8F93      		push r24
 1830 0654 9F93      		push r25
 1831 0656 AF93      		push r26
 1832 0658 BF93      		push r27
 1833 065a EF93      		push r30
 1834 065c FF93      		push r31
 1835               	/* prologue end (size=17) */
 462:timer.c       **** 	// if a user function is defined, execute it
 463:timer.c       **** 	if(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
 1837               	.LM156:
 1838 065e 8091 0000 		lds r24,TimerIntFunc+8
 1839 0662 9091 0000 		lds r25,(TimerIntFunc+8)+1
 1840 0666 892B      		or r24,r25
 1841 0668 29F0      		breq .L85
 464:timer.c       **** 		TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
 1843               	.LM157:
 1844 066a E091 0000 		lds r30,TimerIntFunc+8
 1845 066e F091 0000 		lds r31,(TimerIntFunc+8)+1
 1846 0672 0995      		icall
 1847               	.L85:
 1848               	/* epilogue: frame size=0 */
 1849 0674 FF91      		pop r31
 1850 0676 EF91      		pop r30
 1851 0678 BF91      		pop r27
 1852 067a AF91      		pop r26
 1853 067c 9F91      		pop r25
 1854 067e 8F91      		pop r24
 1855 0680 7F91      		pop r23
 1856 0682 6F91      		pop r22
 1857 0684 5F91      		pop r21
 1858 0686 4F91      		pop r20
 1859 0688 3F91      		pop r19
 1860 068a 2F91      		pop r18
 1861 068c 0F90      		pop __tmp_reg__
 1862 068e 0FBE      		out __SREG__,__tmp_reg__
 1863 0690 0F90      		pop __tmp_reg__
 1864 0692 1F90      		pop __zero_reg__
 1865 0694 1895      		reti
 1866               	/* epilogue end (size=17) */
 1867               	/* function __vector_6 size 45 (11) */
 1869               	.Lscope39:
 1872               	.global	__vector_4
 1874               	__vector_4:
 465:timer.c       **** }
 466:timer.c       **** 
 467:timer.c       **** //! Interrupt handler for OutputCompare2 match (OC2) interrupt
 468:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2)
 469:timer.c       **** {
 1876               	.LM158:
 1877               	/* prologue: frame size=0 */
 1878 0696 1F92      		push __zero_reg__
 1879 0698 0F92      		push __tmp_reg__
 1880 069a 0FB6      		in __tmp_reg__,__SREG__
 1881 069c 0F92      		push __tmp_reg__
 1882 069e 1124      		clr __zero_reg__
 1883 06a0 2F93      		push r18
 1884 06a2 3F93      		push r19
 1885 06a4 4F93      		push r20
 1886 06a6 5F93      		push r21
 1887 06a8 6F93      		push r22
 1888 06aa 7F93      		push r23
 1889 06ac 8F93      		push r24
 1890 06ae 9F93      		push r25
 1891 06b0 AF93      		push r26
 1892 06b2 BF93      		push r27
 1893 06b4 EF93      		push r30
 1894 06b6 FF93      		push r31
 1895               	/* prologue end (size=17) */
 470:timer.c       **** 	// if a user function is defined, execute it
 471:timer.c       **** 	if(TimerIntFunc[TIMER2OUTCOMPARE_INT])
 1897               	.LM159:
 1898 06b8 8091 0000 		lds r24,TimerIntFunc+12
 1899 06bc 9091 0000 		lds r25,(TimerIntFunc+12)+1
 1900 06c0 892B      		or r24,r25
 1901 06c2 29F0      		breq .L87
 472:timer.c       **** 		TimerIntFunc[TIMER2OUTCOMPARE_INT]();
 1903               	.LM160:
 1904 06c4 E091 0000 		lds r30,TimerIntFunc+12
 1905 06c8 F091 0000 		lds r31,(TimerIntFunc+12)+1
 1906 06cc 0995      		icall
 1907               	.L87:
 1908               	/* epilogue: frame size=0 */
 1909 06ce FF91      		pop r31
 1910 06d0 EF91      		pop r30
 1911 06d2 BF91      		pop r27
 1912 06d4 AF91      		pop r26
 1913 06d6 9F91      		pop r25
 1914 06d8 8F91      		pop r24
 1915 06da 7F91      		pop r23
 1916 06dc 6F91      		pop r22
 1917 06de 5F91      		pop r21
 1918 06e0 4F91      		pop r20
 1919 06e2 3F91      		pop r19
 1920 06e4 2F91      		pop r18
 1921 06e6 0F90      		pop __tmp_reg__
 1922 06e8 0FBE      		out __SREG__,__tmp_reg__
 1923 06ea 0F90      		pop __tmp_reg__
 1924 06ec 1F90      		pop __zero_reg__
 1925 06ee 1895      		reti
 1926               	/* epilogue end (size=17) */
 1927               	/* function __vector_4 size 45 (11) */
 1929               	.Lscope40:
 1932               	.global	servoInit
 1934               	servoInit:
 1936               	.Ltext3:
   1:servo.c       **** /*! \file servo.c \brief Interrupt-driven RC Servo function library. */
   2:servo.c       **** //*****************************************************************************
   3:servo.c       **** //
   4:servo.c       **** // File Name	: 'servo.c'
   5:servo.c       **** // Title		: Interrupt-driven RC Servo function library
   6:servo.c       **** // Author		: Pascal Stang - Copyright (C) 2002
   7:servo.c       **** // Created		: 7/31/2002
   8:servo.c       **** // Revised		: 8/02/2002
   9:servo.c       **** // Version		: 1.0
  10:servo.c       **** // Target MCU	: Atmel AVR Series
  11:servo.c       **** // Editor Tabs	: 4
  12:servo.c       **** //
  13:servo.c       **** // This code is distributed under the GNU Public License
  14:servo.c       **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
  15:servo.c       **** //
  16:servo.c       **** //*****************************************************************************
  17:servo.c       **** 
  18:servo.c       **** #ifndef WIN32
  19:servo.c       **** 	#include <avr/io.h>
  20:servo.c       **** #endif
  21:servo.c       **** 
  22:servo.c       **** #include "servo.h"
  23:servo.c       **** 
  24:servo.c       **** // Program ROM constants
  25:servo.c       **** 
  26:servo.c       **** // Global variables
  27:servo.c       **** // servo channel registers
  28:servo.c       **** u16 ServoPosTics;
  29:servo.c       **** u16 ServoPeriodTics;
  30:servo.c       **** u08 ServoChannel;
  31:servo.c       **** ServoChannelType ServoChannels[SERVO_NUM_CHANNELS];
  32:servo.c       **** 
  33:servo.c       **** // functions
  34:servo.c       **** 
  35:servo.c       **** //! initializes software PWM system
  36:servo.c       **** void servoInit(void)
  37:servo.c       **** {
 1938               	.LM161:
 1939               	/* prologue: frame size=0 */
 1940               	/* prologue end (size=0) */
  38:servo.c       **** 	u08 channel;
  39:servo.c       **** 	// disble the timer1 output compare A interrupt
  40:servo.c       **** 	cbi(TIMSK, OCIE1A);
 1942               	.LM162:
 1943 06f0 89B7      		in r24,89-0x20
 1944 06f2 8F7E      		andi r24,lo8(-17)
 1945 06f4 89BF      		out 89-0x20,r24
  41:servo.c       **** 	// set the prescaler for timer1
  42:servo.c       **** 	timer1SetPrescaler(TIMER_CLK_DIV256);
 1947               	.LM163:
 1948 06f6 84E0      		ldi r24,lo8(4)
 1949 06f8 0E94 0000 		call timer1SetPrescaler
  43:servo.c       **** 	// attach the software PWM service routine to timer1 output compare A
  44:servo.c       **** 	timerAttach(TIMER1OUTCOMPAREA_INT, servoService);
 1951               	.LM164:
 1952 06fc 60E0      		ldi r22,lo8(pm(servoService))
 1953 06fe 70E0      		ldi r23,hi8(pm(servoService))
 1954 0700 82E0      		ldi r24,lo8(2)
 1955 0702 0E94 0000 		call timerAttach
 1956 0706 A2E2      		ldi r26,lo8(34)
 1957 0708 B0E0      		ldi r27,hi8(34)
 1958 070a 55E1      		ldi r21,lo8(21)
 1959 070c 61E0      		ldi r22,lo8(1)
 1960 070e 70E0      		ldi r23,hi8(1)
 1961 0710 E0E0      		ldi r30,lo8(ServoChannels)
 1962 0712 F0E0      		ldi r31,hi8(ServoChannels)
 1963 0714 20E0      		ldi r18,lo8(0)
 1964 0716 30E0      		ldi r19,hi8(0)
 1965 0718 41E0      		ldi r20,lo8(1)
 1966               	.L93:
  45:servo.c       **** 	// enable and clear channels
  46:servo.c       **** 	for(channel=0; channel<SERVO_NUM_CHANNELS; channel++)
  47:servo.c       **** 	{
  48:servo.c       **** 		// set minimum position as default
  49:servo.c       **** 		ServoChannels[channel].duty = SERVO_MIN;
 1968               	.LM165:
 1969 071a B383      		std Z+3,r27
 1970 071c A283      		std Z+2,r26
  50:servo.c       **** 		// set default port and pins assignments
  51:servo.c       **** 		ServoChannels[channel].port = _SFR_IO_ADDR(SERVO_DEFAULT_PORT);
 1972               	.LM166:
 1973 071e 5083      		st Z,r21
  52:servo.c       **** 		//ServoChannels[channel].port = (unsigned char)&SERVO_DEFAULT_PORT;
  53:servo.c       **** 		ServoChannels[channel].pin = (1<<channel);
 1975               	.LM167:
 1976 0720 CB01      		movw r24,r22
 1977 0722 022E      		mov r0,r18
 1978 0724 02C0      		rjmp 2f
 1979 0726 880F      	1:	lsl r24
 1980 0728 991F      		rol r25
 1981 072a 0A94      	2:	dec r0
 1982 072c E2F7      		brpl 1b
 1983 072e 8183      		std Z+1,r24
 1985               	.LM168:
 1986 0730 4150      		subi r20,lo8(-(-1))
 1987 0732 2F5F      		subi r18,lo8(-(1))
 1988 0734 3F4F      		sbci r19,hi8(-(1))
 1989 0736 3496      		adiw r30,4
 1990 0738 47FF      		sbrs r20,7
 1991 073a EFCF      		rjmp .L93
  54:servo.c       **** 		// set channel pin to output
  55:servo.c       **** 		// THIS IS OBSOLETED BY THE DYNAMIC CHANNEL TO PORT,PIN ASSIGNMENTS
  56:servo.c       **** 		//outb(SERVODDR, inb(SERVODDR) | (1<<channel));
  57:servo.c       **** 	}
  58:servo.c       **** 	// set PosTics
  59:servo.c       **** 	ServoPosTics = 0;
 1993               	.LM169:
 1994 073c 1092 0000 		sts (ServoPosTics)+1,__zero_reg__
 1995 0740 1092 0000 		sts ServoPosTics,__zero_reg__
  60:servo.c       **** 	// set PeriodTics
  61:servo.c       **** 	ServoPeriodTics = SERVO_MAX*9;
 1997               	.LM170:
 1998 0744 8AED      		ldi r24,lo8(1242)
 1999 0746 94E0      		ldi r25,hi8(1242)
 2000 0748 9093 0000 		sts (ServoPeriodTics)+1,r25
 2001 074c 8093 0000 		sts ServoPeriodTics,r24
  62:servo.c       **** 	// set initial interrupt time
  63:servo.c       **** 	u16 OCValue;
  64:servo.c       **** 	// read in current value of output compare register OCR1A
  65:servo.c       **** 	OCValue =  inb(OCR1AL);		// read low byte of OCR1A
 2003               	.LM171:
 2004 0750 2AB5      		in r18,74-0x20
  66:servo.c       **** 	OCValue += inb(OCR1AH)<<8;	// read high byte of OCR1A
 2006               	.LM172:
 2007 0752 8BB5      		in r24,75-0x20
 2008 0754 9927      		clr r25
 2009 0756 982F      		mov r25,r24
 2010 0758 8827      		clr r24
 2011 075a 820F      		add r24,r18
 2012 075c 911D      		adc r25,__zero_reg__
  67:servo.c       **** 	// increment OCR1A value by nextTics
  68:servo.c       **** 	OCValue += ServoPeriodTics; 
 2014               	.LM173:
 2015 075e 8652      		subi r24,lo8(-(1242))
 2016 0760 9B4F      		sbci r25,hi8(-(1242))
  69:servo.c       **** 	// set future output compare time to this new value
  70:servo.c       **** 	outb(OCR1AH, (OCValue>>8));			// write high byte
 2018               	.LM174:
 2019 0762 292F      		mov r18,r25
 2020 0764 3327      		clr r19
 2021 0766 2BBD      		out 75-0x20,r18
  71:servo.c       **** 	outb(OCR1AL, (OCValue & 0x00FF));	// write low byte
 2023               	.LM175:
 2024 0768 8ABD      		out 74-0x20,r24
  72:servo.c       **** 	// enable the timer1 output compare A interrupt
  73:servo.c       **** 	sbi(TIMSK, OCIE1A);
 2026               	.LM176:
 2027 076a 89B7      		in r24,89-0x20
 2028 076c 8061      		ori r24,lo8(16)
 2029 076e 89BF      		out 89-0x20,r24
 2030               	/* epilogue: frame size=0 */
 2031 0770 0895      		ret
 2032               	/* epilogue end (size=1) */
 2033               	/* function servoInit size 65 (64) */
 2039               	.Lscope41:
 2042               	.global	servoOff
 2044               	servoOff:
  74:servo.c       **** }
  75:servo.c       **** 
  76:servo.c       **** //! turns off software PWM system
  77:servo.c       **** void servoOff(void)
  78:servo.c       **** {
 2046               	.LM177:
 2047               	/* prologue: frame size=0 */
 2048               	/* prologue end (size=0) */
  79:servo.c       **** 	// disable the timer1 output compare A interrupt
  80:servo.c       **** 	cbi(TIMSK, OCIE1A);
 2050               	.LM178:
 2051 0772 89B7      		in r24,89-0x20
 2052 0774 8F7E      		andi r24,lo8(-17)
 2053 0776 89BF      		out 89-0x20,r24
  81:servo.c       **** 	// detach the service routine
  82:servo.c       **** 	timerDetach(TIMER1OUTCOMPAREA_INT);
 2055               	.LM179:
 2056 0778 82E0      		ldi r24,lo8(2)
 2057 077a 0E94 0000 		call timerDetach
 2058               	/* epilogue: frame size=0 */
 2059 077e 0895      		ret
 2060               	/* epilogue end (size=1) */
 2061               	/* function servoOff size 7 (6) */
 2063               	.Lscope42:
 2069               	.global	servoSetChannelIO
 2071               	servoSetChannelIO:
  83:servo.c       **** }
  84:servo.c       **** 
  85:servo.c       **** //! set port and I/O pin for channel
  86:servo.c       **** void servoSetChannelIO(u08 channel, u08 port, u08 pin)
  87:servo.c       **** {
 2073               	.LM180:
 2074               	/* prologue: frame size=0 */
 2075               	/* prologue end (size=0) */
 2076 0780 242F      		mov r18,r20
  88:servo.c       **** 	ServoChannels[channel].port = port;
 2078               	.LM181:
 2079 0782 E82F      		mov r30,r24
 2080 0784 FF27      		clr r31
 2081 0786 EE0F      		lsl r30
 2082 0788 FF1F      		rol r31
 2083 078a EE0F      		lsl r30
 2084 078c FF1F      		rol r31
 2085 078e E050      		subi r30,lo8(-(ServoChannels))
 2086 0790 F040      		sbci r31,hi8(-(ServoChannels))
 2087 0792 6083      		st Z,r22
  89:servo.c       **** 	ServoChannels[channel].pin = (1<<(pin&0x07));
 2089               	.LM182:
 2090 0794 3327      		clr r19
 2091 0796 2770      		andi r18,lo8(7)
 2092 0798 3070      		andi r19,hi8(7)
 2093 079a 81E0      		ldi r24,lo8(1)
 2094 079c 90E0      		ldi r25,hi8(1)
 2095 079e 02C0      		rjmp 2f
 2096 07a0 880F      	1:	lsl r24
 2097 07a2 991F      		rol r25
 2098 07a4 2A95      	2:	dec r18
 2099 07a6 E2F7      		brpl 1b
 2100 07a8 8183      		std Z+1,r24
 2101               	/* epilogue: frame size=0 */
 2102 07aa 0895      		ret
 2103               	/* epilogue end (size=1) */
 2104               	/* function servoSetChannelIO size 23 (22) */
 2106               	.Lscope43:
 2111               	.global	servoSetPositionRaw
 2113               	servoSetPositionRaw:
  90:servo.c       **** }
  91:servo.c       **** 
  92:servo.c       **** //! set servo position on channel
  93:servo.c       **** void servoSetPosition(u08 channel, u08 position)
  94:servo.c       **** {
  95:servo.c       **** 	// input should be between 0 and SERVO_POSITION_MAX
  96:servo.c       **** 	u16 pos_scaled;
  97:servo.c       **** 	// calculate scaled position
  98:servo.c       **** 	pos_scaled = ((u16)position*(SERVO_MAX-SERVO_MIN)/SERVO_POSITION_MAX)+SERVO_MIN;
  99:servo.c       **** 	// set position
 100:servo.c       **** 	servoSetPositionRaw(channel, pos_scaled);
 101:servo.c       **** }
 102:servo.c       **** 
 103:servo.c       **** //! get servo position on channel
 104:servo.c       **** u08 servoGetPosition(u08 channel)
 105:servo.c       **** {
 106:servo.c       **** 	return (u08)( ((servoGetPositionRaw(channel)-SERVO_MIN)*SERVO_POSITION_MAX)/(SERVO_MAX-SERVO_MIN) 
 107:servo.c       **** }
 108:servo.c       **** 
 109:servo.c       **** //! set servo position on channel (raw unscaled format)
 110:servo.c       **** void servoSetPositionRaw(u08 channel, u16 position)
 111:servo.c       **** {
 2115               	.LM183:
 2116               	/* prologue: frame size=0 */
 2117               	/* prologue end (size=0) */
 112:servo.c       **** 	// bind to limits
 113:servo.c       **** 	position = MAX(position, SERVO_MIN);
 2119               	.LM184:
 2120 07ac 6232      		cpi r22,34
 2121 07ae 7105      		cpc r23,__zero_reg__
 2122 07b0 10F4      		brsh .L99
 2124               	.LM185:
 2125 07b2 62E2      		ldi r22,lo8(34)
 2126 07b4 70E0      		ldi r23,hi8(34)
 2127               	.L99:
 114:servo.c       **** 	position = MIN(position, SERVO_MAX);
 2129               	.LM186:
 2130 07b6 6B38      		cpi r22,139
 2131 07b8 7105      		cpc r23,__zero_reg__
 2132 07ba 10F0      		brlo .L100
 2133 07bc 6AE8      		ldi r22,lo8(138)
 2134 07be 70E0      		ldi r23,hi8(138)
 2135               	.L100:
 115:servo.c       **** 	// set position
 116:servo.c       **** 	ServoChannels[channel].duty = position;
 2137               	.LM187:
 2138 07c0 E82F      		mov r30,r24
 2139 07c2 FF27      		clr r31
 2140 07c4 EE0F      		lsl r30
 2141 07c6 FF1F      		rol r31
 2142 07c8 EE0F      		lsl r30
 2143 07ca FF1F      		rol r31
 2144 07cc E050      		subi r30,lo8(-(ServoChannels))
 2145 07ce F040      		sbci r31,hi8(-(ServoChannels))
 2146 07d0 7383      		std Z+3,r23
 2147 07d2 6283      		std Z+2,r22
 2148               	/* epilogue: frame size=0 */
 2149 07d4 0895      		ret
 2150               	/* epilogue end (size=1) */
 2151               	/* function servoSetPositionRaw size 21 (20) */
 2153               	.Lscope44:
 2158               	.global	servoSetPosition
 2160               	servoSetPosition:
 2162               	.LM188:
 2163               	/* prologue: frame size=0 */
 2164               	/* prologue end (size=0) */
 2165 07d6 282F      		mov r18,r24
 2167               	.LM189:
 2168 07d8 88E6      		ldi r24,lo8(104)
 2169 07da 689F      		mul r22,r24
 2170 07dc C001      		movw r24,r0
 2171 07de 1124      		clr r1
 2172 07e0 6FEF      		ldi r22,lo8(255)
 2173 07e2 70E0      		ldi r23,hi8(255)
 2174 07e4 0E94 0000 		call __udivmodhi4
 2175 07e8 CB01      		movw r24,r22
 2176 07ea 8296      		adiw r24,34
 2178               	.LM190:
 2179 07ec BC01      		movw r22,r24
 2180 07ee 822F      		mov r24,r18
 2181 07f0 0E94 0000 		call servoSetPositionRaw
 2182               	/* epilogue: frame size=0 */
 2183 07f4 0895      		ret
 2184               	/* epilogue end (size=1) */
 2185               	/* function servoSetPosition size 16 (15) */
 2187               	.Lscope45:
 2191               	.global	servoGetPositionRaw
 2193               	servoGetPositionRaw:
 117:servo.c       **** }
 118:servo.c       **** 
 119:servo.c       **** //! get servo position on channel (raw unscaled format)
 120:servo.c       **** u16 servoGetPositionRaw(u08 channel)
 121:servo.c       **** {
 2195               	.LM191:
 2196               	/* prologue: frame size=0 */
 2197               	/* prologue end (size=0) */
 122:servo.c       **** 	return ServoChannels[channel].duty;
 2199               	.LM192:
 2200 07f6 E82F      		mov r30,r24
 2201 07f8 FF27      		clr r31
 2202 07fa EE0F      		lsl r30
 2203 07fc FF1F      		rol r31
 2204 07fe EE0F      		lsl r30
 2205 0800 FF1F      		rol r31
 2206 0802 E050      		subi r30,lo8(-(ServoChannels))
 2207 0804 F040      		sbci r31,hi8(-(ServoChannels))
 123:servo.c       **** }
 2209               	.LM193:
 2210 0806 8281      		ldd r24,Z+2
 2211 0808 9381      		ldd r25,Z+3
 2212               	/* epilogue: frame size=0 */
 2213 080a 0895      		ret
 2214               	/* epilogue end (size=1) */
 2215               	/* function servoGetPositionRaw size 11 (10) */
 2217               	.Lscope46:
 2221               	.global	servoGetPosition
 2223               	servoGetPosition:
 2225               	.LM194:
 2226               	/* prologue: frame size=0 */
 2227               	/* prologue end (size=0) */
 2229               	.LM195:
 2230 080c 0E94 0000 		call servoGetPositionRaw
 2231 0810 2FEF      		ldi r18,lo8(255)
 2232 0812 30E0      		ldi r19,hi8(255)
 2233 0814 829F      		mul r24,r18
 2234 0816 A001      		movw r20,r0
 2235 0818 839F      		mul r24,r19
 2236 081a 500D      		add r21,r0
 2237 081c 929F      		mul r25,r18
 2238 081e 500D      		add r21,r0
 2239 0820 1124      		clr r1
 2240 0822 CA01      		movw r24,r20
 2241 0824 8E5D      		subi r24,lo8(-(-8670))
 2242 0826 9142      		sbci r25,hi8(-(-8670))
 2243 0828 68E6      		ldi r22,lo8(104)
 2244 082a 70E0      		ldi r23,hi8(104)
 2245 082c 0E94 0000 		call __udivmodhi4
 2246 0830 CB01      		movw r24,r22
 2248               	.LM196:
 2249 0832 9927      		clr r25
 2250               	/* epilogue: frame size=0 */
 2251 0834 0895      		ret
 2252               	/* epilogue end (size=1) */
 2253               	/* function servoGetPosition size 21 (20) */
 2255               	.Lscope47:
 2258               	.global	servoService
 2260               	servoService:
 124:servo.c       **** 
 125:servo.c       **** void servoService(void)
 126:servo.c       **** {
 2262               	.LM197:
 2263               	/* prologue: frame size=0 */
 2264 0836 CF93      		push r28
 2265 0838 DF93      		push r29
 2266               	/* prologue end (size=2) */
 127:servo.c       **** 	u16 nextTics;
 128:servo.c       **** 
 129:servo.c       **** 	if(ServoChannel < SERVO_NUM_CHANNELS)
 2268               	.LM198:
 2269 083a E091 0000 		lds r30,ServoChannel
 2270 083e E230      		cpi r30,lo8(2)
 2271 0840 80F4      		brsh .L105
 130:servo.c       **** 	{
 131:servo.c       **** 		// turn off current channel
 132:servo.c       **** 		outb(_SFR_IO8(ServoChannels[ServoChannel].port), inb(_SFR_IO8(ServoChannels[ServoChannel].port)) 
 2273               	.LM199:
 2274 0842 FF27      		clr r31
 2275 0844 EE0F      		lsl r30
 2276 0846 FF1F      		rol r31
 2277 0848 EE0F      		lsl r30
 2278 084a FF1F      		rol r31
 2279 084c E050      		subi r30,lo8(-(ServoChannels))
 2280 084e F040      		sbci r31,hi8(-(ServoChannels))
 2281 0850 8081      		ld r24,Z
 2282 0852 A82F      		mov r26,r24
 2283 0854 BB27      		clr r27
 2284 0856 9181      		ldd r25,Z+1
 2285 0858 9095      		com r25
 2286 085a ED01      		movw r28,r26
 2287 085c 88A1      		ldd r24,Y+32
 2288 085e 8923      		and r24,r25
 2289 0860 88A3      		std Y+32,r24
 2290               	.L105:
 133:servo.c       **** 	}
 134:servo.c       **** 	
 135:servo.c       **** 	// next channel
 136:servo.c       **** 	ServoChannel++;
 2292               	.LM200:
 2293 0862 8091 0000 		lds r24,ServoChannel
 2294 0866 8F5F      		subi r24,lo8(-(1))
 2295 0868 8093 0000 		sts ServoChannel,r24
 137:servo.c       **** 
 138:servo.c       **** 	if(ServoChannel != SERVO_NUM_CHANNELS)
 2297               	.LM201:
 2298 086c 8230      		cpi r24,lo8(2)
 2299 086e 19F1      		breq .L106
 139:servo.c       **** 	{
 140:servo.c       **** 		// loop to channel 0 if needed
 141:servo.c       **** 		if(ServoChannel > SERVO_NUM_CHANNELS)	ServoChannel = 0;
 2301               	.LM202:
 2302 0870 8330      		cpi r24,lo8(3)
 2303 0872 10F0      		brlo .L107
 2304 0874 1092 0000 		sts ServoChannel,__zero_reg__
 2305               	.L107:
 142:servo.c       **** 		// turn on new channel
 143:servo.c       **** 		outb(_SFR_IO8(ServoChannels[ServoChannel].port), inb(_SFR_IO8(ServoChannels[ServoChannel].port)) 
 2307               	.LM203:
 2308 0878 8091 0000 		lds r24,ServoChannel
 2309 087c E82F      		mov r30,r24
 2310 087e FF27      		clr r31
 2311 0880 EE0F      		lsl r30
 2312 0882 FF1F      		rol r31
 2313 0884 EE0F      		lsl r30
 2314 0886 FF1F      		rol r31
 2315 0888 E050      		subi r30,lo8(-(ServoChannels))
 2316 088a F040      		sbci r31,hi8(-(ServoChannels))
 2317 088c 8081      		ld r24,Z
 2318 088e A82F      		mov r26,r24
 2319 0890 BB27      		clr r27
 2320 0892 ED01      		movw r28,r26
 2321 0894 88A1      		ldd r24,Y+32
 2322 0896 9181      		ldd r25,Z+1
 2323 0898 892B      		or r24,r25
 2324 089a 88A3      		std Y+32,r24
 144:servo.c       **** 		// schedule turn off time
 145:servo.c       **** 		nextTics = ServoChannels[ServoChannel].duty;
 2326               	.LM204:
 2327 089c 8091 0000 		lds r24,ServoChannel
 2328 08a0 E82F      		mov r30,r24
 2329 08a2 FF27      		clr r31
 2330 08a4 EE0F      		lsl r30
 2331 08a6 FF1F      		rol r31
 2332 08a8 EE0F      		lsl r30
 2333 08aa FF1F      		rol r31
 2334 08ac E050      		subi r30,lo8(-(ServoChannels))
 2335 08ae F040      		sbci r31,hi8(-(ServoChannels))
 2336 08b0 4281      		ldd r20,Z+2
 2337 08b2 5381      		ldd r21,Z+3
 2338 08b4 0AC0      		rjmp .L108
 2339               	.L106:
 146:servo.c       **** 	}
 147:servo.c       **** 	else //(Channel == SERVO_NUM_CHANNELS)
 148:servo.c       **** 	{
 149:servo.c       **** 		// ***we could save time by precalculating this
 150:servo.c       **** 		// schedule end-of-period
 151:servo.c       **** 		nextTics = ServoPeriodTics-ServoPosTics;
 2341               	.LM205:
 2342 08b6 4091 0000 		lds r20,ServoPeriodTics
 2343 08ba 5091 0000 		lds r21,(ServoPeriodTics)+1
 2344 08be 8091 0000 		lds r24,ServoPosTics
 2345 08c2 9091 0000 		lds r25,(ServoPosTics)+1
 2346 08c6 481B      		sub r20,r24
 2347 08c8 590B      		sbc r21,r25
 2348               	.L108:
 152:servo.c       **** 	}
 153:servo.c       **** 
 154:servo.c       **** 	// schedule next interrupt
 155:servo.c       **** 	u16 OCValue;
 156:servo.c       **** 	// read in current value of output compare register OCR1A
 157:servo.c       **** 	OCValue =  inb(OCR1AL);		// read low byte of OCR1A
 2350               	.LM206:
 2351 08ca 2AB5      		in r18,74-0x20
 158:servo.c       **** 	OCValue += inb(OCR1AH)<<8;	// read high byte of OCR1A
 2353               	.LM207:
 2354 08cc 8BB5      		in r24,75-0x20
 2355 08ce 9927      		clr r25
 2356 08d0 982F      		mov r25,r24
 2357 08d2 8827      		clr r24
 2358 08d4 820F      		add r24,r18
 2359 08d6 911D      		adc r25,__zero_reg__
 159:servo.c       **** 	// increment OCR1A value by nextTics
 160:servo.c       **** 	OCValue += nextTics;
 2361               	.LM208:
 2362 08d8 840F      		add r24,r20
 2363 08da 951F      		adc r25,r21
 161:servo.c       **** //	OCR1A+=nextTics;
 162:servo.c       **** 	// set future output compare time to this new value
 163:servo.c       **** 	outb(OCR1AH, (OCValue>>8));			// write high byte
 2365               	.LM209:
 2366 08dc 292F      		mov r18,r25
 2367 08de 3327      		clr r19
 2368 08e0 2BBD      		out 75-0x20,r18
 164:servo.c       **** 	outb(OCR1AL, (OCValue & 0x00FF));	// write low byte
 2370               	.LM210:
 2371 08e2 8ABD      		out 74-0x20,r24
 165:servo.c       **** 	// set our new tic position
 166:servo.c       **** 	ServoPosTics += nextTics;
 2373               	.LM211:
 2374 08e4 8091 0000 		lds r24,ServoPosTics
 2375 08e8 9091 0000 		lds r25,(ServoPosTics)+1
 2376 08ec 840F      		add r24,r20
 2377 08ee 951F      		adc r25,r21
 2378 08f0 9093 0000 		sts (ServoPosTics)+1,r25
 2379 08f4 8093 0000 		sts ServoPosTics,r24
 167:servo.c       **** 	if(ServoPosTics >= ServoPeriodTics) ServoPosTics = 0;
 2381               	.LM212:
 2382 08f8 2091 0000 		lds r18,ServoPeriodTics
 2383 08fc 3091 0000 		lds r19,(ServoPeriodTics)+1
 2384 0900 8217      		cp r24,r18
 2385 0902 9307      		cpc r25,r19
 2386 0904 20F0      		brlo .L104
 2387 0906 1092 0000 		sts (ServoPosTics)+1,__zero_reg__
 2388 090a 1092 0000 		sts ServoPosTics,__zero_reg__
 2389               	.L104:
 2390               	/* epilogue: frame size=0 */
 2391 090e DF91      		pop r29
 2392 0910 CF91      		pop r28
 2393 0912 0895      		ret
 2394               	/* epilogue end (size=3) */
 2395               	/* function servoService size 111 (106) */
 2401               	.Lscope48:
 2404               	.global	__vector_11
 2406               	__vector_11:
 2408               	.Ltext4:
   1:SerialExample.c **** /*
   2:SerialExample.c ****     Serial interface Demo for AvrXFifo's
   3:SerialExample.c **** 
   4:SerialExample.c ****     Also illustrates the use of Frame based variables
   5:SerialExample.c ****     at the top level tasking (switched from NAKED to
   6:SerialExample.c ****     NORETURN function attribute)
   7:SerialExample.c **** 
   8:SerialExample.c **** 	When linked with simple serialio there is no buffering
   9:SerialExample.c **** 	of charactors so only two charactors can be received
  10:SerialExample.c **** 	during the delay (Hardware buffering within the USART).
  11:SerialExample.c **** 
  12:SerialExample.c **** 	When linked with the buffered IO up to 31 (or whatever
  13:SerialExample.c **** 	the buffer size - 1 is) charactors can be received while
  14:SerialExample.c **** 	delaying.
  15:SerialExample.c **** */
  16:SerialExample.c **** #include <avr/io.h>
  17:SerialExample.c **** #include <avr/pgmspace.h>
  18:SerialExample.c **** #include <avrx-signal.h>
  19:SerialExample.c **** #include <stdio.h>
  20:SerialExample.c **** #include "avrx.h"
  21:SerialExample.c **** #include <avr/signal.h>	// include "signal" names (interrupt names)
  22:SerialExample.c **** #include <avr/interrupt.h>	// include interrupt support
  23:SerialExample.c **** #include <stdlib.h>
  24:SerialExample.c **** 
  25:SerialExample.c **** // Uncomment this to override "AvrXSerialIo.h and just use one channel
  26:SerialExample.c **** //#define USART_CHANNELS (1<1)	// 0 - USART0, 1 = USART1
  27:SerialExample.c **** 
  28:SerialExample.c **** #include "AvrXSerialIo.h"
  29:SerialExample.c **** 
  30:SerialExample.c **** #include "parserconf.h"
  31:SerialExample.c **** #include "parser.h"
  32:SerialExample.c **** #include "parser.c"
  33:SerialExample.c **** 
  34:SerialExample.c **** 
  35:SerialExample.c **** // global AVRLIB defines
  36:SerialExample.c **** #include <../../avrlibdefs.h>
  37:SerialExample.c **** // global AVRLIB types definitions
  38:SerialExample.c **** #include <../../avrlibtypes.h>
  39:SerialExample.c **** #include "global.h"
  40:SerialExample.c **** 
  41:SerialExample.c **** #include "timer.h"
  42:SerialExample.c **** #include "timer.c"
  43:SerialExample.c **** #include "servo.h"
  44:SerialExample.c **** #include "servo.c"
  45:SerialExample.c **** /*
  46:SerialExample.c **** enum
  47:SerialExample.c **** {
  48:SerialExample.c **** 	FALSE,
  49:SerialExample.c **** 	TRUE
  50:SerialExample.c **** };
  51:SerialExample.c **** 
  52:SerialExample.c **** typedef unsigned char BOOL;
  53:SerialExample.c **** */
  54:SerialExample.c **** 
  55:SerialExample.c **** // Peripheral initialization
  56:SerialExample.c **** 
  57:SerialExample.c **** #define TCNT0_INIT (0xFF-CPUCLK/256/TICKRATE)
  58:SerialExample.c **** #define LEFT_SERVO_CHAN 	0
  59:SerialExample.c **** #define RIGHT_SERVO_CHAN 	1
  60:SerialExample.c **** #define THROTTLE_SERVO_CHAN 2
  61:SerialExample.c **** #define CAM_PAN_SERVO_CHAN  3
  62:SerialExample.c **** #define CAM_TILT_SERVO_CHAN 4
  63:SerialExample.c **** 
  64:SerialExample.c **** #define DEBUG 0
  65:SerialExample.c **** 
  66:SerialExample.c **** void setLeftServo(void);
  67:SerialExample.c **** void setRightServo(void);
  68:SerialExample.c **** void setThrottleServo(void);
  69:SerialExample.c **** void setCamPanServo(void);
  70:SerialExample.c **** void setCamTiltServo(void);
  71:SerialExample.c **** 
  72:SerialExample.c **** int leftServoPos = 50;		//0 seems to be beyond its reach
  73:SerialExample.c **** int rightServoPos;
  74:SerialExample.c **** int throttleServoPos;
  75:SerialExample.c **** int camPanServoPos;
  76:SerialExample.c **** int camTiltServoPos;
  77:SerialExample.c **** 
  78:SerialExample.c **** //long funcAParam;
  79:SerialExample.c **** //long funcBParam;
  80:SerialExample.c **** 
  81:SerialExample.c **** 
  82:SerialExample.c **** /*
  83:SerialExample.c ****  Timer 0 Overflow Interrupt Handler
  84:SerialExample.c **** 
  85:SerialExample.c ****  Prototypical Interrupt handler:
  86:SerialExample.c ****  . Switch to kernel context
  87:SerialExample.c ****  . handle interrupt
  88:SerialExample.c ****  . switch back to interrupted context.
  89:SerialExample.c ****  */
  90:SerialExample.c **** 
  91:SerialExample.c **** AVRX_SIGINT(SIG_OVERFLOW0)
  92:SerialExample.c **** {
 2410               	.LM213:
 2411               	/* prologue: frame size=0 */
 2412               	/* prologue: naked */
 2413               	/* prologue end (size=0) */
  93:SerialExample.c ****     IntProlog();                // Switch to kernel stack/context
 2415               	.LM214:
 2416 0914 0E94 0000 		call IntProlog
  94:SerialExample.c ****     TCNT0 += TCNT0_INIT;		// Add to pre-load to account for any missed clocks
 2418               	.LM215:
 2419 0918 82B7      		in r24,82-0x20
 2420 091a 8F53      		subi r24,lo8(-(-63))
 2421 091c 82BF      		out 82-0x20,r24
  95:SerialExample.c ****     AvrXTimerHandler();         // Call Time queue manager
 2423               	.LM216:
 2424 091e 0E94 0000 		call AvrXTimerHandler
  96:SerialExample.c ****     Epilog();                   // Return to tasks
 2426               	.LM217:
 2427 0922 0E94 0000 		call Epilog
 2428               	/* epilogue: frame size=0 */
 2429               	/* epilogue: naked */
 2430               	/* epilogue end (size=0) */
 2431               	/* function __vector_11 size 9 (9) */
 2433               	.Lscope49:
 2438               	.global	myputs
 2440               	myputs:
  97:SerialExample.c **** }
  98:SerialExample.c **** 
  99:SerialExample.c **** 
 100:SerialExample.c **** 
 101:SerialExample.c **** // Super simple string printers...
 102:SerialExample.c **** 
 103:SerialExample.c **** // PutString from RAM
 104:SerialExample.c **** void myputs(int (*putch)(char), const uint8_t * psz)
 105:SerialExample.c **** {
 2442               	.LM218:
 2443               	/* prologue: frame size=0 */
 2444 0926 0F93      		push r16
 2445 0928 1F93      		push r17
 2446 092a CF93      		push r28
 2447 092c DF93      		push r29
 2448               	/* prologue end (size=4) */
 2449 092e 8C01      		movw r16,r24
 2450 0930 EB01      		movw r28,r22
 106:SerialExample.c **** 	while (*psz != 0)
 107:SerialExample.c **** 		(*putch)(*psz++);
 2452               	.LM219:
 2453 0932 8881      		ld r24,Y
 2454 0934 8823      		tst r24
 2455 0936 31F0      		breq .L116
 2456               	.L114:
 2458               	.LM220:
 2459 0938 8991      		ld r24,Y+
 2460 093a F801      		movw r30,r16
 2461 093c 0995      		icall
 2462 093e 8881      		ld r24,Y
 2463 0940 8823      		tst r24
 2464 0942 D1F7      		brne .L114
 2465               	.L116:
 2466               	/* epilogue: frame size=0 */
 2467 0944 DF91      		pop r29
 2468 0946 CF91      		pop r28
 2469 0948 1F91      		pop r17
 2470 094a 0F91      		pop r16
 2471 094c 0895      		ret
 2472               	/* epilogue end (size=5) */
 2473               	/* function myputs size 20 (11) */
 2475               	.Lscope50:
 2480               	.global	myputs_P
 2482               	myputs_P:
 108:SerialExample.c **** }
 109:SerialExample.c **** 
 110:SerialExample.c **** // PutString from FLASH
 111:SerialExample.c **** void myputs_P(int (*putch)(char), const uint8_t * psz)
 112:SerialExample.c **** {
 2484               	.LM221:
 2485               	/* prologue: frame size=0 */
 2486 094e 0F93      		push r16
 2487 0950 1F93      		push r17
 2488 0952 CF93      		push r28
 2489 0954 DF93      		push r29
 2490               	/* prologue end (size=4) */
 2491 0956 8C01      		movw r16,r24
 2492 0958 EB01      		movw r28,r22
 2493               	.LBB5:
 113:SerialExample.c **** 	while (__LPM(psz) != 0)
 114:SerialExample.c **** 		(*putch)(__LPM(psz++));
 2495               	.LM222:
 2496 095a FB01      		movw r30,r22
 2497               	/* #APP */
 2498 095c 8491      		lpm r24, Z
 2499               		
 2500               	/* #NOAPP */
 2501               	.LBE5:
 2502 095e 8823      		tst r24
 2503 0960 49F0      		breq .L122
 2504               	.L120:
 2505               	.LBB6:
 2507               	.LM223:
 2508 0962 FE01      		movw r30,r28
 2509 0964 2196      		adiw r28,1
 2510               	/* #APP */
 2511 0966 8491      		lpm r24, Z
 2512               		
 2513               	/* #NOAPP */
 2514               	.LBE6:
 2515 0968 F801      		movw r30,r16
 2516 096a 0995      		icall
 2517               	.LBB7:
 2518 096c FE01      		movw r30,r28
 2519               	/* #APP */
 2520 096e 8491      		lpm r24, Z
 2521               		
 2522               	/* #NOAPP */
 2523               	.LBE7:
 2524 0970 8823      		tst r24
 2525 0972 B9F7      		brne .L120
 2526               	.L122:
 2527               	/* epilogue: frame size=0 */
 2528 0974 DF91      		pop r29
 2529 0976 CF91      		pop r28
 2530 0978 1F91      		pop r17
 2531 097a 0F91      		pop r16
 2532 097c 0895      		ret
 2533               	/* epilogue end (size=5) */
 2534               	/* function myputs_P size 33 (24) */
 2545               	.Lscope51:
 2547               		.section	.progmem.data
 2550               	__c.20:
 2551 005b 3100      		.string	"1"
 2552               		.text
 2554               	.global	getUAVStatus
 2556               	getUAVStatus:
 115:SerialExample.c **** }
 116:SerialExample.c **** 
 117:SerialExample.c **** //#if (USART_CHANNELS & CHANNEL_0)
 118:SerialExample.c **** 
 119:SerialExample.c **** //tell the ground station I am OK by sending a "1" 10 times a second
 120:SerialExample.c **** AVRX_GCC_TASKDEF(getUAVStatus, 76, 4)
 121:SerialExample.c **** {	
 2558               	.LM224:
 2559               	/* prologue: frame size=6 */
 2560 097e CF93      		push r28
 2561 0980 DF93      		push r29
 2562 0982 CDB7      		in r28,__SP_L__
 2563 0984 DEB7      		in r29,__SP_H__
 2564 0986 2697      		sbiw r28,6
 2565 0988 0FB6      		in __tmp_reg__,__SREG__
 2566 098a F894      		cli
 2567 098c DEBF      		out __SP_H__,r29
 2568 098e 0FBE      		out __SREG__,__tmp_reg__
 2569 0990 CDBF      		out __SP_L__,r28
 2570               	/* prologue end (size=10) */
 2571               	.L124:
 122:SerialExample.c **** 	TimerControlBlock timer;
 123:SerialExample.c **** 	
 124:SerialExample.c **** 	while(1)
 125:SerialExample.c **** 	{
 126:SerialExample.c **** 		printf_P(PSTR("1"));
 2573               	.LM225:
 2574 0992 80E0      		ldi r24,lo8(__c.20)
 2575 0994 90E0      		ldi r25,hi8(__c.20)
 2576 0996 9F93      		push r25
 2577 0998 8F93      		push r24
 2578 099a 0E94 0000 		call printf_P
 127:SerialExample.c **** 		putchar('\r');
 2580               	.LM226:
 2581 099e 6091 0000 		lds r22,__iob+2
 2582 09a2 7091 0000 		lds r23,(__iob+2)+1
 2583 09a6 8DE0      		ldi r24,lo8(13)
 2584 09a8 90E0      		ldi r25,hi8(13)
 2585 09aa 0E94 0000 		call fputc
 128:SerialExample.c **** 		if (DEBUG) putchar('\n');
 2587               	.LM227:
 2588 09ae 0F90      		pop __tmp_reg__
 2589 09b0 0F90      		pop __tmp_reg__
 129:SerialExample.c **** 		AvrXDelay(&timer, 100);
 2591               	.LM228:
 2592 09b2 64E6      		ldi r22,lo8(100)
 2593 09b4 70E0      		ldi r23,hi8(100)
 2594 09b6 CE01      		movw r24,r28
 2595 09b8 0196      		adiw r24,1
 2596 09ba 0E94 0000 		call AvrXDelay
 2597 09be E9CF      		rjmp .L124
 2598               	/* epilogue: frame size=6 */
 2599               	/* epilogue: noreturn */
 2600               	/* epilogue end (size=0) */
 2601               	/* function getUAVStatus size 33 (23) */
 2606               	.Lscope52:
 2608               		.section	.progmem.data
 2611               	__c.18:
 2612 005d 6320 2564 		.string	"c %d"
 2612      00
 2615               	__c.19:
 2616 0062 6320 2564 		.string	"c %d"
 2616      00
 2617               		.text
 2619               	.global	getCompassHeading
 2621               	getCompassHeading:
 130:SerialExample.c **** 	}
 131:SerialExample.c **** }
 132:SerialExample.c **** 
 133:SerialExample.c **** AVRX_GCC_TASKDEF(getCompassHeading, 76, 4)
 134:SerialExample.c **** {
 2623               	.LM229:
 2624               	/* prologue: frame size=6 */
 2625 09c0 CF93      		push r28
 2626 09c2 DF93      		push r29
 2627 09c4 CDB7      		in r28,__SP_L__
 2628 09c6 DEB7      		in r29,__SP_H__
 2629 09c8 2697      		sbiw r28,6
 2630 09ca 0FB6      		in __tmp_reg__,__SREG__
 2631 09cc F894      		cli
 2632 09ce DEBF      		out __SP_H__,r29
 2633 09d0 0FBE      		out __SREG__,__tmp_reg__
 2634 09d2 CDBF      		out __SP_L__,r28
 2635               	/* prologue end (size=10) */
 2636               	.L128:
 2637               	.LBB8:
 135:SerialExample.c **** 	TimerControlBlock timer;
 136:SerialExample.c **** 	
 137:SerialExample.c **** 	while(1)
 138:SerialExample.c **** 	{
 139:SerialExample.c **** 		int c = 0;
 2639               	.LM230:
 2640 09d4 00E0      		ldi r16,lo8(0)
 2641 09d6 10E0      		ldi r17,hi8(0)
 2642               	.L133:
 140:SerialExample.c **** 		
 141:SerialExample.c **** 		while (c<360)
 142:SerialExample.c **** 		{	printf_P(PSTR("c %d"), c/3);   	// c/3 evaluates to an int, even it c is not a multiple of
 2644               	.LM231:
 2645 09d8 C801      		movw r24,r16
 2646 09da 63E0      		ldi r22,lo8(3)
 2647 09dc 70E0      		ldi r23,hi8(3)
 2648 09de 0E94 0000 		call __divmodhi4
 2649 09e2 7F93      		push r23
 2650 09e4 6F93      		push r22
 2651 09e6 80E0      		ldi r24,lo8(__c.18)
 2652 09e8 90E0      		ldi r25,hi8(__c.18)
 2653 09ea 9F93      		push r25
 2654 09ec 8F93      		push r24
 2655 09ee 0E94 0000 		call printf_P
 143:SerialExample.c **** 			putchar('\r');					// 3.  This way, the heading is sent as ONE char instead of
 2657               	.LM232:
 2658 09f2 6091 0000 		lds r22,__iob+2
 2659 09f6 7091 0000 		lds r23,(__iob+2)+1
 2660 09fa 8DE0      		ldi r24,lo8(13)
 2661 09fc 90E0      		ldi r25,hi8(13)
 2662 09fe 0E94 0000 		call fputc
 144:SerialExample.c **** 			if (DEBUG) putchar('\n');		// one, two, or three.
 2664               	.LM233:
 2665 0a02 0F90      		pop __tmp_reg__
 2666 0a04 0F90      		pop __tmp_reg__
 2667 0a06 0F90      		pop __tmp_reg__
 2668 0a08 0F90      		pop __tmp_reg__
 145:SerialExample.c **** 			c++;
 2670               	.LM234:
 2671 0a0a 0F5F      		subi r16,lo8(-(1))
 2672 0a0c 1F4F      		sbci r17,hi8(-(1))
 146:SerialExample.c **** 			AvrXDelay(&timer, 1000);
 2674               	.LM235:
 2675 0a0e 68EE      		ldi r22,lo8(1000)
 2676 0a10 73E0      		ldi r23,hi8(1000)
 2677 0a12 CE01      		movw r24,r28
 2678 0a14 0196      		adiw r24,1
 2679 0a16 0E94 0000 		call AvrXDelay
 2680 0a1a 81E0      		ldi r24,hi8(360)
 2681 0a1c 0836      		cpi r16,lo8(360)
 2682 0a1e 1807      		cpc r17,r24
 2683 0a20 DCF2      		brlt .L133
 2684 0a22 08E6      		ldi r16,lo8(360)
 2685 0a24 11E0      		ldi r17,hi8(360)
 2686               	.L137:
 147:SerialExample.c **** 		}
 148:SerialExample.c **** 		while (c>0)
 149:SerialExample.c **** 		{	printf_P(PSTR("c %d"), c/3);
 2688               	.LM236:
 2689 0a26 C801      		movw r24,r16
 2690 0a28 63E0      		ldi r22,lo8(3)
 2691 0a2a 70E0      		ldi r23,hi8(3)
 2692 0a2c 0E94 0000 		call __divmodhi4
 2693 0a30 7F93      		push r23
 2694 0a32 6F93      		push r22
 2695 0a34 80E0      		ldi r24,lo8(__c.19)
 2696 0a36 90E0      		ldi r25,hi8(__c.19)
 2697 0a38 9F93      		push r25
 2698 0a3a 8F93      		push r24
 2699 0a3c 0E94 0000 		call printf_P
 150:SerialExample.c **** 			putchar('\r');
 2701               	.LM237:
 2702 0a40 6091 0000 		lds r22,__iob+2
 2703 0a44 7091 0000 		lds r23,(__iob+2)+1
 2704 0a48 8DE0      		ldi r24,lo8(13)
 2705 0a4a 90E0      		ldi r25,hi8(13)
 2706 0a4c 0E94 0000 		call fputc
 151:SerialExample.c **** 			if (DEBUG) putchar('\n');		//We only want a newline if we are debugging on
 2708               	.LM238:
 2709 0a50 0F90      		pop __tmp_reg__
 2710 0a52 0F90      		pop __tmp_reg__
 2711 0a54 0F90      		pop __tmp_reg__
 2712 0a56 0F90      		pop __tmp_reg__
 152:SerialExample.c **** 			c--;							//a terminal.  Otherwise, we are communicating with
 2714               	.LM239:
 2715 0a58 0150      		subi r16,lo8(-(-1))
 2716 0a5a 1040      		sbci r17,hi8(-(-1))
 153:SerialExample.c **** 			AvrXDelay(&timer, 1000);		//the ground station and it should not be sent.
 2718               	.LM240:
 2719 0a5c 68EE      		ldi r22,lo8(1000)
 2720 0a5e 73E0      		ldi r23,hi8(1000)
 2721 0a60 CE01      		movw r24,r28
 2722 0a62 0196      		adiw r24,1
 2723 0a64 0E94 0000 		call AvrXDelay
 2724 0a68 1016      		cp __zero_reg__,r16
 2725 0a6a 1106      		cpc __zero_reg__,r17
 2726 0a6c E4F2      		brlt .L137
 2727               	.LBE8:
 2728 0a6e B2CF      		rjmp .L128
 2729               	/* epilogue: frame size=6 */
 2730               	/* epilogue: noreturn */
 2731               	/* epilogue end (size=0) */
 2732               	/* function getCompassHeading size 88 (78) */
 2740               	.Lscope53:
 2742               		.section	.progmem.data
 2745               	__c.16:
 2746 0067 7320 2564 		.string	"s %d"
 2746      00
 2749               	__c.17:
 2750 006c 7320 2564 		.string	"s %d"
 2750      00
 2751               		.text
 2753               	.global	getAirspeed
 2755               	getAirspeed:
 154:SerialExample.c **** 		}
 155:SerialExample.c **** 	}
 156:SerialExample.c **** }
 157:SerialExample.c **** 
 158:SerialExample.c **** AVRX_GCC_TASKDEF(getAirspeed, 76, 4)
 159:SerialExample.c **** {
 2757               	.LM241:
 2758               	/* prologue: frame size=6 */
 2759 0a70 CF93      		push r28
 2760 0a72 DF93      		push r29
 2761 0a74 CDB7      		in r28,__SP_L__
 2762 0a76 DEB7      		in r29,__SP_H__
 2763 0a78 2697      		sbiw r28,6
 2764 0a7a 0FB6      		in __tmp_reg__,__SREG__
 2765 0a7c F894      		cli
 2766 0a7e DEBF      		out __SP_H__,r29
 2767 0a80 0FBE      		out __SREG__,__tmp_reg__
 2768 0a82 CDBF      		out __SP_L__,r28
 2769               	/* prologue end (size=10) */
 160:SerialExample.c **** 	TimerControlBlock timer;
 161:SerialExample.c **** 	int s = 0;
 2771               	.LM242:
 2772 0a84 00E0      		ldi r16,lo8(0)
 2773 0a86 10E0      		ldi r17,hi8(0)
 2774               	.L160:
 162:SerialExample.c **** 	
 163:SerialExample.c **** 	while(1)
 164:SerialExample.c **** 	{	
 165:SerialExample.c **** 		while (s<25)
 166:SerialExample.c **** 		{	printf_P(PSTR("s %d"), s);   
 167:SerialExample.c **** 			putchar('\r');
 168:SerialExample.c **** 			if (DEBUG) putchar('\n');	
 169:SerialExample.c **** 			s++;							
 170:SerialExample.c **** 			AvrXDelay(&timer, 1000);
 2776               	.LM243:
 2777 0a88 0931      		cpi r16,25
 2778 0a8a 1105      		cpc r17,__zero_reg__
 2779 0a8c ECF4      		brge .L154
 2781               	.LM244:
 2782 0a8e 1F93      		push r17
 2783 0a90 0F93      		push r16
 2784 0a92 80E0      		ldi r24,lo8(__c.16)
 2785 0a94 90E0      		ldi r25,hi8(__c.16)
 2786 0a96 9F93      		push r25
 2787 0a98 8F93      		push r24
 2788 0a9a 0E94 0000 		call printf_P
 2790               	.LM245:
 2791 0a9e 6091 0000 		lds r22,__iob+2
 2792 0aa2 7091 0000 		lds r23,(__iob+2)+1
 2793 0aa6 8DE0      		ldi r24,lo8(13)
 2794 0aa8 90E0      		ldi r25,hi8(13)
 2795 0aaa 0E94 0000 		call fputc
 2797               	.LM246:
 2798 0aae 0F90      		pop __tmp_reg__
 2799 0ab0 0F90      		pop __tmp_reg__
 2800 0ab2 0F90      		pop __tmp_reg__
 2801 0ab4 0F90      		pop __tmp_reg__
 2803               	.LM247:
 2804 0ab6 0F5F      		subi r16,lo8(-(1))
 2805 0ab8 1F4F      		sbci r17,hi8(-(1))
 2807               	.LM248:
 2808 0aba 68EE      		ldi r22,lo8(1000)
 2809 0abc 73E0      		ldi r23,hi8(1000)
 2810 0abe CE01      		movw r24,r28
 2811 0ac0 0196      		adiw r24,1
 2812 0ac2 0E94 0000 		call AvrXDelay
 2813 0ac6 E0CF      		rjmp .L160
 2814               	.L154:
 171:SerialExample.c **** 		}
 172:SerialExample.c **** 		while (s>15)
 173:SerialExample.c **** 		{	printf_P(PSTR("s %d"), s);
 174:SerialExample.c **** 			putchar('\r');
 175:SerialExample.c **** 			if (DEBUG) putchar('\n');
 176:SerialExample.c **** 			s--;
 177:SerialExample.c **** 			AvrXDelay(&timer, 1000);
 2816               	.LM249:
 2817 0ac8 0031      		cpi r16,16
 2818 0aca 1105      		cpc r17,__zero_reg__
 2819 0acc ECF2      		brlt .L160
 2821               	.LM250:
 2822 0ace 1F93      		push r17
 2823 0ad0 0F93      		push r16
 2824 0ad2 80E0      		ldi r24,lo8(__c.17)
 2825 0ad4 90E0      		ldi r25,hi8(__c.17)
 2826 0ad6 9F93      		push r25
 2827 0ad8 8F93      		push r24
 2828 0ada 0E94 0000 		call printf_P
 2830               	.LM251:
 2831 0ade 6091 0000 		lds r22,__iob+2
 2832 0ae2 7091 0000 		lds r23,(__iob+2)+1
 2833 0ae6 8DE0      		ldi r24,lo8(13)
 2834 0ae8 90E0      		ldi r25,hi8(13)
 2835 0aea 0E94 0000 		call fputc
 2837               	.LM252:
 2838 0aee 0F90      		pop __tmp_reg__
 2839 0af0 0F90      		pop __tmp_reg__
 2840 0af2 0F90      		pop __tmp_reg__
 2841 0af4 0F90      		pop __tmp_reg__
 2843               	.LM253:
 2844 0af6 0150      		subi r16,lo8(-(-1))
 2845 0af8 1040      		sbci r17,hi8(-(-1))
 2847               	.LM254:
 2848 0afa 68EE      		ldi r22,lo8(1000)
 2849 0afc 73E0      		ldi r23,hi8(1000)
 2850 0afe CE01      		movw r24,r28
 2851 0b00 0196      		adiw r24,1
 2852 0b02 0E94 0000 		call AvrXDelay
 2853 0b06 E0CF      		rjmp .L154
 2854               	/* epilogue: frame size=6 */
 2855               	/* epilogue: noreturn */
 2856               	/* epilogue end (size=0) */
 2857               	/* function getAirspeed size 76 (66) */
 2863               	.Lscope54:
 2865               		.section	.progmem.data
 2868               	__c.14:
 2869 0071 6720 2564 		.string	"g %d"
 2869      00
 2872               	__c.15:
 2873 0076 6720 2564 		.string	"g %d"
 2873      00
 2874               		.text
 2876               	.global	getGroundspeed
 2878               	getGroundspeed:
 178:SerialExample.c **** 		}
 179:SerialExample.c **** 	}
 180:SerialExample.c **** }
 181:SerialExample.c **** 
 182:SerialExample.c **** AVRX_GCC_TASKDEF(getGroundspeed, 76, 4)
 183:SerialExample.c **** {
 2880               	.LM255:
 2881               	/* prologue: frame size=6 */
 2882 0b08 CF93      		push r28
 2883 0b0a DF93      		push r29
 2884 0b0c CDB7      		in r28,__SP_L__
 2885 0b0e DEB7      		in r29,__SP_H__
 2886 0b10 2697      		sbiw r28,6
 2887 0b12 0FB6      		in __tmp_reg__,__SREG__
 2888 0b14 F894      		cli
 2889 0b16 DEBF      		out __SP_H__,r29
 2890 0b18 0FBE      		out __SREG__,__tmp_reg__
 2891 0b1a CDBF      		out __SP_L__,r28
 2892               	/* prologue end (size=10) */
 184:SerialExample.c **** 	TimerControlBlock timer;
 185:SerialExample.c **** 	int g = 18;
 2894               	.LM256:
 2895 0b1c 02E1      		ldi r16,lo8(18)
 2896 0b1e 10E0      		ldi r17,hi8(18)
 2897               	.L179:
 186:SerialExample.c **** 	
 187:SerialExample.c **** 	while(1)
 188:SerialExample.c **** 	{	
 189:SerialExample.c **** 		while (g<22)
 190:SerialExample.c **** 		{	printf_P(PSTR("g %d"), g);   
 191:SerialExample.c **** 			putchar('\r');
 192:SerialExample.c **** 			if (DEBUG) putchar('\n');	
 193:SerialExample.c **** 			g++;							
 194:SerialExample.c **** 			AvrXDelay(&timer, 30*1000);
 2899               	.LM257:
 2900 0b20 0631      		cpi r16,22
 2901 0b22 1105      		cpc r17,__zero_reg__
 2902 0b24 ECF4      		brge .L173
 2904               	.LM258:
 2905 0b26 1F93      		push r17
 2906 0b28 0F93      		push r16
 2907 0b2a 80E0      		ldi r24,lo8(__c.14)
 2908 0b2c 90E0      		ldi r25,hi8(__c.14)
 2909 0b2e 9F93      		push r25
 2910 0b30 8F93      		push r24
 2911 0b32 0E94 0000 		call printf_P
 2913               	.LM259:
 2914 0b36 6091 0000 		lds r22,__iob+2
 2915 0b3a 7091 0000 		lds r23,(__iob+2)+1
 2916 0b3e 8DE0      		ldi r24,lo8(13)
 2917 0b40 90E0      		ldi r25,hi8(13)
 2918 0b42 0E94 0000 		call fputc
 2920               	.LM260:
 2921 0b46 0F90      		pop __tmp_reg__
 2922 0b48 0F90      		pop __tmp_reg__
 2923 0b4a 0F90      		pop __tmp_reg__
 2924 0b4c 0F90      		pop __tmp_reg__
 2926               	.LM261:
 2927 0b4e 0F5F      		subi r16,lo8(-(1))
 2928 0b50 1F4F      		sbci r17,hi8(-(1))
 2930               	.LM262:
 2931 0b52 60E3      		ldi r22,lo8(30000)
 2932 0b54 75E7      		ldi r23,hi8(30000)
 2933 0b56 CE01      		movw r24,r28
 2934 0b58 0196      		adiw r24,1
 2935 0b5a 0E94 0000 		call AvrXDelay
 2936 0b5e E0CF      		rjmp .L179
 2937               	.L173:
 195:SerialExample.c **** 		}
 196:SerialExample.c **** 		while (g>18)
 197:SerialExample.c **** 		{	printf_P(PSTR("g %d"), g);
 198:SerialExample.c **** 			putchar('\r');
 199:SerialExample.c **** 			if (DEBUG) putchar('\n');
 200:SerialExample.c **** 			g--;
 201:SerialExample.c **** 			AvrXDelay(&timer, 30*1000);
 2939               	.LM263:
 2940 0b60 0331      		cpi r16,19
 2941 0b62 1105      		cpc r17,__zero_reg__
 2942 0b64 ECF2      		brlt .L179
 2944               	.LM264:
 2945 0b66 1F93      		push r17
 2946 0b68 0F93      		push r16
 2947 0b6a 80E0      		ldi r24,lo8(__c.15)
 2948 0b6c 90E0      		ldi r25,hi8(__c.15)
 2949 0b6e 9F93      		push r25
 2950 0b70 8F93      		push r24
 2951 0b72 0E94 0000 		call printf_P
 2953               	.LM265:
 2954 0b76 6091 0000 		lds r22,__iob+2
 2955 0b7a 7091 0000 		lds r23,(__iob+2)+1
 2956 0b7e 8DE0      		ldi r24,lo8(13)
 2957 0b80 90E0      		ldi r25,hi8(13)
 2958 0b82 0E94 0000 		call fputc
 2960               	.LM266:
 2961 0b86 0F90      		pop __tmp_reg__
 2962 0b88 0F90      		pop __tmp_reg__
 2963 0b8a 0F90      		pop __tmp_reg__
 2964 0b8c 0F90      		pop __tmp_reg__
 2966               	.LM267:
 2967 0b8e 0150      		subi r16,lo8(-(-1))
 2968 0b90 1040      		sbci r17,hi8(-(-1))
 2970               	.LM268:
 2971 0b92 60E3      		ldi r22,lo8(30000)
 2972 0b94 75E7      		ldi r23,hi8(30000)
 2973 0b96 CE01      		movw r24,r28
 2974 0b98 0196      		adiw r24,1
 2975 0b9a 0E94 0000 		call AvrXDelay
 2976 0b9e E0CF      		rjmp .L173
 2977               	/* epilogue: frame size=6 */
 2978               	/* epilogue: noreturn */
 2979               	/* epilogue end (size=0) */
 2980               	/* function getGroundspeed size 76 (66) */
 2986               	.Lscope55:
 2988               		.section	.progmem.data
 2991               	__c.8:
 2992 007b 6120 3036 		.string	"a 067.5759E"
 2992      372E 3537 
 2992      3539 4500 
 2995               	__c.9:
 2996 0087 6F20 3839 		.string	"o 89.12345N"
 2996      2E31 3233 
 2996      3435 4E00 
 2999               	__c.10:
 3000 0093 7A20 2564 		.string	"z %d"
 3000      00
 3003               	__c.11:
 3004 0098 6120 3130 		.string	"a 101.4512W"
 3004      312E 3435 
 3004      3132 5700 
 3007               	__c.12:
 3008 00a4 6F20 3035 		.string	"o 05.98765S"
 3008      2E39 3837 
 3008      3635 5300 
 3011               	__c.13:
 3012 00b0 7A20 2564 		.string	"z %d"
 3012      00
 3013               		.text
 3015               	.global	getGPSData
 3017               	getGPSData:
 202:SerialExample.c **** 		}
 203:SerialExample.c **** 	}
 204:SerialExample.c **** }
 205:SerialExample.c **** 
 206:SerialExample.c **** AVRX_GCC_TASKDEF(getGPSData, 76, 4)
 207:SerialExample.c **** {
 3019               	.LM269:
 3020               	/* prologue: frame size=6 */
 3021 0ba0 CF93      		push r28
 3022 0ba2 DF93      		push r29
 3023 0ba4 CDB7      		in r28,__SP_L__
 3024 0ba6 DEB7      		in r29,__SP_H__
 3025 0ba8 2697      		sbiw r28,6
 3026 0baa 0FB6      		in __tmp_reg__,__SREG__
 3027 0bac F894      		cli
 3028 0bae DEBF      		out __SP_H__,r29
 3029 0bb0 0FBE      		out __SREG__,__tmp_reg__
 3030 0bb2 CDBF      		out __SP_L__,r28
 3031               	/* prologue end (size=10) */
 208:SerialExample.c **** 	TimerControlBlock timer;
 209:SerialExample.c **** 	int z = 0;
 3033               	.LM270:
 3034 0bb4 00E0      		ldi r16,lo8(0)
 3035 0bb6 10E0      		ldi r17,hi8(0)
 3036               	.L181:
 210:SerialExample.c **** 	
 211:SerialExample.c **** 	while(1)
 212:SerialExample.c **** 	{	
 213:SerialExample.c **** 		// Since latitude and longitude cannot be expressed as simple integers,
 214:SerialExample.c **** 		// we cannot fake the measurements by cycling through some numbers.
 215:SerialExample.c **** 		printf_P(PSTR("a 067.5759E"));   
 3038               	.LM271:
 3039 0bb8 80E0      		ldi r24,lo8(__c.8)
 3040 0bba 90E0      		ldi r25,hi8(__c.8)
 3041 0bbc 9F93      		push r25
 3042 0bbe 8F93      		push r24
 3043 0bc0 0E94 0000 		call printf_P
 216:SerialExample.c **** 		putchar('\r');
 3045               	.LM272:
 3046 0bc4 6091 0000 		lds r22,__iob+2
 3047 0bc8 7091 0000 		lds r23,(__iob+2)+1
 3048 0bcc 8DE0      		ldi r24,lo8(13)
 3049 0bce 90E0      		ldi r25,hi8(13)
 3050 0bd0 0E94 0000 		call fputc
 217:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3052               	.LM273:
 3053 0bd4 0F90      		pop __tmp_reg__
 3054 0bd6 0F90      		pop __tmp_reg__
 218:SerialExample.c **** 		
 219:SerialExample.c **** 		printf_P(PSTR("o 89.12345N"));	
 3056               	.LM274:
 3057 0bd8 80E0      		ldi r24,lo8(__c.9)
 3058 0bda 90E0      		ldi r25,hi8(__c.9)
 3059 0bdc 9F93      		push r25
 3060 0bde 8F93      		push r24
 3061 0be0 0E94 0000 		call printf_P
 220:SerialExample.c **** 		putchar('\r');
 3063               	.LM275:
 3064 0be4 6091 0000 		lds r22,__iob+2
 3065 0be8 7091 0000 		lds r23,(__iob+2)+1
 3066 0bec 8DE0      		ldi r24,lo8(13)
 3067 0bee 90E0      		ldi r25,hi8(13)
 3068 0bf0 0E94 0000 		call fputc
 221:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3070               	.LM276:
 3071 0bf4 0F90      		pop __tmp_reg__
 3072 0bf6 0F90      		pop __tmp_reg__
 222:SerialExample.c **** 		
 223:SerialExample.c **** 		printf_P(PSTR("z %d"), z);
 3074               	.LM277:
 3075 0bf8 1F93      		push r17
 3076 0bfa 0F93      		push r16
 3077 0bfc 80E0      		ldi r24,lo8(__c.10)
 3078 0bfe 90E0      		ldi r25,hi8(__c.10)
 3079 0c00 9F93      		push r25
 3080 0c02 8F93      		push r24
 3081 0c04 0E94 0000 		call printf_P
 224:SerialExample.c **** 		putchar('\r');
 3083               	.LM278:
 3084 0c08 6091 0000 		lds r22,__iob+2
 3085 0c0c 7091 0000 		lds r23,(__iob+2)+1
 3086 0c10 8DE0      		ldi r24,lo8(13)
 3087 0c12 90E0      		ldi r25,hi8(13)
 3088 0c14 0E94 0000 		call fputc
 225:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3090               	.LM279:
 3091 0c18 0F90      		pop __tmp_reg__
 3092 0c1a 0F90      		pop __tmp_reg__
 3093 0c1c 0F90      		pop __tmp_reg__
 3094 0c1e 0F90      		pop __tmp_reg__
 226:SerialExample.c **** 		
 227:SerialExample.c **** 		if (z<100) z++;
 3096               	.LM280:
 3097 0c20 0436      		cpi r16,100
 3098 0c22 1105      		cpc r17,__zero_reg__
 3099 0c24 14F4      		brge .L186
 3100 0c26 0F5F      		subi r16,lo8(-(1))
 3101 0c28 1F4F      		sbci r17,hi8(-(1))
 3102               	.L186:
 228:SerialExample.c **** 		AvrXDelay(&timer, 1000);
 3104               	.LM281:
 3105 0c2a 68EE      		ldi r22,lo8(1000)
 3106 0c2c 73E0      		ldi r23,hi8(1000)
 3107 0c2e CE01      		movw r24,r28
 3108 0c30 0196      		adiw r24,1
 3109 0c32 0E94 0000 		call AvrXDelay
 229:SerialExample.c **** 		
 230:SerialExample.c **** 		
 231:SerialExample.c **** 		
 232:SerialExample.c **** 		printf_P(PSTR("a 101.4512W"));   
 3111               	.LM282:
 3112 0c36 80E0      		ldi r24,lo8(__c.11)
 3113 0c38 90E0      		ldi r25,hi8(__c.11)
 3114 0c3a 9F93      		push r25
 3115 0c3c 8F93      		push r24
 3116 0c3e 0E94 0000 		call printf_P
 233:SerialExample.c **** 		putchar('\r');
 3118               	.LM283:
 3119 0c42 6091 0000 		lds r22,__iob+2
 3120 0c46 7091 0000 		lds r23,(__iob+2)+1
 3121 0c4a 8DE0      		ldi r24,lo8(13)
 3122 0c4c 90E0      		ldi r25,hi8(13)
 3123 0c4e 0E94 0000 		call fputc
 234:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3125               	.LM284:
 3126 0c52 0F90      		pop __tmp_reg__
 3127 0c54 0F90      		pop __tmp_reg__
 235:SerialExample.c **** 		
 236:SerialExample.c **** 		printf_P(PSTR("o 05.98765S"));   
 3129               	.LM285:
 3130 0c56 80E0      		ldi r24,lo8(__c.12)
 3131 0c58 90E0      		ldi r25,hi8(__c.12)
 3132 0c5a 9F93      		push r25
 3133 0c5c 8F93      		push r24
 3134 0c5e 0E94 0000 		call printf_P
 237:SerialExample.c **** 		putchar('\r');
 3136               	.LM286:
 3137 0c62 6091 0000 		lds r22,__iob+2
 3138 0c66 7091 0000 		lds r23,(__iob+2)+1
 3139 0c6a 8DE0      		ldi r24,lo8(13)
 3140 0c6c 90E0      		ldi r25,hi8(13)
 3141 0c6e 0E94 0000 		call fputc
 238:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3143               	.LM287:
 3144 0c72 0F90      		pop __tmp_reg__
 3145 0c74 0F90      		pop __tmp_reg__
 239:SerialExample.c **** 		
 240:SerialExample.c **** 		printf_P(PSTR("z %d"), z);
 3147               	.LM288:
 3148 0c76 1F93      		push r17
 3149 0c78 0F93      		push r16
 3150 0c7a 80E0      		ldi r24,lo8(__c.13)
 3151 0c7c 90E0      		ldi r25,hi8(__c.13)
 3152 0c7e 9F93      		push r25
 3153 0c80 8F93      		push r24
 3154 0c82 0E94 0000 		call printf_P
 241:SerialExample.c **** 		putchar('\r');
 3156               	.LM289:
 3157 0c86 6091 0000 		lds r22,__iob+2
 3158 0c8a 7091 0000 		lds r23,(__iob+2)+1
 3159 0c8e 8DE0      		ldi r24,lo8(13)
 3160 0c90 90E0      		ldi r25,hi8(13)
 3161 0c92 0E94 0000 		call fputc
 242:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3163               	.LM290:
 3164 0c96 0F90      		pop __tmp_reg__
 3165 0c98 0F90      		pop __tmp_reg__
 3166 0c9a 0F90      		pop __tmp_reg__
 3167 0c9c 0F90      		pop __tmp_reg__
 243:SerialExample.c **** 		
 244:SerialExample.c **** 		if (z<100) z++;	
 3169               	.LM291:
 3170 0c9e 0436      		cpi r16,100
 3171 0ca0 1105      		cpc r17,__zero_reg__
 3172 0ca2 14F4      		brge .L190
 3173 0ca4 0F5F      		subi r16,lo8(-(1))
 3174 0ca6 1F4F      		sbci r17,hi8(-(1))
 3175               	.L190:
 245:SerialExample.c **** 		AvrXDelay(&timer, 1000);
 3177               	.LM292:
 3178 0ca8 68EE      		ldi r22,lo8(1000)
 3179 0caa 73E0      		ldi r23,hi8(1000)
 3180 0cac CE01      		movw r24,r28
 3181 0cae 0196      		adiw r24,1
 3182 0cb0 0E94 0000 		call AvrXDelay
 3183 0cb4 81CF      		rjmp .L181
 3184               	/* epilogue: frame size=6 */
 3185               	/* epilogue: noreturn */
 3186               	/* epilogue end (size=0) */
 3187               	/* function getGPSData size 139 (129) */
 3193               	.Lscope56:
 3195               		.section	.progmem.data
 3198               	__c.6:
 3199 00b5 6220 2564 		.string	"b %d"
 3199      00
 3202               	__c.7:
 3203 00ba 6620 2564 		.string	"f %d"
 3203      00
 3204               		.text
 3206               	.global	getFuelAndBattery
 3208               	getFuelAndBattery:
 246:SerialExample.c **** 		
 247:SerialExample.c **** 	}		
 248:SerialExample.c **** }
 249:SerialExample.c **** 
 250:SerialExample.c **** AVRX_GCC_TASKDEF(getFuelAndBattery, 76, 4)
 251:SerialExample.c **** {
 3210               	.LM293:
 3211               	/* prologue: frame size=6 */
 3212 0cb6 CF93      		push r28
 3213 0cb8 DF93      		push r29
 3214 0cba CDB7      		in r28,__SP_L__
 3215 0cbc DEB7      		in r29,__SP_H__
 3216 0cbe 2697      		sbiw r28,6
 3217 0cc0 0FB6      		in __tmp_reg__,__SREG__
 3218 0cc2 F894      		cli
 3219 0cc4 DEBF      		out __SP_H__,r29
 3220 0cc6 0FBE      		out __SREG__,__tmp_reg__
 3221 0cc8 CDBF      		out __SP_L__,r28
 3222               	/* prologue end (size=10) */
 252:SerialExample.c **** 	TimerControlBlock timer;
 253:SerialExample.c **** 	int b = 100;
 3224               	.LM294:
 3225 0cca 04E6      		ldi r16,lo8(100)
 3226 0ccc 10E0      		ldi r17,hi8(100)
 254:SerialExample.c **** 	int f = 100;
 3228               	.LM295:
 3229 0cce 7801      		movw r14,r16
 3230               	.L192:
 255:SerialExample.c **** 	
 256:SerialExample.c **** 	while(1)
 257:SerialExample.c **** 	{	
 258:SerialExample.c **** 		printf_P(PSTR("b %d"), b);   
 3232               	.LM296:
 3233 0cd0 FF92      		push r15
 3234 0cd2 EF92      		push r14
 3235 0cd4 80E0      		ldi r24,lo8(__c.6)
 3236 0cd6 90E0      		ldi r25,hi8(__c.6)
 3237 0cd8 9F93      		push r25
 3238 0cda 8F93      		push r24
 3239 0cdc 0E94 0000 		call printf_P
 259:SerialExample.c **** 		putchar('\r');
 3241               	.LM297:
 3242 0ce0 6091 0000 		lds r22,__iob+2
 3243 0ce4 7091 0000 		lds r23,(__iob+2)+1
 3244 0ce8 8DE0      		ldi r24,lo8(13)
 3245 0cea 90E0      		ldi r25,hi8(13)
 3246 0cec 0E94 0000 		call fputc
 260:SerialExample.c **** 		if (DEBUG) putchar('\n');	
 3248               	.LM298:
 3249 0cf0 0F90      		pop __tmp_reg__
 3250 0cf2 0F90      		pop __tmp_reg__
 3251 0cf4 0F90      		pop __tmp_reg__
 3252 0cf6 0F90      		pop __tmp_reg__
 261:SerialExample.c **** 		printf_P(PSTR("f %d"), f);
 3254               	.LM299:
 3255 0cf8 1F93      		push r17
 3256 0cfa 0F93      		push r16
 3257 0cfc 80E0      		ldi r24,lo8(__c.7)
 3258 0cfe 90E0      		ldi r25,hi8(__c.7)
 3259 0d00 9F93      		push r25
 3260 0d02 8F93      		push r24
 3261 0d04 0E94 0000 		call printf_P
 262:SerialExample.c **** 		putchar('\r');
 3263               	.LM300:
 3264 0d08 6091 0000 		lds r22,__iob+2
 3265 0d0c 7091 0000 		lds r23,(__iob+2)+1
 3266 0d10 8DE0      		ldi r24,lo8(13)
 3267 0d12 90E0      		ldi r25,hi8(13)
 3268 0d14 0E94 0000 		call fputc
 263:SerialExample.c **** 		if (DEBUG) putchar('\n');							
 3270               	.LM301:
 3271 0d18 0F90      		pop __tmp_reg__
 3272 0d1a 0F90      		pop __tmp_reg__
 3273 0d1c 0F90      		pop __tmp_reg__
 3274 0d1e 0F90      		pop __tmp_reg__
 264:SerialExample.c **** 		b--;
 3276               	.LM302:
 3277 0d20 0894      		sec
 3278 0d22 E108      		sbc r14,__zero_reg__
 3279 0d24 F108      		sbc r15,__zero_reg__
 265:SerialExample.c **** 		f--;
 3281               	.LM303:
 3282 0d26 0150      		subi r16,lo8(-(-1))
 3283 0d28 1040      		sbci r17,hi8(-(-1))
 266:SerialExample.c **** 		AvrXDelay(&timer, 30*1000);
 3285               	.LM304:
 3286 0d2a 60E3      		ldi r22,lo8(30000)
 3287 0d2c 75E7      		ldi r23,hi8(30000)
 3288 0d2e CE01      		movw r24,r28
 3289 0d30 0196      		adiw r24,1
 3290 0d32 0E94 0000 		call AvrXDelay
 3291 0d36 CCCF      		rjmp .L192
 3292               	/* epilogue: frame size=6 */
 3293               	/* epilogue: noreturn */
 3294               	/* epilogue end (size=0) */
 3295               	/* function getFuelAndBattery size 65 (55) */
 3302               	.Lscope57:
 3304               		.section	.progmem.data
 3307               	__c.2:
 3308 00bf 7120 2564 		.string	"q %d"
 3308      00
 3311               	__c.3:
 3312 00c4 7720 2564 		.string	"w %d"
 3312      00
 3315               	__c.4:
 3316 00c9 7120 2564 		.string	"q %d"
 3316      00
 3319               	__c.5:
 3320 00ce 7720 2564 		.string	"w %d"
 3320      00
 3321               		.text
 3323               	.global	getPitchAndRoll
 3325               	getPitchAndRoll:
 267:SerialExample.c **** 	}
 268:SerialExample.c **** }
 269:SerialExample.c **** 
 270:SerialExample.c **** 
 271:SerialExample.c **** AVRX_GCC_TASKDEF(getPitchAndRoll, 76, 4)
 272:SerialExample.c **** {
 3327               	.LM305:
 3328               	/* prologue: frame size=6 */
 3329 0d38 CF93      		push r28
 3330 0d3a DF93      		push r29
 3331 0d3c CDB7      		in r28,__SP_L__
 3332 0d3e DEB7      		in r29,__SP_H__
 3333 0d40 2697      		sbiw r28,6
 3334 0d42 0FB6      		in __tmp_reg__,__SREG__
 3335 0d44 F894      		cli
 3336 0d46 DEBF      		out __SP_H__,r29
 3337 0d48 0FBE      		out __SREG__,__tmp_reg__
 3338 0d4a CDBF      		out __SP_L__,r28
 3339               	/* prologue end (size=10) */
 273:SerialExample.c **** 	TimerControlBlock timer;
 274:SerialExample.c **** 	int q = 0;
 3341               	.LM306:
 3342 0d4c 00E0      		ldi r16,lo8(0)
 3343 0d4e 10E0      		ldi r17,hi8(0)
 275:SerialExample.c **** 	int w = 127;
 3345               	.LM307:
 3346 0d50 7FE7      		ldi r23,lo8(127)
 3347 0d52 E72E      		mov r14,r23
 3348 0d54 F12C      		mov r15,__zero_reg__
 3349               	.L216:
 276:SerialExample.c **** 	
 277:SerialExample.c **** 	while(1)
 278:SerialExample.c **** 	{	
 279:SerialExample.c **** 		while (q<127)
 280:SerialExample.c **** 		{	printf_P(PSTR("q %d"), q);   
 281:SerialExample.c **** 			putchar('\r');
 282:SerialExample.c **** 			if (DEBUG) putchar('\n');	
 283:SerialExample.c **** 			printf_P(PSTR("w %d"), w);
 284:SerialExample.c **** 			putchar('\r');
 285:SerialExample.c **** 			if (DEBUG) putchar('\n');
 286:SerialExample.c **** 			q++;					
 287:SerialExample.c **** 			w--;		
 288:SerialExample.c **** 			AvrXDelay(&timer, 33);		//try 33Hz
 3351               	.LM308:
 3352 0d56 0F37      		cpi r16,127
 3353 0d58 1105      		cpc r17,__zero_reg__
 3354 0d5a A4F5      		brge .L210
 3356               	.LM309:
 3357 0d5c 1F93      		push r17
 3358 0d5e 0F93      		push r16
 3359 0d60 80E0      		ldi r24,lo8(__c.2)
 3360 0d62 90E0      		ldi r25,hi8(__c.2)
 3361 0d64 9F93      		push r25
 3362 0d66 8F93      		push r24
 3363 0d68 0E94 0000 		call printf_P
 3365               	.LM310:
 3366 0d6c 6091 0000 		lds r22,__iob+2
 3367 0d70 7091 0000 		lds r23,(__iob+2)+1
 3368 0d74 8DE0      		ldi r24,lo8(13)
 3369 0d76 90E0      		ldi r25,hi8(13)
 3370 0d78 0E94 0000 		call fputc
 3372               	.LM311:
 3373 0d7c 0F90      		pop __tmp_reg__
 3374 0d7e 0F90      		pop __tmp_reg__
 3375 0d80 0F90      		pop __tmp_reg__
 3376 0d82 0F90      		pop __tmp_reg__
 3378               	.LM312:
 3379 0d84 FF92      		push r15
 3380 0d86 EF92      		push r14
 3381 0d88 80E0      		ldi r24,lo8(__c.3)
 3382 0d8a 90E0      		ldi r25,hi8(__c.3)
 3383 0d8c 9F93      		push r25
 3384 0d8e 8F93      		push r24
 3385 0d90 0E94 0000 		call printf_P
 3387               	.LM313:
 3388 0d94 6091 0000 		lds r22,__iob+2
 3389 0d98 7091 0000 		lds r23,(__iob+2)+1
 3390 0d9c 8DE0      		ldi r24,lo8(13)
 3391 0d9e 90E0      		ldi r25,hi8(13)
 3392 0da0 0E94 0000 		call fputc
 3394               	.LM314:
 3395 0da4 0F90      		pop __tmp_reg__
 3396 0da6 0F90      		pop __tmp_reg__
 3397 0da8 0F90      		pop __tmp_reg__
 3398 0daa 0F90      		pop __tmp_reg__
 3400               	.LM315:
 3401 0dac 0F5F      		subi r16,lo8(-(1))
 3402 0dae 1F4F      		sbci r17,hi8(-(1))
 3404               	.LM316:
 3405 0db0 0894      		sec
 3406 0db2 E108      		sbc r14,__zero_reg__
 3407 0db4 F108      		sbc r15,__zero_reg__
 3409               	.LM317:
 3410 0db6 61E2      		ldi r22,lo8(33)
 3411 0db8 70E0      		ldi r23,hi8(33)
 3412 0dba CE01      		movw r24,r28
 3413 0dbc 0196      		adiw r24,1
 3414 0dbe 0E94 0000 		call AvrXDelay
 3415 0dc2 C9CF      		rjmp .L216
 3416               	.L210:
 289:SerialExample.c **** 		}
 290:SerialExample.c **** 		while (q>0)
 291:SerialExample.c **** 		{	printf_P(PSTR("q %d"), q);
 292:SerialExample.c **** 			putchar('\r');
 293:SerialExample.c **** 			if (DEBUG) putchar('\n');
 294:SerialExample.c **** 			printf_P(PSTR("w %d"), w);
 295:SerialExample.c **** 			putchar('\r');
 296:SerialExample.c **** 			if (DEBUG) putchar('\n');
 297:SerialExample.c **** 			q--;
 298:SerialExample.c **** 			w++;
 299:SerialExample.c **** 			AvrXDelay(&timer, 33);
 3418               	.LM318:
 3419 0dc4 1016      		cp __zero_reg__,r16
 3420 0dc6 1106      		cpc __zero_reg__,r17
 3421 0dc8 34F6      		brge .L216
 3423               	.LM319:
 3424 0dca 1F93      		push r17
 3425 0dcc 0F93      		push r16
 3426 0dce 80E0      		ldi r24,lo8(__c.4)
 3427 0dd0 90E0      		ldi r25,hi8(__c.4)
 3428 0dd2 9F93      		push r25
 3429 0dd4 8F93      		push r24
 3430 0dd6 0E94 0000 		call printf_P
 3432               	.LM320:
 3433 0dda 6091 0000 		lds r22,__iob+2
 3434 0dde 7091 0000 		lds r23,(__iob+2)+1
 3435 0de2 8DE0      		ldi r24,lo8(13)
 3436 0de4 90E0      		ldi r25,hi8(13)
 3437 0de6 0E94 0000 		call fputc
 3439               	.LM321:
 3440 0dea 0F90      		pop __tmp_reg__
 3441 0dec 0F90      		pop __tmp_reg__
 3442 0dee 0F90      		pop __tmp_reg__
 3443 0df0 0F90      		pop __tmp_reg__
 3445               	.LM322:
 3446 0df2 FF92      		push r15
 3447 0df4 EF92      		push r14
 3448 0df6 80E0      		ldi r24,lo8(__c.5)
 3449 0df8 90E0      		ldi r25,hi8(__c.5)
 3450 0dfa 9F93      		push r25
 3451 0dfc 8F93      		push r24
 3452 0dfe 0E94 0000 		call printf_P
 3454               	.LM323:
 3455 0e02 6091 0000 		lds r22,__iob+2
 3456 0e06 7091 0000 		lds r23,(__iob+2)+1
 3457 0e0a 8DE0      		ldi r24,lo8(13)
 3458 0e0c 90E0      		ldi r25,hi8(13)
 3459 0e0e 0E94 0000 		call fputc
 3461               	.LM324:
 3462 0e12 0F90      		pop __tmp_reg__
 3463 0e14 0F90      		pop __tmp_reg__
 3464 0e16 0F90      		pop __tmp_reg__
 3465 0e18 0F90      		pop __tmp_reg__
 3467               	.LM325:
 3468 0e1a 0150      		subi r16,lo8(-(-1))
 3469 0e1c 1040      		sbci r17,hi8(-(-1))
 3471               	.LM326:
 3472 0e1e 0894      		sec
 3473 0e20 E11C      		adc r14,__zero_reg__
 3474 0e22 F11C      		adc r15,__zero_reg__
 3476               	.LM327:
 3477 0e24 61E2      		ldi r22,lo8(33)
 3478 0e26 70E0      		ldi r23,hi8(33)
 3479 0e28 CE01      		movw r24,r28
 3480 0e2a 0196      		adiw r24,1
 3481 0e2c 0E94 0000 		call AvrXDelay
 3482 0e30 C9CF      		rjmp .L210
 3483               	/* epilogue: frame size=6 */
 3484               	/* epilogue: noreturn */
 3485               	/* epilogue end (size=0) */
 3486               	/* function getPitchAndRoll size 125 (115) */
 3493               	.Lscope58:
 3496               	.global	getCommands
 3498               	getCommands:
 300:SerialExample.c **** 		}
 301:SerialExample.c **** 	}
 302:SerialExample.c **** }
 303:SerialExample.c **** 
 304:SerialExample.c **** AVRX_GCC_TASKDEF(getCommands, 100, 5)
 305:SerialExample.c **** {	
 3500               	.LM328:
 3501               	/* prologue: frame size=0 */
 3502               	/* prologue end (size=0) */
 306:SerialExample.c **** 	int c;		
 307:SerialExample.c **** 	
 308:SerialExample.c **** 	while (1)
 309:SerialExample.c **** 	{
 310:SerialExample.c **** 		while ((c = getchar()) != EOF)
 3504               	.LM329:
 3505 0e32 15C0      		rjmp .L227
 3506               	.L223:
 311:SerialExample.c **** 		{	
 312:SerialExample.c **** 			if (c == '\r')
 3508               	.LM330:
 3509 0e34 CD30      		cpi r28,13
 3510 0e36 D105      		cpc r29,__zero_reg__
 3511 0e38 79F4      		brne .L222
 313:SerialExample.c **** 			{	putchar('\r');
 3513               	.LM331:
 3514 0e3a 6091 0000 		lds r22,__iob+2
 3515 0e3e 7091 0000 		lds r23,(__iob+2)+1
 3516 0e42 CE01      		movw r24,r28
 3517 0e44 0E94 0000 		call fputc
 314:SerialExample.c **** 				putchar('\n');
 3519               	.LM332:
 3520 0e48 6091 0000 		lds r22,__iob+2
 3521 0e4c 7091 0000 		lds r23,(__iob+2)+1
 3522 0e50 8AE0      		ldi r24,lo8(10)
 3523 0e52 90E0      		ldi r25,hi8(10)
 3524 0e54 0E94 0000 		call fputc
 3525               	.L222:
 315:SerialExample.c **** 			}
 316:SerialExample.c **** 			parserInputFunc(c);
 3527               	.LM333:
 3528 0e58 8C2F      		mov r24,r28
 3529 0e5a 0E94 0000 		call parserInputFunc
 3530               	.L227:
 3531 0e5e 8091 0000 		lds r24,__iob
 3532 0e62 9091 0000 		lds r25,(__iob)+1
 3533 0e66 0E94 0000 		call fgetc
 3534 0e6a EC01      		movw r28,r24
 3535 0e6c 8FEF      		ldi r24,hi8(-1)
 3536 0e6e CF3F      		cpi r28,lo8(-1)
 3537 0e70 D807      		cpc r29,r24
 3538 0e72 01F7      		brne .L223
 3539 0e74 F4CF      		rjmp .L227
 3540               	/* epilogue: frame size=0 */
 3541               	/* epilogue: noreturn */
 3542               	/* epilogue end (size=0) */
 3543               	/* function getCommands size 34 (34) */
 3548               	.Lscope59:
 3550               		.section	.progmem.data
 3553               	__c.0:
 3554 00d3 4920 666F 		.string	"I founded Rhizome!\r\n"
 3554      756E 6465 
 3554      6420 5268 
 3554      697A 6F6D 
 3554      6521 0D0A 
 3557               	__c.1:
 3558 00e8 2564 2000 		.string	"%d "
 3559               		.text
 3561               	.global	marktribe
 3563               	marktribe:
 317:SerialExample.c **** 		}
 318:SerialExample.c **** 	}
 319:SerialExample.c **** }
 320:SerialExample.c **** 
 321:SerialExample.c **** AVRX_GCC_TASKDEF(marktribe, 70, 3)
 322:SerialExample.c **** {
 3565               	.LM334:
 3566               	/* prologue: frame size=6 */
 3567 0e76 CF93      		push r28
 3568 0e78 DF93      		push r29
 3569 0e7a CDB7      		in r28,__SP_L__
 3570 0e7c DEB7      		in r29,__SP_H__
 3571 0e7e 2697      		sbiw r28,6
 3572 0e80 0FB6      		in __tmp_reg__,__SREG__
 3573 0e82 F894      		cli
 3574 0e84 DEBF      		out __SP_H__,r29
 3575 0e86 0FBE      		out __SREG__,__tmp_reg__
 3576 0e88 CDBF      		out __SP_L__,r28
 3577               	/* prologue end (size=10) */
 323:SerialExample.c **** 	TimerControlBlock timer2;
 324:SerialExample.c ****     char c = 'a';
 3579               	.LM335:
 3580 0e8a 11E6      		ldi r17,lo8(97)
 325:SerialExample.c ****     printf_P(PSTR("I founded Rhizome!\r\n"));
 3582               	.LM336:
 3583 0e8c 80E0      		ldi r24,lo8(__c.0)
 3584 0e8e 90E0      		ldi r25,hi8(__c.0)
 3585 0e90 9F93      		push r25
 3586 0e92 8F93      		push r24
 3587 0e94 0E94 0000 		call printf_P
 326:SerialExample.c ****     while(1)
 3589               	.LM337:
 3590 0e98 0F90      		pop __tmp_reg__
 3591 0e9a 0F90      		pop __tmp_reg__
 3592               	.L229:
 327:SerialExample.c ****     {    
 328:SerialExample.c ****         printf_P(PSTR("%d "),c);
 3594               	.LM338:
 3595 0e9c 812F      		mov r24,r17
 3596 0e9e 9927      		clr r25
 3597 0ea0 87FD      		sbrc r24,7
 3598 0ea2 9095      		com r25
 3599 0ea4 9F93      		push r25
 3600 0ea6 8F93      		push r24
 3601 0ea8 80E0      		ldi r24,lo8(__c.1)
 3602 0eaa 90E0      		ldi r25,hi8(__c.1)
 3603 0eac 9F93      		push r25
 3604 0eae 8F93      		push r24
 3605 0eb0 0E94 0000 		call printf_P
 329:SerialExample.c ****         c++;
 3607               	.LM339:
 3608 0eb4 1F5F      		subi r17,lo8(-(1))
 330:SerialExample.c ****         AvrXDelay(&timer2, 1000); //supposed to be a 1000 ms delay
 3610               	.LM340:
 3611 0eb6 68EE      		ldi r22,lo8(1000)
 3612 0eb8 73E0      		ldi r23,hi8(1000)
 3613 0eba CE01      		movw r24,r28
 3614 0ebc 0196      		adiw r24,1
 3615 0ebe 0E94 0000 		call AvrXDelay
 3616 0ec2 0F90      		pop __tmp_reg__
 3617 0ec4 0F90      		pop __tmp_reg__
 3618 0ec6 0F90      		pop __tmp_reg__
 3619 0ec8 0F90      		pop __tmp_reg__
 3620 0eca E8CF      		rjmp .L229
 3621               	/* epilogue: frame size=6 */
 3622               	/* epilogue: noreturn */
 3623               	/* epilogue end (size=0) */
 3624               	/* function marktribe size 43 (33) */
 3630               	.Lscope60:
 3632               		.data
 3633               	.LC0:
 3634 0002 6C00      		.string	"l"
 3635               	.LC1:
 3636 0004 7200      		.string	"r"
 3637               	.LC2:
 3638 0006 7400      		.string	"t"
 3639               	.LC3:
 3640 0008 7000      		.string	"p"
 3641               	.LC4:
 3642 000a 6900      		.string	"i"
 3643               		.text
 3645               	.global	main
 3647               	main:
 331:SerialExample.c ****     }
 332:SerialExample.c ****     
 333:SerialExample.c **** }
 334:SerialExample.c **** 	
 335:SerialExample.c **** /*
 336:SerialExample.c **** AVRX_GCC_TASKDEF(servos, 120, 1)
 337:SerialExample.c **** {
 338:SerialExample.c **** 	TimerControlBlock timer3;
 339:SerialExample.c **** 	
 340:SerialExample.c **** 	u08 pos;
 341:SerialExample.c **** 	u08 channel;
 342:SerialExample.c **** 
 343:SerialExample.c **** 	// do some examples
 344:SerialExample.c **** 	// initialize RC servo system
 345:SerialExample.c **** 	servoInit();
 346:SerialExample.c **** 	// setup servo output channel-to-I/Opin mapping
 347:SerialExample.c **** 	// format is servoSetChannelIO( CHANNEL#, PORT, PIN );
 348:SerialExample.c **** 	servoSetChannelIO(0, _SFR_IO_ADDR(PORTC), PC0);
 349:SerialExample.c **** 
 350:SerialExample.c **** 
 351:SerialExample.c **** 	// set port pins to output
 352:SerialExample.c **** 	outb(DDRC, 0x01);
 353:SerialExample.c **** 
 354:SerialExample.c **** 	pos = 0;
 355:SerialExample.c **** 	
 356:SerialExample.c **** 	#define SPEED_SERVO	1
 357:SerialExample.c **** 
 358:SerialExample.c **** 	// spin servos sequentially back and forth between their limits
 359:SerialExample.c **** 	while(1)
 360:SerialExample.c **** 	{
 361:SerialExample.c **** 		for(channel=0; channel<SERVO_NUM_CHANNELS; channel++)
 362:SerialExample.c **** 		{
 363:SerialExample.c **** 			for(pos=0; pos<SERVO_POSITION_MAX; pos++)
 364:SerialExample.c **** 			{
 365:SerialExample.c **** 				servoSetPosition(channel,pos);
 366:SerialExample.c **** 				AvrXDelay(&timer3, 1000);;
 367:SerialExample.c **** 			}
 368:SerialExample.c **** 		}
 369:SerialExample.c **** 
 370:SerialExample.c **** 		for(channel=0; channel<SERVO_NUM_CHANNELS; channel++)
 371:SerialExample.c **** 		{
 372:SerialExample.c **** 			for(pos=SERVO_POSITION_MAX; pos>=1; pos--)
 373:SerialExample.c **** 			{
 374:SerialExample.c **** 				servoSetPosition(channel,pos);
 375:SerialExample.c **** 				AvrXDelay(&timer3, 1000);;
 376:SerialExample.c **** 			}
 377:SerialExample.c **** 		}
 378:SerialExample.c **** 	}
 379:SerialExample.c **** }
 380:SerialExample.c **** */
 381:SerialExample.c **** //#endif // USART_CHANNELS & CHANNEL_0
 382:SerialExample.c **** 
 383:SerialExample.c **** int main(void)
 384:SerialExample.c **** {
 3649               	.LM341:
 3650               	/* prologue: frame size=0 */
 3651 0ecc C0E0      		ldi r28,lo8(__stack - 0)
 3652 0ece D0E0      		ldi r29,hi8(__stack - 0)
 3653 0ed0 DEBF      		out __SP_H__,r29
 3654 0ed2 CDBF      		out __SP_L__,r28
 3655               	/* prologue end (size=4) */
 385:SerialExample.c ****     AvrXSetKernelStack(0);
 3657               	.LM342:
 3658 0ed4 80E0      		ldi r24,lo8(0)
 3659 0ed6 90E0      		ldi r25,hi8(0)
 3660 0ed8 0E94 0000 		call AvrXSetKernelStack
 386:SerialExample.c **** 
 387:SerialExample.c **** 	MCUCR = _BV(SE);
 3662               	.LM343:
 3663 0edc 80E8      		ldi r24,lo8(-128)
 3664 0ede 85BF      		out 85-0x20,r24
 388:SerialExample.c **** 	TCNT0 = TCNT0_INIT;
 3666               	.LM344:
 3667 0ee0 81EC      		ldi r24,lo8(-63)
 3668 0ee2 82BF      		out 82-0x20,r24
 389:SerialExample.c **** #if defined (__AVR_ATmega103__) || defined (__ATmega103__)
 390:SerialExample.c **** 	TCCR0 =  ((1<<CS02) | (1<<CS01));
 391:SerialExample.c **** #elif defined (__AVR_ATmega128__) || defined (__ATmega128__) || defined (__AVR_ATmega64__) || defin
 392:SerialExample.c **** 	TCCR0 =  ((1<<CS2) | (1<<CS1));
 393:SerialExample.c **** #else	// Most other chips...  Note: some are TCCR0 and some are TCCR0B...
 394:SerialExample.c **** 	TCCR0 =  (1<<CS02);
 3670               	.LM345:
 3671 0ee4 84E0      		ldi r24,lo8(4)
 3672 0ee6 83BF      		out 83-0x20,r24
 395:SerialExample.c **** #endif
 396:SerialExample.c **** 	TIMSK = _BV(TOIE0);
 3674               	.LM346:
 3675 0ee8 11E0      		ldi r17,lo8(1)
 3676 0eea 19BF      		out 89-0x20,r17
 397:SerialExample.c **** 
 398:SerialExample.c ****     InitSerial0(BAUD(9600));
 3678               	.LM347:
 3679 0eec 8FEC      		ldi r24,lo8(207)
 3680 0eee 90E0      		ldi r25,hi8(207)
 3681 0ef0 0E94 0000 		call InitSerial0
 399:SerialExample.c ****     fdevopen(put_char0, get_c0,0);		// Set up standard I/O
 3683               	.LM348:
 3684 0ef4 40E0      		ldi r20,lo8(0)
 3685 0ef6 50E0      		ldi r21,hi8(0)
 3686 0ef8 60E0      		ldi r22,lo8(pm(get_c0))
 3687 0efa 70E0      		ldi r23,hi8(pm(get_c0))
 3688 0efc 80E0      		ldi r24,lo8(pm(put_char0))
 3689 0efe 90E0      		ldi r25,hi8(pm(put_char0))
 3690 0f00 0E94 0000 		call fdevopen
 400:SerialExample.c **** 
 401:SerialExample.c **** 	// initialize parser system
 402:SerialExample.c **** 	parserInit();
 3692               	.LM349:
 3693 0f04 0E94 0000 		call parserInit
 403:SerialExample.c **** 	// direct output to uart (serial port)
 404:SerialExample.c **** 	parserSetOutputFunc(put_char0);
 3695               	.LM350:
 3696 0f08 80E0      		ldi r24,lo8(pm(put_char0))
 3697 0f0a 90E0      		ldi r25,hi8(pm(put_char0))
 3698 0f0c 0E94 0000 		call parserSetOutputFunc
 405:SerialExample.c **** 	// add commands to the command database
 406:SerialExample.c **** 	parserAddCommand("l",		setLeftServo);
 3700               	.LM351:
 3701 0f10 60E0      		ldi r22,lo8(pm(setLeftServo))
 3702 0f12 70E0      		ldi r23,hi8(pm(setLeftServo))
 3703 0f14 80E0      		ldi r24,lo8(.LC0)
 3704 0f16 90E0      		ldi r25,hi8(.LC0)
 3705 0f18 0E94 0000 		call parserAddCommand
 407:SerialExample.c **** 	parserAddCommand("r",		setRightServo);
 3707               	.LM352:
 3708 0f1c 60E0      		ldi r22,lo8(pm(setRightServo))
 3709 0f1e 70E0      		ldi r23,hi8(pm(setRightServo))
 3710 0f20 80E0      		ldi r24,lo8(.LC1)
 3711 0f22 90E0      		ldi r25,hi8(.LC1)
 3712 0f24 0E94 0000 		call parserAddCommand
 408:SerialExample.c ****     parserAddCommand("t", 		setThrottleServo);
 3714               	.LM353:
 3715 0f28 60E0      		ldi r22,lo8(pm(setThrottleServo))
 3716 0f2a 70E0      		ldi r23,hi8(pm(setThrottleServo))
 3717 0f2c 80E0      		ldi r24,lo8(.LC2)
 3718 0f2e 90E0      		ldi r25,hi8(.LC2)
 3719 0f30 0E94 0000 		call parserAddCommand
 409:SerialExample.c **** 	parserAddCommand("p", 		setCamPanServo);
 3721               	.LM354:
 3722 0f34 60E0      		ldi r22,lo8(pm(setCamPanServo))
 3723 0f36 70E0      		ldi r23,hi8(pm(setCamPanServo))
 3724 0f38 80E0      		ldi r24,lo8(.LC3)
 3725 0f3a 90E0      		ldi r25,hi8(.LC3)
 3726 0f3c 0E94 0000 		call parserAddCommand
 410:SerialExample.c **** 	parserAddCommand("i", 		setCamTiltServo);
 3728               	.LM355:
 3729 0f40 60E0      		ldi r22,lo8(pm(setCamTiltServo))
 3730 0f42 70E0      		ldi r23,hi8(pm(setCamTiltServo))
 3731 0f44 80E0      		ldi r24,lo8(.LC4)
 3732 0f46 90E0      		ldi r25,hi8(.LC4)
 3733 0f48 0E94 0000 		call parserAddCommand
 411:SerialExample.c **** 	
 412:SerialExample.c **** 	// initialize the timer system -- FROM AVRLIB
 413:SerialExample.c **** 	//timerInit();
 414:SerialExample.c **** 	
 415:SerialExample.c **** 	//////////////////////////////////////////////////Servos//////////////////////////
 416:SerialExample.c **** 	servoInit();
 3735               	.LM356:
 3736 0f4c 0E94 0000 		call servoInit
 417:SerialExample.c **** 	// setup servo output channel-to-I/Opin mapping
 418:SerialExample.c **** 	// format is servoSetChannelIO( CHANNEL#, PORT, PIN );
 419:SerialExample.c **** 	servoSetChannelIO(0, _SFR_IO_ADDR(PORTC), PC0);
 3738               	.LM357:
 3739 0f50 40E0      		ldi r20,lo8(0)
 3740 0f52 65E1      		ldi r22,lo8(21)
 3741 0f54 842F      		mov r24,r20
 3742 0f56 0E94 0000 		call servoSetChannelIO
 420:SerialExample.c **** 	servoSetChannelIO(1, _SFR_IO_ADDR(PORTC), PC1);
 3744               	.LM358:
 3745 0f5a 412F      		mov r20,r17
 3746 0f5c 65E1      		ldi r22,lo8(21)
 3747 0f5e 812F      		mov r24,r17
 3748 0f60 0E94 0000 		call servoSetChannelIO
 421:SerialExample.c **** 
 422:SerialExample.c **** 	// set port pins to output
 423:SerialExample.c **** 	outb(DDRC, 0x03);
 3750               	.LM359:
 3751 0f64 83E0      		ldi r24,lo8(3)
 3752 0f66 84BB      		out 52-0x20,r24
 424:SerialExample.c **** 
 425:SerialExample.c **** 	
 426:SerialExample.c **** 	#define SPEED_SERVO	1
 427:SerialExample.c **** 	//////////////////////////////////////////////////////////////////////////////////
 428:SerialExample.c **** 	
 429:SerialExample.c **** 	AvrXRunTask(TCB(getCommands));
 3754               	.LM360:
 3755 0f68 80E0      		ldi r24,lo8(getCommandsTcb)
 3756 0f6a 90E0      		ldi r25,hi8(getCommandsTcb)
 3757 0f6c 0E94 0000 		call AvrXRunTask
 430:SerialExample.c **** //	AvrXRunTask(TCB(marktribe));
 431:SerialExample.c **** 	AvrXRunTask(TCB(getUAVStatus));
 3759               	.LM361:
 3760 0f70 80E0      		ldi r24,lo8(getUAVStatusTcb)
 3761 0f72 90E0      		ldi r25,hi8(getUAVStatusTcb)
 3762 0f74 0E94 0000 		call AvrXRunTask
 432:SerialExample.c **** 	AvrXRunTask(TCB(getAirspeed));
 3764               	.LM362:
 3765 0f78 80E0      		ldi r24,lo8(getAirspeedTcb)
 3766 0f7a 90E0      		ldi r25,hi8(getAirspeedTcb)
 3767 0f7c 0E94 0000 		call AvrXRunTask
 433:SerialExample.c **** 	AvrXRunTask(TCB(getGroundspeed));
 3769               	.LM363:
 3770 0f80 80E0      		ldi r24,lo8(getGroundspeedTcb)
 3771 0f82 90E0      		ldi r25,hi8(getGroundspeedTcb)
 3772 0f84 0E94 0000 		call AvrXRunTask
 434:SerialExample.c **** 	AvrXRunTask(TCB(getCompassHeading));
 3774               	.LM364:
 3775 0f88 80E0      		ldi r24,lo8(getCompassHeadingTcb)
 3776 0f8a 90E0      		ldi r25,hi8(getCompassHeadingTcb)
 3777 0f8c 0E94 0000 		call AvrXRunTask
 435:SerialExample.c **** 	AvrXRunTask(TCB(getGPSData));
 3779               	.LM365:
 3780 0f90 80E0      		ldi r24,lo8(getGPSDataTcb)
 3781 0f92 90E0      		ldi r25,hi8(getGPSDataTcb)
 3782 0f94 0E94 0000 		call AvrXRunTask
 436:SerialExample.c **** 	AvrXRunTask(TCB(getPitchAndRoll));
 3784               	.LM366:
 3785 0f98 80E0      		ldi r24,lo8(getPitchAndRollTcb)
 3786 0f9a 90E0      		ldi r25,hi8(getPitchAndRollTcb)
 3787 0f9c 0E94 0000 		call AvrXRunTask
 437:SerialExample.c **** 	AvrXRunTask(TCB(getFuelAndBattery));
 3789               	.LM367:
 3790 0fa0 80E0      		ldi r24,lo8(getFuelAndBatteryTcb)
 3791 0fa2 90E0      		ldi r25,hi8(getFuelAndBatteryTcb)
 3792 0fa4 0E94 0000 		call AvrXRunTask
 438:SerialExample.c **** 	//AvrXRunTask(TCB(servos));
 439:SerialExample.c ****     
 440:SerialExample.c **** 	Epilog();
 3794               	.LM368:
 3795 0fa8 0E94 0000 		call Epilog
 441:SerialExample.c **** 	return(0);
 442:SerialExample.c **** }
 3797               	.LM369:
 3798 0fac 80E0      		ldi r24,lo8(0)
 3799 0fae 90E0      		ldi r25,hi8(0)
 3800               	/* epilogue: frame size=0 */
 3801 0fb0 0C94 0000 		jmp exit
 3802               	/* epilogue end (size=2) */
 3803               	/* function main size 116 (110) */
 3805               	.Lscope61:
 3808               	.global	setLeftServo
 3810               	setLeftServo:
 443:SerialExample.c **** 
 444:SerialExample.c **** void setLeftServo(void)
 445:SerialExample.c **** {	
 3812               	.LM370:
 3813               	/* prologue: frame size=0 */
 3814               	/* prologue end (size=0) */
 446:SerialExample.c **** 	leftServoPos = parserGetArgInt();
 3816               	.LM371:
 3817 0fb4 0E94 0000 		call parserGetArgInt
 3818 0fb8 9093 0000 		sts (leftServoPos)+1,r25
 3819 0fbc 8093 0000 		sts leftServoPos,r24
 447:SerialExample.c **** 	servoSetPosition(LEFT_SERVO_CHAN, (char)leftServoPos);
 3821               	.LM372:
 3822 0fc0 6091 0000 		lds r22,leftServoPos
 3823 0fc4 80E0      		ldi r24,lo8(0)
 3824 0fc6 0E94 0000 		call servoSetPosition
 3825               	/* epilogue: frame size=0 */
 3826 0fca 0895      		ret
 3827               	/* epilogue end (size=1) */
 3828               	/* function setLeftServo size 12 (11) */
 3830               	.Lscope62:
 3833               	.global	setRightServo
 3835               	setRightServo:
 448:SerialExample.c **** 	if (DEBUG)
 449:SerialExample.c **** 	{	printf("Left Servo Set: %d", leftServoPos);
 450:SerialExample.c **** 		putchar('\r');
 451:SerialExample.c **** 		putchar('\n');
 452:SerialExample.c **** 	}
 453:SerialExample.c **** }
 454:SerialExample.c **** 
 455:SerialExample.c **** void setRightServo(void)
 456:SerialExample.c **** {	
 3837               	.LM373:
 3838               	/* prologue: frame size=0 */
 3839               	/* prologue end (size=0) */
 457:SerialExample.c **** 	rightServoPos = parserGetArgInt();
 3841               	.LM374:
 3842 0fcc 0E94 0000 		call parserGetArgInt
 3843 0fd0 9093 0000 		sts (rightServoPos)+1,r25
 3844 0fd4 8093 0000 		sts rightServoPos,r24
 458:SerialExample.c **** 	servoSetPosition(RIGHT_SERVO_CHAN, (char)rightServoPos);
 3846               	.LM375:
 3847 0fd8 6091 0000 		lds r22,rightServoPos
 3848 0fdc 81E0      		ldi r24,lo8(1)
 3849 0fde 0E94 0000 		call servoSetPosition
 3850               	/* epilogue: frame size=0 */
 3851 0fe2 0895      		ret
 3852               	/* epilogue end (size=1) */
 3853               	/* function setRightServo size 12 (11) */
 3855               	.Lscope63:
 3858               	.global	setThrottleServo
 3860               	setThrottleServo:
 459:SerialExample.c **** 	if (DEBUG)
 460:SerialExample.c **** 	{	printf("Right Servo Set: %d", rightServoPos);
 461:SerialExample.c **** 		putchar('\r');
 462:SerialExample.c **** 		putchar('\n');
 463:SerialExample.c **** 	}
 464:SerialExample.c **** }
 465:SerialExample.c **** 
 466:SerialExample.c **** void setThrottleServo(void)
 467:SerialExample.c **** {
 3862               	.LM376:
 3863               	/* prologue: frame size=0 */
 3864               	/* prologue end (size=0) */
 468:SerialExample.c **** 	throttleServoPos = parserGetArgInt();
 3866               	.LM377:
 3867 0fe4 0E94 0000 		call parserGetArgInt
 3868 0fe8 9093 0000 		sts (throttleServoPos)+1,r25
 3869 0fec 8093 0000 		sts throttleServoPos,r24
 469:SerialExample.c **** 	servoSetPosition(THROTTLE_SERVO_CHAN, (char)throttleServoPos);
 3871               	.LM378:
 3872 0ff0 6091 0000 		lds r22,throttleServoPos
 3873 0ff4 82E0      		ldi r24,lo8(2)
 3874 0ff6 0E94 0000 		call servoSetPosition
 3875               	/* epilogue: frame size=0 */
 3876 0ffa 0895      		ret
 3877               	/* epilogue end (size=1) */
 3878               	/* function setThrottleServo size 12 (11) */
 3880               	.Lscope64:
 3883               	.global	setCamPanServo
 3885               	setCamPanServo:
 470:SerialExample.c **** 	if (DEBUG)
 471:SerialExample.c **** 	{	printf("Throttle Servo Set: %d", throttleServoPos);
 472:SerialExample.c **** 		putchar('\r');
 473:SerialExample.c **** 		putchar('\n');
 474:SerialExample.c **** 	}
 475:SerialExample.c **** }
 476:SerialExample.c **** 
 477:SerialExample.c **** void setCamPanServo(void)
 478:SerialExample.c **** {
 3887               	.LM379:
 3888               	/* prologue: frame size=0 */
 3889               	/* prologue end (size=0) */
 479:SerialExample.c **** 	camPanServoPos = parserGetArgInt();
 3891               	.LM380:
 3892 0ffc 0E94 0000 		call parserGetArgInt
 3893 1000 9093 0000 		sts (camPanServoPos)+1,r25
 3894 1004 8093 0000 		sts camPanServoPos,r24
 480:SerialExample.c **** 	servoSetPosition(CAM_PAN_SERVO_CHAN, (char)camPanServoPos);
 3896               	.LM381:
 3897 1008 6091 0000 		lds r22,camPanServoPos
 3898 100c 83E0      		ldi r24,lo8(3)
 3899 100e 0E94 0000 		call servoSetPosition
 3900               	/* epilogue: frame size=0 */
 3901 1012 0895      		ret
 3902               	/* epilogue end (size=1) */
 3903               	/* function setCamPanServo size 12 (11) */
 3905               	.Lscope65:
 3908               	.global	setCamTiltServo
 3910               	setCamTiltServo:
 481:SerialExample.c **** 	if (DEBUG)
 482:SerialExample.c **** 	{	printf("Camera Pan Servo Set: %d", camPanServoPos);
 483:SerialExample.c **** 		putchar('\r');
 484:SerialExample.c **** 		putchar('\n');
 485:SerialExample.c **** 	}
 486:SerialExample.c **** }
 487:SerialExample.c **** 
 488:SerialExample.c **** void setCamTiltServo(void)
 489:SerialExample.c **** {
 3912               	.LM382:
 3913               	/* prologue: frame size=0 */
 3914               	/* prologue end (size=0) */
 490:SerialExample.c **** 	camTiltServoPos = parserGetArgInt();
 3916               	.LM383:
 3917 1014 0E94 0000 		call parserGetArgInt
 3918 1018 9093 0000 		sts (camTiltServoPos)+1,r25
 3919 101c 8093 0000 		sts camTiltServoPos,r24
 491:SerialExample.c **** 	servoSetPosition(CAM_TILT_SERVO_CHAN, (char)camTiltServoPos);
 3921               	.LM384:
 3922 1020 6091 0000 		lds r22,camTiltServoPos
 3923 1024 84E0      		ldi r24,lo8(4)
 3924 1026 0E94 0000 		call servoSetPosition
 3925               	/* epilogue: frame size=0 */
 3926 102a 0895      		ret
 3927               	/* epilogue end (size=1) */
 3928               	/* function setCamTiltServo size 12 (11) */
 3930               	.Lscope66:
 3932               		.comm CommandList,150,1
 3933               		.comm ParserFunctionList,20,1
 3934               		.comm parserNumCommands,1,1
 3935               		.comm parserBufferLength,1,1
 3936               		.comm parserBuffer,15,1
 3937               		.comm ParserExecFunction,2,1
 3938               		.comm parserOutputFunc,2,1
 3939               		.comm TimerPauseReg,4,1
 3940               		.comm Timer0Reg0,4,1
 3941               		.comm Timer2Reg0,4,1
 3942               		.lcomm TimerIntFunc,16
 3943               		.comm ServoPosTics,2,1
 3944               		.comm ServoPeriodTics,2,1
 3945               		.comm ServoChannel,1,1
 3946               		.comm ServoChannels,8,1
 3947               		.comm rightServoPos,2,1
 3948               		.comm throttleServoPos,2,1
 3949               		.comm camPanServoPos,2,1
 3950               		.comm camTiltServoPos,2,1
 3951               		.comm getUAVStatusStk,111,1
 3952               		.comm getUAVStatusPid,6,1
 3953               		.comm getCompassHeadingStk,111,1
 3954               		.comm getCompassHeadingPid,6,1
 3955               		.comm getAirspeedStk,111,1
 3956               		.comm getAirspeedPid,6,1
 3957               		.comm getGroundspeedStk,111,1
 3958               		.comm getGroundspeedPid,6,1
 3959               		.comm getGPSDataStk,111,1
 3960               		.comm getGPSDataPid,6,1
 3961               		.comm getFuelAndBatteryStk,111,1
 3962               		.comm getFuelAndBatteryPid,6,1
 3963               		.comm getPitchAndRollStk,111,1
 3964               		.comm getPitchAndRollPid,6,1
 3965               		.comm getCommandsStk,135,1
 3966               		.comm getCommandsPid,6,1
 3967               		.comm marktribeStk,105,1
 3968               		.comm marktribePid,6,1
 4018               		.text
 4020               	Letext:
 4021               	/* File "SerialExample.c": code 2096 = 0x0830 (1681), prologues 226, epilogues 189 */
DEFINED SYMBOLS
                            *ABS*:00000000 SerialExample.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
/var/tmp//cchYfHkt.s:149    .progmem.data:00000000 marktribeTcb
                            *COM*:00000069 marktribeStk
/var/tmp//cchYfHkt.s:3563   .text:00000e76 marktribe
                            *COM*:00000006 marktribePid
/var/tmp//cchYfHkt.s:157    .progmem.data:00000007 getCommandsTcb
                            *COM*:00000087 getCommandsStk
/var/tmp//cchYfHkt.s:3498   .text:00000e32 getCommands
                            *COM*:00000006 getCommandsPid
/var/tmp//cchYfHkt.s:165    .progmem.data:0000000e getPitchAndRollTcb
                            *COM*:0000006f getPitchAndRollStk
/var/tmp//cchYfHkt.s:3325   .text:00000d38 getPitchAndRoll
                            *COM*:00000006 getPitchAndRollPid
/var/tmp//cchYfHkt.s:173    .progmem.data:00000015 getFuelAndBatteryTcb
                            *COM*:0000006f getFuelAndBatteryStk
/var/tmp//cchYfHkt.s:3208   .text:00000cb6 getFuelAndBattery
                            *COM*:00000006 getFuelAndBatteryPid
/var/tmp//cchYfHkt.s:181    .progmem.data:0000001c getGPSDataTcb
                            *COM*:0000006f getGPSDataStk
/var/tmp//cchYfHkt.s:3017   .text:00000ba0 getGPSData
                            *COM*:00000006 getGPSDataPid
/var/tmp//cchYfHkt.s:189    .progmem.data:00000023 getGroundspeedTcb
                            *COM*:0000006f getGroundspeedStk
/var/tmp//cchYfHkt.s:2878   .text:00000b08 getGroundspeed
                            *COM*:00000006 getGroundspeedPid
/var/tmp//cchYfHkt.s:197    .progmem.data:0000002a getAirspeedTcb
                            *COM*:0000006f getAirspeedStk
/var/tmp//cchYfHkt.s:2755   .text:00000a70 getAirspeed
                            *COM*:00000006 getAirspeedPid
/var/tmp//cchYfHkt.s:205    .progmem.data:00000031 getCompassHeadingTcb
                            *COM*:0000006f getCompassHeadingStk
/var/tmp//cchYfHkt.s:2621   .text:000009c0 getCompassHeading
                            *COM*:00000006 getCompassHeadingPid
/var/tmp//cchYfHkt.s:213    .progmem.data:00000038 getUAVStatusTcb
                            *COM*:0000006f getUAVStatusStk
/var/tmp//cchYfHkt.s:2556   .text:0000097e getUAVStatus
                            *COM*:00000006 getUAVStatusPid
/var/tmp//cchYfHkt.s:222    .data:00000000 leftServoPos
/var/tmp//cchYfHkt.s:228    .progmem.data:0000003f TimerRTCPrescaleFactor
/var/tmp//cchYfHkt.s:240    .progmem.data:0000004f TimerPrescaleFactor
/var/tmp//cchYfHkt.s:251    .text:00000000 parserInit
                            *COM*:00000001 parserBufferLength
                            *COM*:00000002 ParserExecFunction
                            *COM*:00000001 parserNumCommands
/var/tmp//cchYfHkt.s:280    .text:00000012 parserAddCommand
                            *COM*:00000096 CommandList
                            *COM*:00000014 ParserFunctionList
/var/tmp//cchYfHkt.s:328    .text:00000050 parserSetOutputFunc
                            *COM*:00000002 parserOutputFunc
/var/tmp//cchYfHkt.s:347    .text:0000005a parserProcessInputString
                            *COM*:0000000f parserBuffer
/var/tmp//cchYfHkt.s:426    .text:000000c4 parserInputFunc
/var/tmp//cchYfHkt.s:473    .text:000000f2 parserGetArgStr
/var/tmp//cchYfHkt.s:492    .text:000000f8 parserGetArgInt
/var/tmp//cchYfHkt.s:512    .text:00000102 delay_us
/var/tmp//cchYfHkt.s:559    .text:0000012a timerDetach
                             .bss:00000000 TimerIntFunc
/var/tmp//cchYfHkt.s:591    .text:00000140 timer0SetPrescaler
/var/tmp//cchYfHkt.s:612    .text:0000014a timer0ClearOverflowCount
                            *COM*:00000004 Timer0Reg0
/var/tmp//cchYfHkt.s:633    .text:0000015c timer0Init
/var/tmp//cchYfHkt.s:664    .text:00000170 timer1SetPrescaler
/var/tmp//cchYfHkt.s:685    .text:0000017a timer1Init
/var/tmp//cchYfHkt.s:716    .text:0000018c timer2SetPrescaler
/var/tmp//cchYfHkt.s:737    .text:00000196 timer2ClearOverflowCount
                            *COM*:00000004 Timer2Reg0
/var/tmp//cchYfHkt.s:758    .text:000001a8 timer2Init
/var/tmp//cchYfHkt.s:788    .text:000001bc timerInit
/var/tmp//cchYfHkt.s:835    .text:000001de timer0GetPrescaler
/var/tmp//cchYfHkt.s:873    .text:000001f6 timer1GetPrescaler
/var/tmp//cchYfHkt.s:911    .text:0000020e timer2GetPrescaler
/var/tmp//cchYfHkt.s:951    .text:00000226 timerAttach
/var/tmp//cchYfHkt.s:983    .text:0000023c timerPause
                            *COM*:00000004 TimerPauseReg
/var/tmp//cchYfHkt.s:1166   .text:00000376 timer0GetOverflowCount
/var/tmp//cchYfHkt.s:1191   .text:0000038c timer2GetOverflowCount
/var/tmp//cchYfHkt.s:1217   .text:000003a2 timer1PWMInit
/var/tmp//cchYfHkt.s:1282   .text:000003d2 timer1PWMInitICR
/var/tmp//cchYfHkt.s:1330   .text:000003fa timer1PWMAOff
/var/tmp//cchYfHkt.s:1355   .text:00000408 timer1PWMBOff
/var/tmp//cchYfHkt.s:1380   .text:00000416 timer1PWMOff
/var/tmp//cchYfHkt.s:1411   .text:0000042c timer1PWMAOn
/var/tmp//cchYfHkt.s:1436   .text:0000043a timer1PWMBOn
/var/tmp//cchYfHkt.s:1462   .text:00000448 timer1PWMASet
/var/tmp//cchYfHkt.s:1482   .text:0000044e timer1PWMBSet
/var/tmp//cchYfHkt.s:1501   .text:00000454 __vector_9
/var/tmp//cchYfHkt.s:1561   .text:000004ae __vector_5
/var/tmp//cchYfHkt.s:1634   .text:0000052e __vector_10
/var/tmp//cchYfHkt.s:1694   .text:00000588 __vector_7
/var/tmp//cchYfHkt.s:1754   .text:000005e2 __vector_8
/var/tmp//cchYfHkt.s:1814   .text:0000063c __vector_6
/var/tmp//cchYfHkt.s:1874   .text:00000696 __vector_4
/var/tmp//cchYfHkt.s:1934   .text:000006f0 servoInit
/var/tmp//cchYfHkt.s:2260   .text:00000836 servoService
                            *COM*:00000008 ServoChannels
                            *COM*:00000002 ServoPosTics
                            *COM*:00000002 ServoPeriodTics
/var/tmp//cchYfHkt.s:2044   .text:00000772 servoOff
/var/tmp//cchYfHkt.s:2071   .text:00000780 servoSetChannelIO
/var/tmp//cchYfHkt.s:2113   .text:000007ac servoSetPositionRaw
/var/tmp//cchYfHkt.s:2160   .text:000007d6 servoSetPosition
/var/tmp//cchYfHkt.s:2193   .text:000007f6 servoGetPositionRaw
/var/tmp//cchYfHkt.s:2223   .text:0000080c servoGetPosition
                            *COM*:00000001 ServoChannel
/var/tmp//cchYfHkt.s:2406   .text:00000914 __vector_11
/var/tmp//cchYfHkt.s:2440   .text:00000926 myputs
/var/tmp//cchYfHkt.s:2482   .text:0000094e myputs_P
/var/tmp//cchYfHkt.s:2550   .progmem.data:0000005b __c.20
/var/tmp//cchYfHkt.s:2611   .progmem.data:0000005d __c.18
/var/tmp//cchYfHkt.s:2615   .progmem.data:00000062 __c.19
/var/tmp//cchYfHkt.s:2745   .progmem.data:00000067 __c.16
/var/tmp//cchYfHkt.s:2749   .progmem.data:0000006c __c.17
/var/tmp//cchYfHkt.s:2868   .progmem.data:00000071 __c.14
/var/tmp//cchYfHkt.s:2872   .progmem.data:00000076 __c.15
/var/tmp//cchYfHkt.s:2991   .progmem.data:0000007b __c.8
/var/tmp//cchYfHkt.s:2995   .progmem.data:00000087 __c.9
/var/tmp//cchYfHkt.s:2999   .progmem.data:00000093 __c.10
/var/tmp//cchYfHkt.s:3003   .progmem.data:00000098 __c.11
/var/tmp//cchYfHkt.s:3007   .progmem.data:000000a4 __c.12
/var/tmp//cchYfHkt.s:3011   .progmem.data:000000b0 __c.13
/var/tmp//cchYfHkt.s:3198   .progmem.data:000000b5 __c.6
/var/tmp//cchYfHkt.s:3202   .progmem.data:000000ba __c.7
/var/tmp//cchYfHkt.s:3307   .progmem.data:000000bf __c.2
/var/tmp//cchYfHkt.s:3311   .progmem.data:000000c4 __c.3
/var/tmp//cchYfHkt.s:3315   .progmem.data:000000c9 __c.4
/var/tmp//cchYfHkt.s:3319   .progmem.data:000000ce __c.5
/var/tmp//cchYfHkt.s:3553   .progmem.data:000000d3 __c.0
/var/tmp//cchYfHkt.s:3557   .progmem.data:000000e8 __c.1
/var/tmp//cchYfHkt.s:3647   .text:00000ecc main
/var/tmp//cchYfHkt.s:3810   .text:00000fb4 setLeftServo
/var/tmp//cchYfHkt.s:3835   .text:00000fcc setRightServo
/var/tmp//cchYfHkt.s:3860   .text:00000fe4 setThrottleServo
/var/tmp//cchYfHkt.s:3885   .text:00000ffc setCamPanServo
/var/tmp//cchYfHkt.s:3910   .text:00001014 setCamTiltServo
                            *COM*:00000002 rightServoPos
                            *COM*:00000002 throttleServoPos
                            *COM*:00000002 camPanServoPos
                            *COM*:00000002 camTiltServoPos
/var/tmp//cchYfHkt.s:4020   .text:0000102c Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
strcpy
atoi
__udivmodhi4
__divmodsi4
__mulsi3
__udivmodsi4
IntProlog
AvrXTimerHandler
Epilog
printf_P
__iob
fputc
AvrXDelay
__divmodhi4
fgetc
__stack
AvrXSetKernelStack
InitSerial0
get_c0
put_char0
fdevopen
AvrXRunTask
exit
