   1               		.file	"AvrXBufferedSerial.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
  84               	.global	Tx0Buf
  85               		.data
  88               	Tx0Buf:
  89 0000 0000      		.word	Tx0BufFifo
  90               	.global	Rx0Buf
  93               	Rx0Buf:
  94 0002 0000      		.word	Rx0BufFifo
  95               		.text
  98               	.global	InitSerial0
 100               	InitSerial0:
   1:AvrXBufferedSerial.c **** /*
   2:AvrXBufferedSerial.c **** 	AvrXBufferedSerial.c
   3:AvrXBufferedSerial.c **** 
   4:AvrXBufferedSerial.c **** 	Sample code for fully buffered interrupt driven serial I/O for the
   5:AvrXBufferedSerial.c **** 	AVR processor.  Uses the AvrXFifo facility.
   6:AvrXBufferedSerial.c **** 
   7:AvrXBufferedSerial.c **** 	Author: Larry Barello (larry@barello.net)
   8:AvrXBufferedSerial.c **** 
   9:AvrXBufferedSerial.c **** 	Revision History:
  10:AvrXBufferedSerial.c **** 	09-13-2005	- Initial version
  11:AvrXBufferedSerial.c **** 
  12:AvrXBufferedSerial.c **** */
  13:AvrXBufferedSerial.c **** 
  14:AvrXBufferedSerial.c **** //------------------------------------------------------------------------------
  15:AvrXBufferedSerial.c **** #include <avr/io.h>
  16:AvrXBufferedSerial.c **** #include <avr/interrupt.h>
  17:AvrXBufferedSerial.c **** #define _AVRXSERIALIO_C_
  18:AvrXBufferedSerial.c **** #include "AvrXSerialIo.h"
  19:AvrXBufferedSerial.c **** 
  20:AvrXBufferedSerial.c **** #if USART_CHANNELS & CHANNEL_0
  21:AvrXBufferedSerial.c **** 
  22:AvrXBufferedSerial.c **** AVRX_DECL_FIFO(Rx0Buf, RX0_BUFSZ);
  23:AvrXBufferedSerial.c **** AVRX_DECL_FIFO(Tx0Buf, TX0_BUFSZ);
  24:AvrXBufferedSerial.c **** 
  25:AvrXBufferedSerial.c **** void InitSerial0(uint16_t ubrr)
  26:AvrXBufferedSerial.c **** {
 102               	.LM1:
 103               	/* prologue: frame size=0 */
 104               	/* prologue end (size=0) */
  27:AvrXBufferedSerial.c **** 
  28:AvrXBufferedSerial.c **** // One USART, (C register shared)
  29:AvrXBufferedSerial.c **** #if defined(__AVR_ATmega8__)   | defined(__AVR_ATmega16__)  | defined(__AVR_ATmega32__)  | \
  30:AvrXBufferedSerial.c **** 	  defined(__AVR_ATmega323__) | defined(__AVR_ATmega8515__)| defined(__AVR_ATmega8535__)
  31:AvrXBufferedSerial.c **** 	UBRRL = ubrr;
 106               	.LM2:
 107 0000 89B9      		out 41-0x20,r24
  32:AvrXBufferedSerial.c **** 	UBRRH = (uint8_t)(ubrr>>8);
 109               	.LM3:
 110 0002 892F      		mov r24,r25
 111 0004 9927      		clr r25
 112 0006 80BD      		out 64-0x20,r24
  33:AvrXBufferedSerial.c **** 	UCSRA = (BAUDX == 8)?(1<<U2X):0;
 114               	.LM4:
 115 0008 82E0      		ldi r24,lo8(2)
 116 000a 8BB9      		out 43-0x20,r24
  34:AvrXBufferedSerial.c **** 	UCSRB = ((1<<TXEN) | (1<<RXEN) | (1<<RXCIE));
 118               	.LM5:
 119 000c 88E9      		ldi r24,lo8(-104)
 120 000e 8AB9      		out 42-0x20,r24
  35:AvrXBufferedSerial.c **** 	UCSRC = ((1<<URSEL) | (1<<UCSZ1) | (1<<UCSZ0));
 122               	.LM6:
 123 0010 86E8      		ldi r24,lo8(-122)
 124 0012 80BD      		out 64-0x20,r24
  36:AvrXBufferedSerial.c **** #else
  37:AvrXBufferedSerial.c **** #   ERROR Dont know about that CPU!
  38:AvrXBufferedSerial.c **** #endif
  39:AvrXBufferedSerial.c **** #ifndef UCSRB
  40:AvrXBufferedSerial.c **** #   define UCSRB UCSR0B
  41:AvrXBufferedSerial.c **** #endif
  42:AvrXBufferedSerial.c **** #ifndef UDR
  43:AvrXBufferedSerial.c **** #	define UDR UDR0
  44:AvrXBufferedSerial.c **** #endif
  45:AvrXBufferedSerial.c **** 	AVRX_INIT_FIFO(Rx0Buf);
 126               	.LM7:
 127 0014 80E0      		ldi r24,lo8(Rx0BufFifo)
 128 0016 90E0      		ldi r25,hi8(Rx0BufFifo)
 129 0018 0E94 0000 		call AvrXFlushFifo
 130 001c 84E6      		ldi r24,lo8(100)
 131 001e 8093 0000 		sts Rx0BufFifo+6,r24
  46:AvrXBufferedSerial.c **** 	AVRX_INIT_FIFO(Tx0Buf);
 133               	.LM8:
 134 0022 80E0      		ldi r24,lo8(Tx0BufFifo)
 135 0024 90E0      		ldi r25,hi8(Tx0BufFifo)
 136 0026 0E94 0000 		call AvrXFlushFifo
 137 002a 80E2      		ldi r24,lo8(32)
 138 002c 8093 0000 		sts Tx0BufFifo+6,r24
 139               	/* epilogue: frame size=0 */
 140 0030 0895      		ret
 141               	/* epilogue end (size=1) */
 142               	/* function InitSerial0 size 25 (24) */
 144               	.Lscope0:
 148               	.global	put_c0
 150               	put_c0:
  47:AvrXBufferedSerial.c **** }
  48:AvrXBufferedSerial.c **** 
  49:AvrXBufferedSerial.c **** int put_c0(char c)	// Non blocking output
  50:AvrXBufferedSerial.c **** {
 152               	.LM9:
 153               	/* prologue: frame size=0 */
 154               	/* prologue end (size=0) */
  51:AvrXBufferedSerial.c **** 	int retc;
  52:AvrXBufferedSerial.c **** 	retc = AvrXPutFifo(Tx0Buf, c);
 156               	.LM10:
 157 0032 682F      		mov r22,r24
 158 0034 80E0      		ldi r24,lo8(Tx0BufFifo)
 159 0036 90E0      		ldi r25,hi8(Tx0BufFifo)
 160 0038 0E94 0000 		call AvrXPutFifo
  53:AvrXBufferedSerial.c **** 	UCSRB |= (1<<UDRIE);
 162               	.LM11:
 163 003c 559A      		sbi 42-0x20,5
 164               	/* epilogue: frame size=0 */
 165 003e 0895      		ret
 166               	/* epilogue end (size=1) */
 167               	/* function put_c0 size 7 (6) */
 169               	.Lscope1:
 173               	.global	put_char0
 175               	put_char0:
  54:AvrXBufferedSerial.c **** 	return retc;
  55:AvrXBufferedSerial.c **** }
  56:AvrXBufferedSerial.c **** 
  57:AvrXBufferedSerial.c **** int put_char0( char c)	// Blocking output
  58:AvrXBufferedSerial.c **** {
 177               	.LM12:
 178               	/* prologue: frame size=0 */
 179               	/* prologue end (size=0) */
  59:AvrXBufferedSerial.c **** 	AvrXWaitPutFifo(Tx0Buf, c);
 181               	.LM13:
 182 0040 682F      		mov r22,r24
 183 0042 80E0      		ldi r24,lo8(Tx0BufFifo)
 184 0044 90E0      		ldi r25,hi8(Tx0BufFifo)
 185 0046 0E94 0000 		call AvrXWaitPutFifo
  60:AvrXBufferedSerial.c **** 	UCSRB |= (1<<UDRIE);
 187               	.LM14:
 188 004a 559A      		sbi 42-0x20,5
  61:AvrXBufferedSerial.c **** 	return 0;
  62:AvrXBufferedSerial.c **** }
 190               	.LM15:
 191 004c 80E0      		ldi r24,lo8(0)
 192 004e 90E0      		ldi r25,hi8(0)
 193               	/* epilogue: frame size=0 */
 194 0050 0895      		ret
 195               	/* epilogue end (size=1) */
 196               	/* function put_char0 size 9 (8) */
 198               	.Lscope2:
 201               	.global	get_c0
 203               	get_c0:
  63:AvrXBufferedSerial.c **** 
  64:AvrXBufferedSerial.c **** 
  65:AvrXBufferedSerial.c **** int get_c0(void)	// Non blocking, return status outside of char range
  66:AvrXBufferedSerial.c **** {
 205               	.LM16:
 206               	/* prologue: frame size=0 */
 207               	/* prologue end (size=0) */
  67:AvrXBufferedSerial.c **** 	int retc = AvrXPullFifo(Rx0Buf);
 209               	.LM17:
 210 0052 80E0      		ldi r24,lo8(Rx0BufFifo)
 211 0054 90E0      		ldi r25,hi8(Rx0BufFifo)
 212 0056 0E94 0000 		call AvrXPullFifo
 213               	/* epilogue: frame size=0 */
 214 005a 0895      		ret
 215               	/* epilogue end (size=1) */
 216               	/* function get_c0 size 5 (4) */
 218               	.Lscope3:
 221               	.global	get_char0
 223               	get_char0:
  68:AvrXBufferedSerial.c **** 	return retc;
  69:AvrXBufferedSerial.c **** }
  70:AvrXBufferedSerial.c **** 
  71:AvrXBufferedSerial.c **** int get_char0(void)	// Blocks waiting for something
  72:AvrXBufferedSerial.c **** {
 225               	.LM18:
 226               	/* prologue: frame size=0 */
 227               	/* prologue end (size=0) */
  73:AvrXBufferedSerial.c **** 	return AvrXWaitPullFifo(Rx0Buf);
 229               	.LM19:
 230 005c 80E0      		ldi r24,lo8(Rx0BufFifo)
 231 005e 90E0      		ldi r25,hi8(Rx0BufFifo)
 232 0060 0E94 0000 		call AvrXWaitPullFifo
 233               	/* epilogue: frame size=0 */
 234 0064 0895      		ret
 235               	/* epilogue end (size=1) */
 236               	/* function get_char0 size 5 (4) */
 238               	.Lscope4:
 241               	.global	__vector_13
 243               	__vector_13:
  74:AvrXBufferedSerial.c **** }
  75:AvrXBufferedSerial.c **** // We don't care if the buffer is full.  Just signal we got one.
  76:AvrXBufferedSerial.c **** // The task may attempt one extra time to get data out of an empyt
  77:AvrXBufferedSerial.c **** // buffer (getc(), but so what.  Eventually it will block waiting
  78:AvrXBufferedSerial.c **** // for another character to be received.
  79:AvrXBufferedSerial.c **** 
  80:AvrXBufferedSerial.c **** #if defined(SIG_UART_RECV) && !defined(SIG_UART0_RECV)
  81:AvrXBufferedSerial.c **** #  define SIG_UART0_RECV SIG_UART_RECV		// This covers old single UART chips
  82:AvrXBufferedSerial.c **** #  define SIG_UART0_DATA SIG_UART_DATA
  83:AvrXBufferedSerial.c **** #endif
  84:AvrXBufferedSerial.c **** 
  85:AvrXBufferedSerial.c **** AVRX_SIGINT(SIG_UART0_RECV)
  86:AvrXBufferedSerial.c **** {
 245               	.LM20:
 246               	/* prologue: frame size=0 */
 247               	/* prologue: naked */
 248               	/* prologue end (size=0) */
  87:AvrXBufferedSerial.c ****     IntProlog();
 250               	.LM21:
 251 0066 0E94 0000 		call IntProlog
  88:AvrXBufferedSerial.c ****     UCSRB &= ~(1<<RXCIE);	// Disable Rx interrupt
 253               	.LM22:
 254 006a 5798      		cbi 42-0x20,7
  89:AvrXBufferedSerial.c ****     sei();					// Allow other interrupt activity to occur
 256               	.LM23:
 257               	/* #APP */
 258 006c 7894      		sei
  90:AvrXBufferedSerial.c **** 	AvrXPutFifo(Rx0Buf, UDR);// This resets the Rx Interrupt
 260               	.LM24:
 261               	/* #NOAPP */
 262 006e 6CB1      		in r22,44-0x20
 263 0070 80E0      		ldi r24,lo8(Rx0BufFifo)
 264 0072 90E0      		ldi r25,hi8(Rx0BufFifo)
 265 0074 0E94 0000 		call AvrXPutFifo
  91:AvrXBufferedSerial.c **** 	UCSRB |= (1<<RXCIE);	// Re-enable.
 267               	.LM25:
 268 0078 579A      		sbi 42-0x20,7
  92:AvrXBufferedSerial.c **** 	Epilog();
 270               	.LM26:
 271 007a 0E94 0000 		call Epilog
 272               	/* epilogue: frame size=0 */
 273               	/* epilogue: naked */
 274               	/* epilogue end (size=0) */
 275               	/* function __vector_13 size 13 (13) */
 277               	.Lscope5:
 280               	.global	__vector_14
 282               	__vector_14:
  93:AvrXBufferedSerial.c **** }
  94:AvrXBufferedSerial.c **** 
  95:AvrXBufferedSerial.c **** AVRX_SIGINT(SIG_UART0_DATA)
  96:AvrXBufferedSerial.c **** {
 284               	.LM27:
 285               	/* prologue: frame size=0 */
 286               	/* prologue: naked */
 287               	/* prologue end (size=0) */
  97:AvrXBufferedSerial.c ****     IntProlog();
 289               	.LM28:
 290 007e 0E94 0000 		call IntProlog
  98:AvrXBufferedSerial.c ****     UCSRB &= ~(1<<UDRIE);			// Disable UDRE interrupt
 292               	.LM29:
 293 0082 5598      		cbi 42-0x20,5
  99:AvrXBufferedSerial.c ****     sei();							// Allow other stuff to happen
 295               	.LM30:
 296               	/* #APP */
 297 0084 7894      		sei
 100:AvrXBufferedSerial.c **** 	int c = AvrXPullFifo(Tx0Buf);	// Return -1 if empty (enables interrupts)
 299               	.LM31:
 300               	/* #NOAPP */
 301 0086 80E0      		ldi r24,lo8(Tx0BufFifo)
 302 0088 90E0      		ldi r25,hi8(Tx0BufFifo)
 303 008a 0E94 0000 		call AvrXPullFifo
 101:AvrXBufferedSerial.c **** 	if (c >= 0)						// Tricky tight code: only checking sign
 305               	.LM32:
 306 008e 97FD      		sbrc r25,7
 307 0090 02C0      		rjmp .L8
 102:AvrXBufferedSerial.c **** 	{
 103:AvrXBufferedSerial.c **** 		UDR = c;
 309               	.LM33:
 310 0092 8CB9      		out 44-0x20,r24
 104:AvrXBufferedSerial.c **** 		UCSRB |= (1<<UDRIE);
 312               	.LM34:
 313 0094 559A      		sbi 42-0x20,5
 314               	.L8:
 105:AvrXBufferedSerial.c **** 	}
 106:AvrXBufferedSerial.c **** 	Epilog();
 316               	.LM35:
 317 0096 0E94 0000 		call Epilog
 318               	/* epilogue: frame size=0 */
 319               	/* epilogue: naked */
 320               	/* epilogue end (size=0) */
 321               	/* function __vector_14 size 15 (15) */
 326               	.Lscope6:
 328               		.comm Rx0BufFifo,107,1
 329               		.comm Tx0BufFifo,39,1
 334               		.text
 336               	Letext:
 337               	/* File "AvrXBufferedSerial.c": code   79 = 0x004f (  74), prologues   0, epilogues   5 */
DEFINED SYMBOLS
                            *ABS*:00000000 AvrXBufferedSerial.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
/var/tmp//ccun8uGl.s:88     .data:00000000 Tx0Buf
                            *COM*:00000027 Tx0BufFifo
/var/tmp//ccun8uGl.s:93     .data:00000002 Rx0Buf
                            *COM*:0000006b Rx0BufFifo
/var/tmp//ccun8uGl.s:100    .text:00000000 InitSerial0
/var/tmp//ccun8uGl.s:150    .text:00000032 put_c0
/var/tmp//ccun8uGl.s:175    .text:00000040 put_char0
/var/tmp//ccun8uGl.s:203    .text:00000052 get_c0
/var/tmp//ccun8uGl.s:223    .text:0000005c get_char0
/var/tmp//ccun8uGl.s:243    .text:00000066 __vector_13
/var/tmp//ccun8uGl.s:282    .text:0000007e __vector_14
/var/tmp//ccun8uGl.s:336    .text:0000009a Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
AvrXFlushFifo
AvrXPutFifo
AvrXWaitPutFifo
AvrXPullFifo
AvrXWaitPullFifo
IntProlog
Epilog
