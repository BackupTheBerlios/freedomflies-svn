   1               		.file	"SerialExample.c"
   2               		.arch atmega32
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
 145               	.global	marktribeTcb
 146               		.section	.progmem.data,"a",@progbits
 149               	marktribeTcb:
 150 0000 0000      		.word	marktribeStk+104
 151 0002 0000      		.word	pm(marktribe)
 152 0004 0000      		.word	marktribePid
 153 0006 03        		.byte	3
 154               	.global	getCommandsTcb
 157               	getCommandsTcb:
 158 0007 0000      		.word	getCommandsStk+134
 159 0009 0000      		.word	pm(getCommands)
 160 000b 0000      		.word	getCommandsPid
 161 000d 05        		.byte	5
 162               	.global	getPitchAndRollTcb
 165               	getPitchAndRollTcb:
 166 000e 0000      		.word	getPitchAndRollStk+110
 167 0010 0000      		.word	pm(getPitchAndRoll)
 168 0012 0000      		.word	getPitchAndRollPid
 169 0014 04        		.byte	4
 170               	.global	getFuelAndBatteryTcb
 173               	getFuelAndBatteryTcb:
 174 0015 0000      		.word	getFuelAndBatteryStk+110
 175 0017 0000      		.word	pm(getFuelAndBattery)
 176 0019 0000      		.word	getFuelAndBatteryPid
 177 001b 04        		.byte	4
 178               	.global	getGPSDataTcb
 181               	getGPSDataTcb:
 182 001c 0000      		.word	getGPSDataStk+110
 183 001e 0000      		.word	pm(getGPSData)
 184 0020 0000      		.word	getGPSDataPid
 185 0022 04        		.byte	4
 186               	.global	getGroundspeedTcb
 189               	getGroundspeedTcb:
 190 0023 0000      		.word	getGroundspeedStk+110
 191 0025 0000      		.word	pm(getGroundspeed)
 192 0027 0000      		.word	getGroundspeedPid
 193 0029 04        		.byte	4
 194               	.global	getAirspeedTcb
 197               	getAirspeedTcb:
 198 002a 0000      		.word	getAirspeedStk+110
 199 002c 0000      		.word	pm(getAirspeed)
 200 002e 0000      		.word	getAirspeedPid
 201 0030 04        		.byte	4
 202               	.global	getCompassHeadingTcb
 205               	getCompassHeadingTcb:
 206 0031 0000      		.word	getCompassHeadingStk+110
 207 0033 0000      		.word	pm(getCompassHeading)
 208 0035 0000      		.word	getCompassHeadingPid
 209 0037 04        		.byte	4
 210               	.global	getUAVStatusTcb
 213               	getUAVStatusTcb:
 214 0038 0000      		.word	getUAVStatusStk+110
 215 003a 0000      		.word	pm(getUAVStatus)
 216 003c 0000      		.word	getUAVStatusPid
 217 003e 04        		.byte	4
 218               	.global	leftServoPos
 219               		.data
 222               	leftServoPos:
 223 0000 3200      		.word	50
 224               	.global	TimerRTCPrescaleFactor
 225               		.section	.progmem.data
 228               	TimerRTCPrescaleFactor:
 229 003f 0000      		.word	0
 230 0041 0100      		.word	1
 231 0043 0800      		.word	8
 232 0045 2000      		.word	32
 233 0047 4000      		.word	64
 234 0049 8000      		.word	128
 235 004b 0001      		.word	256
 236 004d 0004      		.word	1024
 237               	.global	TimerPrescaleFactor
 240               	TimerPrescaleFactor:
 241 004f 0000      		.word	0
 242 0051 0100      		.word	1
 243 0053 0800      		.word	8
 244 0055 4000      		.word	64
 245 0057 0001      		.word	256
 246 0059 0004      		.word	1024
 247               		.text
 249               	.global	parserInit
 251               	parserInit:
 253               	.Ltext1:
   1:parser.c      **** #include <avr/io.h>			// include I/O definitions (port names, pin names, etc)
   2:parser.c      **** #include <avr/interrupt.h>	// include interrupt support
   3:parser.c      **** #include <avr/pgmspace.h>	// include AVR program memory support
   4:parser.c      **** #include <string.h>			// include standard C string functions
   5:parser.c      **** #include <stdlib.h>			// include stdlib for string conversion functions
   6:parser.c      **** 
   7:parser.c      **** 
   8:parser.c      **** #include "parser.h"
   9:parser.c      **** #include "parserconf.h"
  10:parser.c      **** 
  11:parser.c      **** 
  12:parser.c      **** 
  13:parser.c      **** // command list
  14:parser.c      **** char CommandList[MAX_COMMANDS][MAX_CMD_LENGTH];
  15:parser.c      **** // command function pointer list
  16:parser.c      **** ParserFuncPtrType ParserFunctionList[MAX_COMMANDS];
  17:parser.c      **** // number of commands currently registered
  18:parser.c      **** unsigned char parserNumCommands;
  19:parser.c      **** //current length of input buffer
  20:parser.c      **** unsigned char parserBufferLength;
  21:parser.c      **** //buffer into which commands are written as they come through
  22:parser.c      **** unsigned char parserBuffer[BUFFERSIZE];
  23:parser.c      **** 
  24:parser.c      **** ParserFuncPtrType ParserExecFunction;
  25:parser.c      **** 
  26:parser.c      **** // function pointer to single character output routine
  27:parser.c      **** void (*parserOutputFunc)(unsigned char c);
  28:parser.c      **** 
  29:parser.c      **** 
  30:parser.c      **** void parserInit(void)
  31:parser.c      **** {
 255               	.LM1:
 256               	/* prologue: frame size=0 */
 257               	/* prologue end (size=0) */
  32:parser.c      **** 	// initialize input buffer
  33:parser.c      **** 	parserBufferLength = 0;
 259               	.LM2:
 260 0000 1092 0000 		sts parserBufferLength,__zero_reg__
  34:parser.c      **** 	// initialize executing function
  35:parser.c      **** 	ParserExecFunction = 0;
 262               	.LM3:
 263 0004 1092 0000 		sts (ParserExecFunction)+1,__zero_reg__
 264 0008 1092 0000 		sts ParserExecFunction,__zero_reg__
  36:parser.c      **** 	// initialize command list
  37:parser.c      **** 	parserNumCommands = 0;
 266               	.LM4:
 267 000c 1092 0000 		sts parserNumCommands,__zero_reg__
 268               	/* epilogue: frame size=0 */
 269 0010 0895      		ret
 270               	/* epilogue end (size=1) */
 271               	/* function parserInit size 9 (8) */
 273               	.Lscope0:
 278               	.global	parserAddCommand
 280               	parserAddCommand:
  38:parser.c      **** }
  39:parser.c      **** 
  40:parser.c      **** 
  41:parser.c      **** void parserAddCommand(unsigned char* newCmdString, ParserFuncPtrType newCmdFuncPtr)
  42:parser.c      **** {
 282               	.LM5:
 283               	/* prologue: frame size=0 */
 284 0012 0F93      		push r16
 285 0014 1F93      		push r17
 286               	/* prologue end (size=2) */
 287 0016 9C01      		movw r18,r24
 288 0018 8B01      		movw r16,r22
  43:parser.c      **** 	// add command string to end of command list
  44:parser.c      **** 	strcpy(CommandList[parserNumCommands], newCmdString);
 290               	.LM6:
 291 001a 9091 0000 		lds r25,parserNumCommands
 292 001e 8FE0      		ldi r24,lo8(15)
 293 0020 989F      		mul r25,r24
 294 0022 C001      		movw r24,r0
 295 0024 1124      		clr r1
 296 0026 B901      		movw r22,r18
 297 0028 8050      		subi r24,lo8(-(CommandList))
 298 002a 9040      		sbci r25,hi8(-(CommandList))
 299 002c 0E94 0000 		call strcpy
  45:parser.c      **** 	// add command function ptr to end of function list
  46:parser.c      **** 	ParserFunctionList[parserNumCommands] = newCmdFuncPtr;
 301               	.LM7:
 302 0030 8091 0000 		lds r24,parserNumCommands
 303 0034 E82F      		mov r30,r24
 304 0036 FF27      		clr r31
 305 0038 EE0F      		add r30,r30
 306 003a FF1F      		adc r31,r31
 307 003c E050      		subi r30,lo8(-(ParserFunctionList))
 308 003e F040      		sbci r31,hi8(-(ParserFunctionList))
 309 0040 1183      		std Z+1,r17
 310 0042 0083      		st Z,r16
  47:parser.c      **** 	// increment number of registered commands
  48:parser.c      **** 	parserNumCommands++;
 312               	.LM8:
 313 0044 8F5F      		subi r24,lo8(-(1))
 314 0046 8093 0000 		sts parserNumCommands,r24
 315               	/* epilogue: frame size=0 */
 316 004a 1F91      		pop r17
 317 004c 0F91      		pop r16
 318 004e 0895      		ret
 319               	/* epilogue end (size=3) */
 320               	/* function parserAddCommand size 31 (26) */
 322               	.Lscope1:
 326               	.global	parserSetOutputFunc
 328               	parserSetOutputFunc:
  49:parser.c      **** }
  50:parser.c      **** 
  51:parser.c      **** 
  52:parser.c      **** void parserSetOutputFunc(void (*output_func)(unsigned char c))
  53:parser.c      **** {
 330               	.LM9:
 331               	/* prologue: frame size=0 */
 332               	/* prologue end (size=0) */
  54:parser.c      **** 	// set new output function
  55:parser.c      **** 	parserOutputFunc = output_func;
 334               	.LM10:
 335 0050 9093 0000 		sts (parserOutputFunc)+1,r25
 336 0054 8093 0000 		sts parserOutputFunc,r24
 337               	/* epilogue: frame size=0 */
 338 0058 0895      		ret
 339               	/* epilogue end (size=1) */
 340               	/* function parserSetOutputFunc size 5 (4) */
 342               	.Lscope2:
 345               	.global	parserProcessInputString
 347               	parserProcessInputString:
  56:parser.c      **** }
  57:parser.c      **** 
  58:parser.c      **** 
  59:parser.c      **** void parserInputFunc(unsigned char c)
  60:parser.c      **** {
  61:parser.c      **** 	// process the received character
  62:parser.c      **** 	
  63:parser.c      **** 	if (c != '\r')		//anything other than return character must be a part of the command
  64:parser.c      **** 	{	
  65:parser.c      **** 		// echo character to the output
  66:parser.c      **** //		parserOutputFunc(c);
  67:parser.c      **** 		// add it to the command line buffer
  68:parser.c      **** 		parserBuffer[parserBufferLength] = c;
  69:parser.c      **** 		// update buffer length
  70:parser.c      **** 		parserBufferLength++;
  71:parser.c      **** 	}
  72:parser.c      **** 	else				//return character -> process command
  73:parser.c      **** 	{
  74:parser.c      **** 		// add null termination to command
  75:parser.c      **** 		parserBuffer[parserBufferLength] = 0;
  76:parser.c      **** 		// command is complete, process it
  77:parser.c      **** 		parserProcessInputString();
  78:parser.c      **** 		// reset buffer
  79:parser.c      **** 		parserBufferLength = 0;
  80:parser.c      **** 	}
  81:parser.c      **** }
  82:parser.c      **** 
  83:parser.c      **** 
  84:parser.c      **** void parserProcessInputString(void)
  85:parser.c      **** {
 349               	.LM11:
 350               	/* prologue: frame size=0 */
 351 005a 1F93      		push r17
 352 005c CF93      		push r28
 353 005e DF93      		push r29
 354               	/* prologue end (size=3) */
  86:parser.c      **** 	unsigned char cmdIndex;
  87:parser.c      **** 
  88:parser.c      **** 	// search command list for match with entered command
  89:parser.c      **** 	for(cmdIndex=0; cmdIndex<parserNumCommands; cmdIndex++)
 356               	.LM12:
 357 0060 10E0      		ldi r17,lo8(0)
 358 0062 8091 0000 		lds r24,parserNumCommands
 359 0066 1817      		cp r17,r24
 360 0068 48F5      		brsh .L11
 361               	.L9:
  90:parser.c      **** 	{
  91:parser.c      **** 		if( !strncmp(CommandList[cmdIndex], parserBuffer, 1) )		//command is first char of buffer
 363               	.LM13:
 364 006a A12F      		mov r26,r17
 365 006c BB27      		clr r27
 366 006e FD01      		movw r30,r26
 367 0070 84E0      		ldi r24,4
 368 0072 EE0F      	1:	lsl r30
 369 0074 FF1F      		rol r31
 370 0076 8A95      		dec r24
 371 0078 E1F7      		brne 1b
 372 007a EA1B      		sub r30,r26
 373 007c FB0B      		sbc r31,r27
 374 007e E050      		subi r30,lo8(-(CommandList))
 375 0080 F040      		sbci r31,hi8(-(CommandList))
 376 0082 8081      		ld r24,Z
 377 0084 C82F      		mov r28,r24
 378 0086 DD27      		clr r29
 379 0088 8091 0000 		lds r24,parserBuffer
 380 008c C81B      		sub r28,r24
 381 008e D109      		sbc r29,__zero_reg__
 382 0090 2097      		sbiw r28,0
 383 0092 79F4      		brne .L7
  92:parser.c      **** 		{
  93:parser.c      **** 			// user-entered command matched a command in the list (database)
  94:parser.c      **** 			ParserExecFunction = ParserFunctionList[cmdIndex];
 385               	.LM14:
 386 0094 AA0F      		add r26,r26
 387 0096 BB1F      		adc r27,r27
 388 0098 A050      		subi r26,lo8(-(ParserFunctionList))
 389 009a B040      		sbci r27,hi8(-(ParserFunctionList))
 390 009c ED91      		ld r30,X+
 391 009e FC91      		ld r31,X
 392 00a0 F093 0000 		sts (ParserExecFunction)+1,r31
 393 00a4 E093 0000 		sts ParserExecFunction,r30
  95:parser.c      **** 			// run the corresponding function
  96:parser.c      **** 			ParserExecFunction();
 395               	.LM15:
 396 00a8 0995      		icall
  97:parser.c      **** 			// reset
  98:parser.c      **** 			ParserExecFunction = 0;
 398               	.LM16:
 399 00aa D093 0000 		sts (ParserExecFunction)+1,r29
 400 00ae C093 0000 		sts ParserExecFunction,r28
 401               	.L7:
 403               	.LM17:
 404 00b2 1F5F      		subi r17,lo8(-(1))
 405 00b4 8091 0000 		lds r24,parserNumCommands
 406 00b8 1817      		cp r17,r24
 407 00ba B8F2      		brlo .L9
 408               	.L11:
 409               	/* epilogue: frame size=0 */
 410 00bc DF91      		pop r29
 411 00be CF91      		pop r28
 412 00c0 1F91      		pop r17
 413 00c2 0895      		ret
 414               	/* epilogue end (size=4) */
 415               	/* function parserProcessInputString size 53 (46) */
 420               	.Lscope3:
 424               	.global	parserInputFunc
 426               	parserInputFunc:
 428               	.LM18:
 429               	/* prologue: frame size=0 */
 430               	/* prologue end (size=0) */
 431 00c4 9091 0000 		lds r25,parserBufferLength
 433               	.LM19:
 434 00c8 8D30      		cpi r24,lo8(13)
 435 00ca 49F0      		breq .L13
 437               	.LM20:
 438 00cc E92F      		mov r30,r25
 439 00ce FF27      		clr r31
 440 00d0 E050      		subi r30,lo8(-(parserBuffer))
 441 00d2 F040      		sbci r31,hi8(-(parserBuffer))
 442 00d4 8083      		st Z,r24
 444               	.LM21:
 445 00d6 9F5F      		subi r25,lo8(-(1))
 446 00d8 9093 0000 		sts parserBufferLength,r25
 447 00dc 0895      		ret
 448               	.L13:
 450               	.LM22:
 451 00de E92F      		mov r30,r25
 452 00e0 FF27      		clr r31
 453 00e2 E050      		subi r30,lo8(-(parserBuffer))
 454 00e4 F040      		sbci r31,hi8(-(parserBuffer))
 455 00e6 1082      		st Z,__zero_reg__
 457               	.LM23:
 458 00e8 0E94 0000 		call parserProcessInputString
 460               	.LM24:
 461 00ec 1092 0000 		sts parserBufferLength,__zero_reg__
 462 00f0 0895      		ret
 463               	/* epilogue: frame size=0 */
 464               	/* epilogue: noreturn */
 465               	/* epilogue end (size=0) */
 466               	/* function parserInputFunc size 23 (23) */
 468               	.Lscope4:
 471               	.global	parserGetArgStr
 473               	parserGetArgStr:
  99:parser.c      **** 		}
 100:parser.c      **** 	}
 101:parser.c      **** }
 102:parser.c      **** 
 103:parser.c      **** // return string pointer to argument [argnum]
 104:parser.c      **** unsigned char* parserGetArgStr(void)
 105:parser.c      **** {
 475               	.LM25:
 476               	/* prologue: frame size=0 */
 477               	/* prologue end (size=0) */
 106:parser.c      **** 	return &parserBuffer[2];		//spec states that commands are 1 char followed by a space followed by t
 107:parser.c      **** }									//arg must start at idx 2
 479               	.LM26:
 480 00f2 80E0      		ldi r24,lo8(parserBuffer+2)
 481 00f4 90E0      		ldi r25,hi8(parserBuffer+2)
 482               	/* epilogue: frame size=0 */
 483 00f6 0895      		ret
 484               	/* epilogue end (size=1) */
 485               	/* function parserGetArgStr size 3 (2) */
 487               	.Lscope5:
 490               	.global	parserGetArgInt
 492               	parserGetArgInt:
 108:parser.c      **** 
 109:parser.c      **** //return argument as a long
 110:parser.c      **** int parserGetArgInt(void)
 111:parser.c      **** {
 494               	.LM27:
 495               	/* prologue: frame size=0 */
 496               	/* prologue end (size=0) */
 112:parser.c      **** 	char* endptr;
 113:parser.c      **** 	return atoi(parserGetArgStr());
 498               	.LM28:
 499 00f8 0E94 0000 		call parserGetArgStr
 500 00fc 0E94 0000 		call atoi
 501               	/* epilogue: frame size=0 */
 502 0100 0895      		ret
 503               	/* epilogue end (size=1) */
 504               	/* function parserGetArgInt size 5 (4) */
 506               	.Lscope6:
 510               	.global	delay_us
 512               	delay_us:
 514               	.Ltext2:
   1:timer.c       **** /*! \file timer.c \brief System Timer function library. */
   2:timer.c       **** //*****************************************************************************
   3:timer.c       **** //
   4:timer.c       **** // File Name	: 'timer.c'
   5:timer.c       **** // Title		: System Timer function library
   6:timer.c       **** // Author		: Pascal Stang - Copyright (C) 2000-2002
   7:timer.c       **** // Created		: 11/22/2000
   8:timer.c       **** // Revised		: 07/09/2003
   9:timer.c       **** // Version		: 1.1
  10:timer.c       **** // Target MCU	: Atmel AVR Series
  11:timer.c       **** // Editor Tabs	: 4
  12:timer.c       **** //
  13:timer.c       **** // This code is distributed under the GNU Public License
  14:timer.c       **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
  15:timer.c       **** //
  16:timer.c       **** //*****************************************************************************
  17:timer.c       **** 
  18:timer.c       **** #ifndef WIN32
  19:timer.c       **** 	#include <avr/io.h>
  20:timer.c       **** 	#include <avr/signal.h>
  21:timer.c       **** 	#include <avr/interrupt.h>
  22:timer.c       **** 	#include <avr/pgmspace.h>
  23:timer.c       **** 	#include <avr/sleep.h>
  24:timer.c       **** #endif
  25:timer.c       **** 
  26:timer.c       **** #include "global.h"
  27:timer.c       **** #include "timer.h"
  28:timer.c       **** 
  29:timer.c       **** //#include "rprintf.h"
  30:timer.c       **** 
  31:timer.c       **** // Program ROM constants
  32:timer.c       **** // the prescale division values stored in order of timer control register index
  33:timer.c       **** // STOP, CLK, CLK/8, CLK/64, CLK/256, CLK/1024
  34:timer.c       **** unsigned short __attribute__ ((progmem)) TimerPrescaleFactor[] = {0,1,8,64,256,1024};
  35:timer.c       **** // the prescale division values stored in order of timer control register index
  36:timer.c       **** // STOP, CLK, CLK/8, CLK/32, CLK/64, CLK/128, CLK/256, CLK/1024
  37:timer.c       **** unsigned short __attribute__ ((progmem)) TimerRTCPrescaleFactor[] = {0,1,8,32,64,128,256,1024};
  38:timer.c       **** 
  39:timer.c       **** // Global variables
  40:timer.c       **** // time registers
  41:timer.c       **** volatile unsigned long TimerPauseReg;
  42:timer.c       **** volatile unsigned long Timer0Reg0;
  43:timer.c       **** volatile unsigned long Timer2Reg0;
  44:timer.c       **** 
  45:timer.c       **** typedef void (*voidFuncPtr)(void);
  46:timer.c       **** volatile static voidFuncPtr TimerIntFunc[TIMER_NUM_INTERRUPTS];
  47:timer.c       **** 
  48:timer.c       **** // delay for a minimum of <us> microseconds 
  49:timer.c       **** // the time resolution is dependent on the time the loop takes 
  50:timer.c       **** // e.g. with 4Mhz and 5 cycles per loop, the resolution is 1.25 us 
  51:timer.c       **** void delay_us(unsigned short time_us) 
  52:timer.c       **** {
 516               	.LM29:
 517               	/* prologue: frame size=0 */
 518               	/* prologue end (size=0) */
  53:timer.c       **** 	unsigned short delay_loops;
  54:timer.c       **** 	register unsigned short i;
  55:timer.c       **** 
  56:timer.c       **** 	delay_loops = (time_us+3)/5*CYCLES_PER_US; // +3 for rounding up (dirty) 
 520               	.LM30:
 521 0102 0396      		adiw r24,3
 522 0104 65E0      		ldi r22,lo8(5)
 523 0106 70E0      		ldi r23,hi8(5)
 524 0108 0E94 0000 		call __udivmodhi4
 525 010c CB01      		movw r24,r22
 526 010e AA27      		clr r26
 527 0110 BB27      		clr r27
 528 0112 24E0      		ldi r18,4
 529 0114 880F      	1:	lsl r24
 530 0116 991F      		rol r25
 531 0118 AA1F      		rol r26
 532 011a BB1F      		rol r27
 533 011c 2A95      		dec r18
 534 011e D1F7      		brne 1b
 535               	.L24:
  57:timer.c       **** 
  58:timer.c       **** 	// one loop takes 5 cpu cycles 
  59:timer.c       **** 	for (i=0; i < delay_loops; i++) {};
 537               	.LM31:
 538 0120 0097      		sbiw r24,0
 539 0122 11F0      		breq .L23
 540 0124 0197      		sbiw r24,1
 541 0126 FCCF      		rjmp .L24
 542               	.L23:
 543 0128 0895      		ret
 544               	/* epilogue: frame size=0 */
 545               	/* epilogue: noreturn */
 546               	/* epilogue end (size=0) */
 547               	/* function delay_us size 20 (20) */
 553               	.Lscope7:
 557               	.global	timerDetach
 559               	timerDetach:
  60:timer.c       **** }
  61:timer.c       **** /*
  62:timer.c       **** void delay_ms(unsigned char time_ms)
  63:timer.c       **** {
  64:timer.c       **** 	unsigned short delay_count = F_CPU / 4000;
  65:timer.c       **** 
  66:timer.c       **** 	unsigned short cnt;
  67:timer.c       **** 	asm volatile ("\n"
  68:timer.c       ****                   "L_dl1%=:\n\t"
  69:timer.c       ****                   "mov %A0, %A2\n\t"
  70:timer.c       ****                   "mov %B0, %B2\n"
  71:timer.c       ****                   "L_dl2%=:\n\t"
  72:timer.c       ****                   "sbiw %A0, 1\n\t"
  73:timer.c       ****                   "brne L_dl2%=\n\t"
  74:timer.c       ****                   "dec %1\n\t" "brne L_dl1%=\n\t":"=&w" (cnt)
  75:timer.c       ****                   :"r"(time_ms), "r"((unsigned short) (delay_count))
  76:timer.c       **** 	);
  77:timer.c       **** }
  78:timer.c       **** */
  79:timer.c       **** void timerInit(void)
  80:timer.c       **** {
  81:timer.c       **** 	u08 intNum;
  82:timer.c       **** 	// detach all user functions from interrupts
  83:timer.c       **** 	for(intNum=0; intNum<TIMER_NUM_INTERRUPTS; intNum++)
  84:timer.c       **** 		timerDetach(intNum);
  85:timer.c       **** 
  86:timer.c       **** 	// initialize all timers
  87:timer.c       **** 	timer0Init();
  88:timer.c       **** 	timer1Init();
  89:timer.c       **** 	#ifdef TCNT2	// support timer2 only if it exists
  90:timer.c       **** 	timer2Init();
  91:timer.c       **** 	#endif
  92:timer.c       **** 	// enable interrupts
  93:timer.c       **** 	sei();
  94:timer.c       **** }
  95:timer.c       **** 
  96:timer.c       **** void timer0Init()
  97:timer.c       **** {
  98:timer.c       **** 	// initialize timer 0
  99:timer.c       **** 	timer0SetPrescaler( TIMER0PRESCALE );	// set prescaler
 100:timer.c       **** 	outb(TCNT0, 0);							// reset TCNT0
 101:timer.c       **** 	sbi(TIMSK, TOIE0);						// enable TCNT0 overflow interrupt
 102:timer.c       **** 
 103:timer.c       **** 	timer0ClearOverflowCount();				// initialize time registers
 104:timer.c       **** }
 105:timer.c       **** 
 106:timer.c       **** void timer1Init(void)
 107:timer.c       **** {
 108:timer.c       **** 	// initialize timer 1
 109:timer.c       **** 	timer1SetPrescaler( TIMER1PRESCALE );	// set prescaler
 110:timer.c       **** 	outb(TCNT1H, 0);						// reset TCNT1
 111:timer.c       **** 	outb(TCNT1L, 0);
 112:timer.c       **** 	sbi(TIMSK, TOIE1);						// enable TCNT1 overflow
 113:timer.c       **** }
 114:timer.c       **** 
 115:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 116:timer.c       **** void timer2Init(void)
 117:timer.c       **** {
 118:timer.c       **** 	// initialize timer 2
 119:timer.c       **** 	timer2SetPrescaler( TIMER2PRESCALE );	// set prescaler
 120:timer.c       **** 	outb(TCNT2, 0);							// reset TCNT2
 121:timer.c       **** 	sbi(TIMSK, TOIE2);						// enable TCNT2 overflow
 122:timer.c       **** 
 123:timer.c       **** 	timer2ClearOverflowCount();				// initialize time registers
 124:timer.c       **** }
 125:timer.c       **** #endif
 126:timer.c       **** 
 127:timer.c       **** void timer0SetPrescaler(u08 prescale)
 128:timer.c       **** {
 129:timer.c       **** 	// set prescaler on timer 0
 130:timer.c       **** 	outb(TCCR0, (inb(TCCR0) & ~TIMER_PRESCALE_MASK) | prescale);
 131:timer.c       **** }
 132:timer.c       **** 
 133:timer.c       **** void timer1SetPrescaler(u08 prescale)
 134:timer.c       **** {
 135:timer.c       **** 	// set prescaler on timer 1
 136:timer.c       **** 	outb(TCCR1B, (inb(TCCR1B) & ~TIMER_PRESCALE_MASK) | prescale);
 137:timer.c       **** }
 138:timer.c       **** 
 139:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 140:timer.c       **** void timer2SetPrescaler(u08 prescale)
 141:timer.c       **** {
 142:timer.c       **** 	// set prescaler on timer 2
 143:timer.c       **** 	outb(TCCR2, (inb(TCCR2) & ~TIMER_PRESCALE_MASK) | prescale);
 144:timer.c       **** }
 145:timer.c       **** #endif
 146:timer.c       **** 
 147:timer.c       **** u16 timer0GetPrescaler(void)
 148:timer.c       **** {
 149:timer.c       **** 	// get the current prescaler setting
 150:timer.c       **** 	return (pgm_read_word(TimerPrescaleFactor+(inb(TCCR0) & TIMER_PRESCALE_MASK)));
 151:timer.c       **** }
 152:timer.c       **** 
 153:timer.c       **** u16 timer1GetPrescaler(void)
 154:timer.c       **** {
 155:timer.c       **** 	// get the current prescaler setting
 156:timer.c       **** 	return (pgm_read_word(TimerPrescaleFactor+(inb(TCCR1B) & TIMER_PRESCALE_MASK)));
 157:timer.c       **** }
 158:timer.c       **** 
 159:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 160:timer.c       **** u16 timer2GetPrescaler(void)
 161:timer.c       **** {
 162:timer.c       **** 	//TODO: can we assume for all 3-timer AVR processors,
 163:timer.c       **** 	// that timer2 is the RTC timer?
 164:timer.c       **** 
 165:timer.c       **** 	// get the current prescaler setting
 166:timer.c       **** 	return (pgm_read_word(TimerRTCPrescaleFactor+(inb(TCCR2) & TIMER_PRESCALE_MASK)));
 167:timer.c       **** }
 168:timer.c       **** #endif
 169:timer.c       **** 
 170:timer.c       **** void timerAttach(u08 interruptNum, void (*userFunc)(void) )
 171:timer.c       **** {
 172:timer.c       **** 	// make sure the interrupt number is within bounds
 173:timer.c       **** 	if(interruptNum < TIMER_NUM_INTERRUPTS)
 174:timer.c       **** 	{
 175:timer.c       **** 		// set the interrupt function to run
 176:timer.c       **** 		// the supplied user's function
 177:timer.c       **** 		TimerIntFunc[interruptNum] = userFunc;
 178:timer.c       **** 	}
 179:timer.c       **** }
 180:timer.c       **** 
 181:timer.c       **** void timerDetach(u08 interruptNum)
 182:timer.c       **** {
 561               	.LM32:
 562               	/* prologue: frame size=0 */
 563               	/* prologue end (size=0) */
 183:timer.c       **** 	// make sure the interrupt number is within bounds
 184:timer.c       **** 	if(interruptNum < TIMER_NUM_INTERRUPTS)
 565               	.LM33:
 566 012a 8830      		cpi r24,lo8(8)
 567 012c 40F4      		brsh .L25
 185:timer.c       **** 	{
 186:timer.c       **** 		// set the interrupt function to run nothing
 187:timer.c       **** 		TimerIntFunc[interruptNum] = 0;
 569               	.LM34:
 570 012e E82F      		mov r30,r24
 571 0130 FF27      		clr r31
 572 0132 EE0F      		add r30,r30
 573 0134 FF1F      		adc r31,r31
 574 0136 E050      		subi r30,lo8(-(TimerIntFunc))
 575 0138 F040      		sbci r31,hi8(-(TimerIntFunc))
 576 013a 1182      		std Z+1,__zero_reg__
 577 013c 1082      		st Z,__zero_reg__
 578               	.L25:
 579 013e 0895      		ret
 580               	/* epilogue: frame size=0 */
 581               	/* epilogue: noreturn */
 582               	/* epilogue end (size=0) */
 583               	/* function timerDetach size 11 (11) */
 585               	.Lscope8:
 589               	.global	timer0SetPrescaler
 591               	timer0SetPrescaler:
 593               	.LM35:
 594               	/* prologue: frame size=0 */
 595               	/* prologue end (size=0) */
 597               	.LM36:
 598 0140 93B7      		in r25,83-0x20
 599 0142 987F      		andi r25,lo8(-8)
 600 0144 982B      		or r25,r24
 601 0146 93BF      		out 83-0x20,r25
 602               	/* epilogue: frame size=0 */
 603 0148 0895      		ret
 604               	/* epilogue end (size=1) */
 605               	/* function timer0SetPrescaler size 5 (4) */
 607               	.Lscope9:
 610               	.global	timer0ClearOverflowCount
 612               	timer0ClearOverflowCount:
 188:timer.c       **** 	}
 189:timer.c       **** }
 190:timer.c       **** /*
 191:timer.c       **** u32 timerMsToTics(u16 ms)
 192:timer.c       **** {
 193:timer.c       **** 	// calculate the prescaler division rate
 194:timer.c       **** 	u16 prescaleDiv = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));
 195:timer.c       **** 	// calculate the number of timer tics in x milliseconds
 196:timer.c       **** 	return (ms*(F_CPU/(prescaleDiv*256)))/1000;
 197:timer.c       **** }
 198:timer.c       **** 
 199:timer.c       **** u16 timerTicsToMs(u32 tics)
 200:timer.c       **** {
 201:timer.c       **** 	// calculate the prescaler division rate
 202:timer.c       **** 	u16 prescaleDiv = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));
 203:timer.c       **** 	// calculate the number of milliseconds in x timer tics
 204:timer.c       **** 	return (tics*1000*(prescaleDiv*256))/F_CPU;
 205:timer.c       **** }
 206:timer.c       **** */
 207:timer.c       **** void timerPause(unsigned short pause_ms)
 208:timer.c       **** {
 209:timer.c       **** 	// pauses for exactly <pause_ms> number of milliseconds
 210:timer.c       **** 	u08 timerThres;
 211:timer.c       **** 	u32 ticRateHz;
 212:timer.c       **** 	u32 pause;
 213:timer.c       **** 
 214:timer.c       **** 	// capture current pause timer value
 215:timer.c       **** 	timerThres = inb(TCNT0);
 216:timer.c       **** 	// reset pause timer overflow count
 217:timer.c       **** 	TimerPauseReg = 0;
 218:timer.c       **** 	// calculate delay for [pause_ms] milliseconds
 219:timer.c       **** 	// prescaler division = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)))
 220:timer.c       **** 	ticRateHz = F_CPU/timer0GetPrescaler();
 221:timer.c       **** 	// precision management
 222:timer.c       **** 	// prevent overflow and precision underflow
 223:timer.c       **** 	//	-could add more conditions to improve accuracy
 224:timer.c       **** 	if( ((ticRateHz < 429497) && (pause_ms <= 10000)) )
 225:timer.c       **** 		pause = (pause_ms*ticRateHz)/1000;
 226:timer.c       **** 	else
 227:timer.c       **** 		pause = pause_ms*(ticRateHz/1000);
 228:timer.c       **** 
 229:timer.c       **** 	// loop until time expires
 230:timer.c       **** 	while( ((TimerPauseReg<<8) | inb(TCNT0)) < (pause+timerThres) )
 231:timer.c       **** 	{
 232:timer.c       **** 		if( TimerPauseReg < (pause>>8));
 233:timer.c       **** 		{
 234:timer.c       **** 			// save power by idling the processor
 235:timer.c       **** 			set_sleep_mode(SLEEP_MODE_IDLE);
 236:timer.c       **** 			sleep_mode();
 237:timer.c       **** 		}
 238:timer.c       **** 	}
 239:timer.c       **** 
 240:timer.c       **** 	/* old inaccurate code, for reference
 241:timer.c       **** 	
 242:timer.c       **** 	// calculate delay for [pause_ms] milliseconds
 243:timer.c       **** 	u16 prescaleDiv = 1<<(pgm_read_byte(TimerPrescaleFactor+inb(TCCR0)));
 244:timer.c       **** 	u32 pause = (pause_ms*(F_CPU/(prescaleDiv*256)))/1000;
 245:timer.c       **** 	
 246:timer.c       **** 	TimerPauseReg = 0;
 247:timer.c       **** 	while(TimerPauseReg < pause);
 248:timer.c       **** 
 249:timer.c       **** 	*/
 250:timer.c       **** }
 251:timer.c       **** 
 252:timer.c       **** void timer0ClearOverflowCount(void)
 253:timer.c       **** {
 614               	.LM37:
 615               	/* prologue: frame size=0 */
 616               	/* prologue end (size=0) */
 254:timer.c       **** 	// clear the timer overflow counter registers
 255:timer.c       **** 	Timer0Reg0 = 0;	// initialize time registers
 618               	.LM38:
 619 014a 1092 0000 		sts Timer0Reg0,__zero_reg__
 620 014e 1092 0000 		sts (Timer0Reg0)+1,__zero_reg__
 621 0152 1092 0000 		sts (Timer0Reg0)+2,__zero_reg__
 622 0156 1092 0000 		sts (Timer0Reg0)+3,__zero_reg__
 623               	/* epilogue: frame size=0 */
 624 015a 0895      		ret
 625               	/* epilogue end (size=1) */
 626               	/* function timer0ClearOverflowCount size 9 (8) */
 628               	.Lscope10:
 631               	.global	timer0Init
 633               	timer0Init:
 635               	.LM39:
 636               	/* prologue: frame size=0 */
 637               	/* prologue end (size=0) */
 639               	.LM40:
 640 015c 82E0      		ldi r24,lo8(2)
 641 015e 0E94 0000 		call timer0SetPrescaler
 643               	.LM41:
 644 0162 12BE      		out 82-0x20,__zero_reg__
 646               	.LM42:
 647 0164 89B7      		in r24,89-0x20
 648 0166 8160      		ori r24,lo8(1)
 649 0168 89BF      		out 89-0x20,r24
 651               	.LM43:
 652 016a 0E94 0000 		call timer0ClearOverflowCount
 653               	/* epilogue: frame size=0 */
 654 016e 0895      		ret
 655               	/* epilogue end (size=1) */
 656               	/* function timer0Init size 10 (9) */
 658               	.Lscope11:
 662               	.global	timer1SetPrescaler
 664               	timer1SetPrescaler:
 666               	.LM44:
 667               	/* prologue: frame size=0 */
 668               	/* prologue end (size=0) */
 670               	.LM45:
 671 0170 9EB5      		in r25,78-0x20
 672 0172 987F      		andi r25,lo8(-8)
 673 0174 982B      		or r25,r24
 674 0176 9EBD      		out 78-0x20,r25
 675               	/* epilogue: frame size=0 */
 676 0178 0895      		ret
 677               	/* epilogue end (size=1) */
 678               	/* function timer1SetPrescaler size 5 (4) */
 680               	.Lscope12:
 683               	.global	timer1Init
 685               	timer1Init:
 687               	.LM46:
 688               	/* prologue: frame size=0 */
 689               	/* prologue end (size=0) */
 691               	.LM47:
 692 017a 83E0      		ldi r24,lo8(3)
 693 017c 0E94 0000 		call timer1SetPrescaler
 695               	.LM48:
 696 0180 1DBC      		out 77-0x20,__zero_reg__
 698               	.LM49:
 699 0182 1CBC      		out 76-0x20,__zero_reg__
 701               	.LM50:
 702 0184 89B7      		in r24,89-0x20
 703 0186 8460      		ori r24,lo8(4)
 704 0188 89BF      		out 89-0x20,r24
 705               	/* epilogue: frame size=0 */
 706 018a 0895      		ret
 707               	/* epilogue end (size=1) */
 708               	/* function timer1Init size 9 (8) */
 710               	.Lscope13:
 714               	.global	timer2SetPrescaler
 716               	timer2SetPrescaler:
 718               	.LM51:
 719               	/* prologue: frame size=0 */
 720               	/* prologue end (size=0) */
 722               	.LM52:
 723 018c 95B5      		in r25,69-0x20
 724 018e 987F      		andi r25,lo8(-8)
 725 0190 982B      		or r25,r24
 726 0192 95BD      		out 69-0x20,r25
 727               	/* epilogue: frame size=0 */
 728 0194 0895      		ret
 729               	/* epilogue end (size=1) */
 730               	/* function timer2SetPrescaler size 5 (4) */
 732               	.Lscope14:
 735               	.global	timer2ClearOverflowCount
 737               	timer2ClearOverflowCount:
 256:timer.c       **** }
 257:timer.c       **** 
 258:timer.c       **** long timer0GetOverflowCount(void)
 259:timer.c       **** {
 260:timer.c       **** 	// return the current timer overflow count
 261:timer.c       **** 	// (this is since the last timer0ClearOverflowCount() command was called)
 262:timer.c       **** 	return Timer0Reg0;
 263:timer.c       **** }
 264:timer.c       **** 
 265:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 266:timer.c       **** void timer2ClearOverflowCount(void)
 267:timer.c       **** {
 739               	.LM53:
 740               	/* prologue: frame size=0 */
 741               	/* prologue end (size=0) */
 268:timer.c       **** 	// clear the timer overflow counter registers
 269:timer.c       **** 	Timer2Reg0 = 0;	// initialize time registers
 743               	.LM54:
 744 0196 1092 0000 		sts Timer2Reg0,__zero_reg__
 745 019a 1092 0000 		sts (Timer2Reg0)+1,__zero_reg__
 746 019e 1092 0000 		sts (Timer2Reg0)+2,__zero_reg__
 747 01a2 1092 0000 		sts (Timer2Reg0)+3,__zero_reg__
 748               	/* epilogue: frame size=0 */
 749 01a6 0895      		ret
 750               	/* epilogue end (size=1) */
 751               	/* function timer2ClearOverflowCount size 9 (8) */
 753               	.Lscope15:
 756               	.global	timer2Init
 758               	timer2Init:
 760               	.LM55:
 761               	/* prologue: frame size=0 */
 762               	/* prologue end (size=0) */
 764               	.LM56:
 765 01a8 84E0      		ldi r24,lo8(4)
 766 01aa 0E94 0000 		call timer2SetPrescaler
 768               	.LM57:
 769 01ae 14BC      		out 68-0x20,__zero_reg__
 771               	.LM58:
 772 01b0 89B7      		in r24,89-0x20
 773 01b2 8064      		ori r24,lo8(64)
 774 01b4 89BF      		out 89-0x20,r24
 776               	.LM59:
 777 01b6 0E94 0000 		call timer2ClearOverflowCount
 778               	/* epilogue: frame size=0 */
 779 01ba 0895      		ret
 780               	/* epilogue end (size=1) */
 781               	/* function timer2Init size 10 (9) */
 783               	.Lscope16:
 786               	.global	timerInit
 788               	timerInit:
 790               	.LM60:
 791               	/* prologue: frame size=0 */
 792 01bc CF93      		push r28
 793               	/* prologue end (size=1) */
 795               	.LM61:
 796 01be C0E0      		ldi r28,lo8(0)
 797               	.L39:
 799               	.LM62:
 800 01c0 8C2F      		mov r24,r28
 801 01c2 0E94 0000 		call timerDetach
 803               	.LM63:
 804 01c6 CF5F      		subi r28,lo8(-(1))
 805 01c8 C830      		cpi r28,lo8(8)
 806 01ca D0F3      		brlo .L39
 808               	.LM64:
 809 01cc 0E94 0000 		call timer0Init
 811               	.LM65:
 812 01d0 0E94 0000 		call timer1Init
 814               	.LM66:
 815 01d4 0E94 0000 		call timer2Init
 817               	.LM67:
 818               	/* #APP */
 819 01d8 7894      		sei
 820               	/* #NOAPP */
 821               	/* epilogue: frame size=0 */
 822 01da CF91      		pop r28
 823 01dc 0895      		ret
 824               	/* epilogue end (size=2) */
 825               	/* function timerInit size 18 (15) */
 830               	.Lscope17:
 833               	.global	timer0GetPrescaler
 835               	timer0GetPrescaler:
 837               	.LM68:
 838               	/* prologue: frame size=0 */
 839               	/* prologue end (size=0) */
 840               	.LBB2:
 842               	.LM69:
 843 01de 83B7      		in r24,83-0x20
 844 01e0 E82F      		mov r30,r24
 845 01e2 FF27      		clr r31
 846 01e4 E770      		andi r30,lo8(7)
 847 01e6 F070      		andi r31,hi8(7)
 848 01e8 EE0F      		add r30,r30
 849 01ea FF1F      		adc r31,r31
 850 01ec E050      		subi r30,lo8(-(TimerPrescaleFactor))
 851 01ee F040      		sbci r31,hi8(-(TimerPrescaleFactor))
 852               	.LBE2:
 854               	.LM70:
 855               	/* #APP */
 856 01f0 8591      		lpm r24, Z+
 857 01f2 9491      		lpm r25, Z
 858               		
 859               	/* #NOAPP */
 860               	/* epilogue: frame size=0 */
 861 01f4 0895      		ret
 862               	/* epilogue end (size=1) */
 863               	/* function timer0GetPrescaler size 16 (15) */
 868               	.Lscope18:
 871               	.global	timer1GetPrescaler
 873               	timer1GetPrescaler:
 875               	.LM71:
 876               	/* prologue: frame size=0 */
 877               	/* prologue end (size=0) */
 878               	.LBB3:
 880               	.LM72:
 881 01f6 8EB5      		in r24,78-0x20
 882 01f8 E82F      		mov r30,r24
 883 01fa FF27      		clr r31
 884 01fc E770      		andi r30,lo8(7)
 885 01fe F070      		andi r31,hi8(7)
 886 0200 EE0F      		add r30,r30
 887 0202 FF1F      		adc r31,r31
 888 0204 E050      		subi r30,lo8(-(TimerPrescaleFactor))
 889 0206 F040      		sbci r31,hi8(-(TimerPrescaleFactor))
 890               	.LBE3:
 892               	.LM73:
 893               	/* #APP */
 894 0208 8591      		lpm r24, Z+
 895 020a 9491      		lpm r25, Z
 896               		
 897               	/* #NOAPP */
 898               	/* epilogue: frame size=0 */
 899 020c 0895      		ret
 900               	/* epilogue end (size=1) */
 901               	/* function timer1GetPrescaler size 16 (15) */
 906               	.Lscope19:
 909               	.global	timer2GetPrescaler
 911               	timer2GetPrescaler:
 913               	.LM74:
 914               	/* prologue: frame size=0 */
 915               	/* prologue end (size=0) */
 916               	.LBB4:
 918               	.LM75:
 919 020e 85B5      		in r24,69-0x20
 920 0210 E82F      		mov r30,r24
 921 0212 FF27      		clr r31
 922 0214 E770      		andi r30,lo8(7)
 923 0216 F070      		andi r31,hi8(7)
 924 0218 EE0F      		add r30,r30
 925 021a FF1F      		adc r31,r31
 926 021c E050      		subi r30,lo8(-(TimerRTCPrescaleFactor))
 927 021e F040      		sbci r31,hi8(-(TimerRTCPrescaleFactor))
 928               	.LBE4:
 930               	.LM76:
 931               	/* #APP */
 932 0220 8591      		lpm r24, Z+
 933 0222 9491      		lpm r25, Z
 934               		
 935               	/* #NOAPP */
 936               	/* epilogue: frame size=0 */
 937 0224 0895      		ret
 938               	/* epilogue end (size=1) */
 939               	/* function timer2GetPrescaler size 16 (15) */
 944               	.Lscope20:
 949               	.global	timerAttach
 951               	timerAttach:
 953               	.LM77:
 954               	/* prologue: frame size=0 */
 955               	/* prologue end (size=0) */
 957               	.LM78:
 958 0226 8830      		cpi r24,lo8(8)
 959 0228 40F4      		brsh .L45
 961               	.LM79:
 962 022a E82F      		mov r30,r24
 963 022c FF27      		clr r31
 964 022e EE0F      		add r30,r30
 965 0230 FF1F      		adc r31,r31
 966 0232 E050      		subi r30,lo8(-(TimerIntFunc))
 967 0234 F040      		sbci r31,hi8(-(TimerIntFunc))
 968 0236 7183      		std Z+1,r23
 969 0238 6083      		st Z,r22
 970               	.L45:
 971 023a 0895      		ret
 972               	/* epilogue: frame size=0 */
 973               	/* epilogue: noreturn */
 974               	/* epilogue end (size=0) */
 975               	/* function timerAttach size 11 (11) */
 977               	.Lscope21:
 981               	.global	timerPause
 983               	timerPause:
 985               	.LM80:
 986               	/* prologue: frame size=0 */
 987 023c DF92      		push r13
 988 023e EF92      		push r14
 989 0240 FF92      		push r15
 990 0242 0F93      		push r16
 991 0244 1F93      		push r17
 992 0246 CF93      		push r28
 993 0248 DF93      		push r29
 994               	/* prologue end (size=7) */
 995 024a EC01      		movw r28,r24
 997               	.LM81:
 998 024c D2B6      		in r13,82-0x20
 1000               	.LM82:
 1001 024e 1092 0000 		sts TimerPauseReg,__zero_reg__
 1002 0252 1092 0000 		sts (TimerPauseReg)+1,__zero_reg__
 1003 0256 1092 0000 		sts (TimerPauseReg)+2,__zero_reg__
 1004 025a 1092 0000 		sts (TimerPauseReg)+3,__zero_reg__
 1006               	.LM83:
 1007 025e 0E94 0000 		call timer0GetPrescaler
 1008 0262 9C01      		movw r18,r24
 1009 0264 4427      		clr r20
 1010 0266 5527      		clr r21
 1011 0268 60E0      		ldi r22,lo8(16000000)
 1012 026a 74E2      		ldi r23,hi8(16000000)
 1013 026c 84EF      		ldi r24,hlo8(16000000)
 1014 026e 90E0      		ldi r25,hhi8(16000000)
 1015 0270 0E94 0000 		call __divmodsi4
 1017               	.LM84:
 1018 0274 293B      		cpi r18,lo8(429497)
 1019 0276 8DE8      		ldi r24,hi8(429497)
 1020 0278 3807      		cpc r19,r24
 1021 027a 86E0      		ldi r24,hlo8(429497)
 1022 027c 4807      		cpc r20,r24
 1023 027e 80E0      		ldi r24,hhi8(429497)
 1024 0280 5807      		cpc r21,r24
 1025 0282 C0F4      		brsh .L48
 1027               	.LM85:
 1028 0284 87E2      		ldi r24,hi8(10001)
 1029 0286 C131      		cpi r28,lo8(10001)
 1030 0288 D807      		cpc r29,r24
 1031 028a A0F4      		brsh .L48
 1033               	.LM86:
 1034 028c CE01      		movw r24,r28
 1035 028e AA27      		clr r26
 1036 0290 BB27      		clr r27
 1037 0292 BC01      		movw r22,r24
 1038 0294 CD01      		movw r24,r26
 1039 0296 0E94 0000 		call __mulsi3
 1040 029a DC01      		movw r26,r24
 1041 029c CB01      		movw r24,r22
 1042 029e BC01      		movw r22,r24
 1043 02a0 CD01      		movw r24,r26
 1044 02a2 28EE      		ldi r18,lo8(1000)
 1045 02a4 33E0      		ldi r19,hi8(1000)
 1046 02a6 40E0      		ldi r20,hlo8(1000)
 1047 02a8 50E0      		ldi r21,hhi8(1000)
 1048 02aa 0E94 0000 		call __udivmodsi4
 1049 02ae FA01      		movw r30,r20
 1050 02b0 E901      		movw r28,r18
 1051 02b2 11C0      		rjmp .L49
 1052               	.L48:
 1054               	.LM87:
 1055 02b4 7E01      		movw r14,r28
 1056 02b6 0027      		clr r16
 1057 02b8 1127      		clr r17
 1058 02ba CA01      		movw r24,r20
 1059 02bc B901      		movw r22,r18
 1060 02be 28EE      		ldi r18,lo8(1000)
 1061 02c0 33E0      		ldi r19,hi8(1000)
 1062 02c2 40E0      		ldi r20,hlo8(1000)
 1063 02c4 50E0      		ldi r21,hhi8(1000)
 1064 02c6 0E94 0000 		call __udivmodsi4
 1065 02ca C801      		movw r24,r16
 1066 02cc B701      		movw r22,r14
 1067 02ce 0E94 0000 		call __mulsi3
 1068 02d2 FC01      		movw r30,r24
 1069 02d4 EB01      		movw r28,r22
 1070               	.L49:
 1072               	.LM88:
 1073 02d6 8091 0000 		lds r24,TimerPauseReg
 1074 02da 9091 0000 		lds r25,(TimerPauseReg)+1
 1075 02de A091 0000 		lds r26,(TimerPauseReg)+2
 1076 02e2 B091 0000 		lds r27,(TimerPauseReg)+3
 1077 02e6 2227      		clr r18
 1078 02e8 382F      		mov r19,r24
 1079 02ea 492F      		mov r20,r25
 1080 02ec 5A2F      		mov r21,r26
 1081 02ee 82B7      		in r24,82-0x20
 1082 02f0 9927      		clr r25
 1083 02f2 AA27      		clr r26
 1084 02f4 BB27      		clr r27
 1085 02f6 282B      		or r18,r24
 1086 02f8 392B      		or r19,r25
 1087 02fa 4A2B      		or r20,r26
 1088 02fc 5B2B      		or r21,r27
 1089 02fe CD0D      		add r28,r13
 1090 0300 D11D      		adc r29,__zero_reg__
 1091 0302 E11D      		adc r30,__zero_reg__
 1092 0304 F11D      		adc r31,__zero_reg__
 1093 0306 2C17      		cp r18,r28
 1094 0308 3D07      		cpc r19,r29
 1095 030a 4E07      		cpc r20,r30
 1096 030c 5F07      		cpc r21,r31
 1097 030e 58F5      		brsh .L57
 1098               	.L55:
 1100               	.LM89:
 1101 0310 8091 0000 		lds r24,TimerPauseReg
 1102 0314 9091 0000 		lds r25,(TimerPauseReg)+1
 1103 0318 A091 0000 		lds r26,(TimerPauseReg)+2
 1104 031c B091 0000 		lds r27,(TimerPauseReg)+3
 1106               	.LM90:
 1107 0320 85B7      		in r24,85-0x20
 1108 0322 8F78      		andi r24,lo8(-113)
 1109 0324 85BF      		out 85-0x20,r24
 1111               	.LM91:
 1112 0326 85B7      		in r24,85-0x20
 1113 0328 8068      		ori r24,lo8(-128)
 1114 032a 85BF      		out 85-0x20,r24
 1115               	/* #APP */
 1116 032c 8895      		sleep
 1117               		
 1118               	/* #NOAPP */
 1119 032e 85B7      		in r24,85-0x20
 1120 0330 8F77      		andi r24,lo8(127)
 1121 0332 85BF      		out 85-0x20,r24
 1122 0334 8091 0000 		lds r24,TimerPauseReg
 1123 0338 9091 0000 		lds r25,(TimerPauseReg)+1
 1124 033c A091 0000 		lds r26,(TimerPauseReg)+2
 1125 0340 B091 0000 		lds r27,(TimerPauseReg)+3
 1126 0344 BA2F      		mov r27,r26
 1127 0346 A92F      		mov r26,r25
 1128 0348 982F      		mov r25,r24
 1129 034a 8827      		clr r24
 1130 034c 22B7      		in r18,82-0x20
 1131 034e 3327      		clr r19
 1132 0350 4427      		clr r20
 1133 0352 5527      		clr r21
 1134 0354 822B      		or r24,r18
 1135 0356 932B      		or r25,r19
 1136 0358 A42B      		or r26,r20
 1137 035a B52B      		or r27,r21
 1138 035c 8C17      		cp r24,r28
 1139 035e 9D07      		cpc r25,r29
 1140 0360 AE07      		cpc r26,r30
 1141 0362 BF07      		cpc r27,r31
 1142 0364 A8F2      		brlo .L55
 1143               	.L57:
 1144               	/* epilogue: frame size=0 */
 1145 0366 DF91      		pop r29
 1146 0368 CF91      		pop r28
 1147 036a 1F91      		pop r17
 1148 036c 0F91      		pop r16
 1149 036e FF90      		pop r15
 1150 0370 EF90      		pop r14
 1151 0372 DF90      		pop r13
 1152 0374 0895      		ret
 1153               	/* epilogue end (size=8) */
 1154               	/* function timerPause size 160 (145) */
 1161               	.Lscope22:
 1164               	.global	timer0GetOverflowCount
 1166               	timer0GetOverflowCount:
 1168               	.LM92:
 1169               	/* prologue: frame size=0 */
 1170               	/* prologue end (size=0) */
 1172               	.LM93:
 1173 0376 8091 0000 		lds r24,Timer0Reg0
 1174 037a 9091 0000 		lds r25,(Timer0Reg0)+1
 1175 037e A091 0000 		lds r26,(Timer0Reg0)+2
 1176 0382 B091 0000 		lds r27,(Timer0Reg0)+3
 1178               	.LM94:
 1179 0386 BC01      		movw r22,r24
 1180 0388 CD01      		movw r24,r26
 1181               	/* epilogue: frame size=0 */
 1182 038a 0895      		ret
 1183               	/* epilogue end (size=1) */
 1184               	/* function timer0GetOverflowCount size 11 (10) */
 1186               	.Lscope23:
 1189               	.global	timer2GetOverflowCount
 1191               	timer2GetOverflowCount:
 270:timer.c       **** }
 271:timer.c       **** 
 272:timer.c       **** long timer2GetOverflowCount(void)
 273:timer.c       **** {
 1193               	.LM95:
 1194               	/* prologue: frame size=0 */
 1195               	/* prologue end (size=0) */
 274:timer.c       **** 	// return the current timer overflow count
 275:timer.c       **** 	// (this is since the last timer2ClearOverflowCount() command was called)
 276:timer.c       **** 	return Timer2Reg0;
 1197               	.LM96:
 1198 038c 8091 0000 		lds r24,Timer2Reg0
 1199 0390 9091 0000 		lds r25,(Timer2Reg0)+1
 1200 0394 A091 0000 		lds r26,(Timer2Reg0)+2
 1201 0398 B091 0000 		lds r27,(Timer2Reg0)+3
 277:timer.c       **** }
 1203               	.LM97:
 1204 039c BC01      		movw r22,r24
 1205 039e CD01      		movw r24,r26
 1206               	/* epilogue: frame size=0 */
 1207 03a0 0895      		ret
 1208               	/* epilogue end (size=1) */
 1209               	/* function timer2GetOverflowCount size 11 (10) */
 1211               	.Lscope24:
 1215               	.global	timer1PWMInit
 1217               	timer1PWMInit:
 278:timer.c       **** #endif
 279:timer.c       **** 
 280:timer.c       **** void timer1PWMInit(u08 bitRes)
 281:timer.c       **** {
 1219               	.LM98:
 1220               	/* prologue: frame size=0 */
 1221               	/* prologue end (size=0) */
 282:timer.c       **** 	// configures timer1 for use with PWM output
 283:timer.c       **** 	// on OC1A and OC1B pins
 284:timer.c       **** 
 285:timer.c       **** 	// enable timer1 as 8,9,10bit PWM
 286:timer.c       **** 	if(bitRes == 9)
 1223               	.LM99:
 1224 03a2 8930      		cpi r24,lo8(9)
 1225 03a4 31F4      		brne .L61
 287:timer.c       **** 	{	// 9bit mode
 288:timer.c       **** 		sbi(TCCR1A,PWM11);
 1227               	.LM100:
 1228 03a6 8FB5      		in r24,79-0x20
 1229 03a8 8260      		ori r24,lo8(2)
 1230 03aa 8FBD      		out 79-0x20,r24
 289:timer.c       **** 		cbi(TCCR1A,PWM10);
 1232               	.LM101:
 1233 03ac 8FB5      		in r24,79-0x20
 1234 03ae 8E7F      		andi r24,lo8(-2)
 1235 03b0 0AC0      		rjmp .L66
 1236               	.L61:
 290:timer.c       **** 	}
 291:timer.c       **** 	else if( bitRes == 10 )
 1238               	.LM102:
 1239 03b2 8A30      		cpi r24,lo8(10)
 1240 03b4 19F4      		brne .L63
 292:timer.c       **** 	{	// 10bit mode
 293:timer.c       **** 		sbi(TCCR1A,PWM11);
 1242               	.LM103:
 1243 03b6 8FB5      		in r24,79-0x20
 1244 03b8 8260      		ori r24,lo8(2)
 1245 03ba 02C0      		rjmp .L65
 1246               	.L63:
 294:timer.c       **** 		sbi(TCCR1A,PWM10);
 295:timer.c       **** 	}
 296:timer.c       **** 	else
 297:timer.c       **** 	{	// default 8bit mode
 298:timer.c       **** 		cbi(TCCR1A,PWM11);
 1248               	.LM104:
 1249 03bc 8FB5      		in r24,79-0x20
 1250 03be 8D7F      		andi r24,lo8(-3)
 1251               	.L65:
 1252 03c0 8FBD      		out 79-0x20,r24
 299:timer.c       **** 		sbi(TCCR1A,PWM10);
 1254               	.LM105:
 1255 03c2 8FB5      		in r24,79-0x20
 1256 03c4 8160      		ori r24,lo8(1)
 1257               	.L66:
 1258 03c6 8FBD      		out 79-0x20,r24
 300:timer.c       **** 	}
 301:timer.c       **** 
 302:timer.c       **** 	// clear output compare value A
 303:timer.c       **** 	outb(OCR1AH, 0);
 1260               	.LM106:
 1261 03c8 1BBC      		out 75-0x20,__zero_reg__
 304:timer.c       **** 	outb(OCR1AL, 0);
 1263               	.LM107:
 1264 03ca 1ABC      		out 74-0x20,__zero_reg__
 305:timer.c       **** 	// clear output compare value B
 306:timer.c       **** 	outb(OCR1BH, 0);
 1266               	.LM108:
 1267 03cc 19BC      		out 73-0x20,__zero_reg__
 307:timer.c       **** 	outb(OCR1BL, 0);
 1269               	.LM109:
 1270 03ce 18BC      		out 72-0x20,__zero_reg__
 1271               	/* epilogue: frame size=0 */
 1272 03d0 0895      		ret
 1273               	/* epilogue end (size=1) */
 1274               	/* function timer1PWMInit size 24 (23) */
 1276               	.Lscope25:
 1280               	.global	timer1PWMInitICR
 1282               	timer1PWMInitICR:
 308:timer.c       **** }
 309:timer.c       **** 
 310:timer.c       **** #ifdef WGM10
 311:timer.c       **** // include support for arbitrary top-count PWM
 312:timer.c       **** // on new AVR processors that support it
 313:timer.c       **** void timer1PWMInitICR(u16 topcount)
 314:timer.c       **** {
 1284               	.LM110:
 1285               	/* prologue: frame size=0 */
 1286               	/* prologue end (size=0) */
 1287 03d2 9C01      		movw r18,r24
 315:timer.c       **** 	// set PWM mode with ICR top-count
 316:timer.c       **** 	cbi(TCCR1A,WGM10);
 1289               	.LM111:
 1290 03d4 8FB5      		in r24,79-0x20
 1291 03d6 8E7F      		andi r24,lo8(-2)
 1292 03d8 8FBD      		out 79-0x20,r24
 317:timer.c       **** 	sbi(TCCR1A,WGM11);
 1294               	.LM112:
 1295 03da 8FB5      		in r24,79-0x20
 1296 03dc 8260      		ori r24,lo8(2)
 1297 03de 8FBD      		out 79-0x20,r24
 318:timer.c       **** 	sbi(TCCR1B,WGM12);
 1299               	.LM113:
 1300 03e0 8EB5      		in r24,78-0x20
 1301 03e2 8860      		ori r24,lo8(8)
 1302 03e4 8EBD      		out 78-0x20,r24
 319:timer.c       **** 	sbi(TCCR1B,WGM13);
 1304               	.LM114:
 1305 03e6 8EB5      		in r24,78-0x20
 1306 03e8 8061      		ori r24,lo8(16)
 1307 03ea 8EBD      		out 78-0x20,r24
 320:timer.c       **** 	
 321:timer.c       **** 	// set top count value
 322:timer.c       **** 	ICR1 = topcount;
 1309               	.LM115:
 1310 03ec 37BD      		out (70)+1-0x20,r19
 1311 03ee 26BD      		out 70-0x20,r18
 323:timer.c       **** 	
 324:timer.c       **** 	// clear output compare value A
 325:timer.c       **** 	OCR1A = 0;
 1313               	.LM116:
 1314 03f0 1BBC      		out (74)+1-0x20,__zero_reg__
 1315 03f2 1ABC      		out 74-0x20,__zero_reg__
 326:timer.c       **** 	// clear output compare value B
 327:timer.c       **** 	OCR1B = 0;
 1317               	.LM117:
 1318 03f4 19BC      		out (72)+1-0x20,__zero_reg__
 1319 03f6 18BC      		out 72-0x20,__zero_reg__
 1320               	/* epilogue: frame size=0 */
 1321 03f8 0895      		ret
 1322               	/* epilogue end (size=1) */
 1323               	/* function timer1PWMInitICR size 20 (19) */
 1325               	.Lscope26:
 1328               	.global	timer1PWMAOff
 1330               	timer1PWMAOff:
 328:timer.c       **** 
 329:timer.c       **** }
 330:timer.c       **** #endif
 331:timer.c       **** 
 332:timer.c       **** void timer1PWMOff(void)
 333:timer.c       **** {
 334:timer.c       **** 	// turn off timer1 PWM mode
 335:timer.c       **** 	cbi(TCCR1A,PWM11);
 336:timer.c       **** 	cbi(TCCR1A,PWM10);
 337:timer.c       **** 	// set PWM1A/B (OutputCompare action) to none
 338:timer.c       **** 	timer1PWMAOff();
 339:timer.c       **** 	timer1PWMBOff();
 340:timer.c       **** }
 341:timer.c       **** 
 342:timer.c       **** void timer1PWMAOn(void)
 343:timer.c       **** {
 344:timer.c       **** 	// turn on channel A (OC1A) PWM output
 345:timer.c       **** 	// set OC1A as non-inverted PWM
 346:timer.c       **** 	sbi(TCCR1A,COM1A1);
 347:timer.c       **** 	cbi(TCCR1A,COM1A0);
 348:timer.c       **** }
 349:timer.c       **** 
 350:timer.c       **** void timer1PWMBOn(void)
 351:timer.c       **** {
 352:timer.c       **** 	// turn on channel B (OC1B) PWM output
 353:timer.c       **** 	// set OC1B as non-inverted PWM
 354:timer.c       **** 	sbi(TCCR1A,COM1B1);
 355:timer.c       **** 	cbi(TCCR1A,COM1B0);
 356:timer.c       **** }
 357:timer.c       **** 
 358:timer.c       **** void timer1PWMAOff(void)
 359:timer.c       **** {
 1332               	.LM118:
 1333               	/* prologue: frame size=0 */
 1334               	/* prologue end (size=0) */
 360:timer.c       **** 	// turn off channel A (OC1A) PWM output
 361:timer.c       **** 	// set OC1A (OutputCompare action) to none
 362:timer.c       **** 	cbi(TCCR1A,COM1A1);
 1336               	.LM119:
 1337 03fa 8FB5      		in r24,79-0x20
 1338 03fc 8F77      		andi r24,lo8(127)
 1339 03fe 8FBD      		out 79-0x20,r24
 363:timer.c       **** 	cbi(TCCR1A,COM1A0);
 1341               	.LM120:
 1342 0400 8FB5      		in r24,79-0x20
 1343 0402 8F7B      		andi r24,lo8(-65)
 1344 0404 8FBD      		out 79-0x20,r24
 1345               	/* epilogue: frame size=0 */
 1346 0406 0895      		ret
 1347               	/* epilogue end (size=1) */
 1348               	/* function timer1PWMAOff size 7 (6) */
 1350               	.Lscope27:
 1353               	.global	timer1PWMBOff
 1355               	timer1PWMBOff:
 364:timer.c       **** }
 365:timer.c       **** 
 366:timer.c       **** void timer1PWMBOff(void)
 367:timer.c       **** {
 1357               	.LM121:
 1358               	/* prologue: frame size=0 */
 1359               	/* prologue end (size=0) */
 368:timer.c       **** 	// turn off channel B (OC1B) PWM output
 369:timer.c       **** 	// set OC1B (OutputCompare action) to none
 370:timer.c       **** 	cbi(TCCR1A,COM1B1);
 1361               	.LM122:
 1362 0408 8FB5      		in r24,79-0x20
 1363 040a 8F7D      		andi r24,lo8(-33)
 1364 040c 8FBD      		out 79-0x20,r24
 371:timer.c       **** 	cbi(TCCR1A,COM1B0);
 1366               	.LM123:
 1367 040e 8FB5      		in r24,79-0x20
 1368 0410 8F7E      		andi r24,lo8(-17)
 1369 0412 8FBD      		out 79-0x20,r24
 1370               	/* epilogue: frame size=0 */
 1371 0414 0895      		ret
 1372               	/* epilogue end (size=1) */
 1373               	/* function timer1PWMBOff size 7 (6) */
 1375               	.Lscope28:
 1378               	.global	timer1PWMOff
 1380               	timer1PWMOff:
 1382               	.LM124:
 1383               	/* prologue: frame size=0 */
 1384               	/* prologue end (size=0) */
 1386               	.LM125:
 1387 0416 8FB5      		in r24,79-0x20
 1388 0418 8D7F      		andi r24,lo8(-3)
 1389 041a 8FBD      		out 79-0x20,r24
 1391               	.LM126:
 1392 041c 8FB5      		in r24,79-0x20
 1393 041e 8E7F      		andi r24,lo8(-2)
 1394 0420 8FBD      		out 79-0x20,r24
 1396               	.LM127:
 1397 0422 0E94 0000 		call timer1PWMAOff
 1399               	.LM128:
 1400 0426 0E94 0000 		call timer1PWMBOff
 1401               	/* epilogue: frame size=0 */
 1402 042a 0895      		ret
 1403               	/* epilogue end (size=1) */
 1404               	/* function timer1PWMOff size 11 (10) */
 1406               	.Lscope29:
 1409               	.global	timer1PWMAOn
 1411               	timer1PWMAOn:
 1413               	.LM129:
 1414               	/* prologue: frame size=0 */
 1415               	/* prologue end (size=0) */
 1417               	.LM130:
 1418 042c 8FB5      		in r24,79-0x20
 1419 042e 8068      		ori r24,lo8(-128)
 1420 0430 8FBD      		out 79-0x20,r24
 1422               	.LM131:
 1423 0432 8FB5      		in r24,79-0x20
 1424 0434 8F7B      		andi r24,lo8(-65)
 1425 0436 8FBD      		out 79-0x20,r24
 1426               	/* epilogue: frame size=0 */
 1427 0438 0895      		ret
 1428               	/* epilogue end (size=1) */
 1429               	/* function timer1PWMAOn size 7 (6) */
 1431               	.Lscope30:
 1434               	.global	timer1PWMBOn
 1436               	timer1PWMBOn:
 1438               	.LM132:
 1439               	/* prologue: frame size=0 */
 1440               	/* prologue end (size=0) */
 1442               	.LM133:
 1443 043a 8FB5      		in r24,79-0x20
 1444 043c 8062      		ori r24,lo8(32)
 1445 043e 8FBD      		out 79-0x20,r24
 1447               	.LM134:
 1448 0440 8FB5      		in r24,79-0x20
 1449 0442 8F7E      		andi r24,lo8(-17)
 1450 0444 8FBD      		out 79-0x20,r24
 1451               	/* epilogue: frame size=0 */
 1452 0446 0895      		ret
 1453               	/* epilogue end (size=1) */
 1454               	/* function timer1PWMBOn size 7 (6) */
 1456               	.Lscope31:
 1460               	.global	timer1PWMASet
 1462               	timer1PWMASet:
 372:timer.c       **** }
 373:timer.c       **** 
 374:timer.c       **** void timer1PWMASet(u16 pwmDuty)
 375:timer.c       **** {
 1464               	.LM135:
 1465               	/* prologue: frame size=0 */
 1466               	/* prologue end (size=0) */
 376:timer.c       **** 	// set PWM (output compare) duty for channel A
 377:timer.c       **** 	// this PWM output is generated on OC1A pin
 378:timer.c       **** 	// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
 379:timer.c       **** 	//			pwmDuty should be in the range 0-511 for 9bit PWM
 380:timer.c       **** 	//			pwmDuty should be in the range 0-1023 for 10bit PWM
 381:timer.c       **** 	//outp( (pwmDuty>>8), OCR1AH);		// set the high 8bits of OCR1A
 382:timer.c       **** 	//outp( (pwmDuty&0x00FF), OCR1AL);	// set the low 8bits of OCR1A
 383:timer.c       **** 	OCR1A = pwmDuty;
 1468               	.LM136:
 1469 0448 9BBD      		out (74)+1-0x20,r25
 1470 044a 8ABD      		out 74-0x20,r24
 1471               	/* epilogue: frame size=0 */
 1472 044c 0895      		ret
 1473               	/* epilogue end (size=1) */
 1474               	/* function timer1PWMASet size 3 (2) */
 1476               	.Lscope32:
 1480               	.global	timer1PWMBSet
 1482               	timer1PWMBSet:
 384:timer.c       **** }
 385:timer.c       **** 
 386:timer.c       **** void timer1PWMBSet(u16 pwmDuty)
 387:timer.c       **** {
 1484               	.LM137:
 1485               	/* prologue: frame size=0 */
 1486               	/* prologue end (size=0) */
 388:timer.c       **** 	// set PWM (output compare) duty for channel B
 389:timer.c       **** 	// this PWM output is generated on OC1B pin
 390:timer.c       **** 	// NOTE:	pwmDuty should be in the range 0-255 for 8bit PWM
 391:timer.c       **** 	//			pwmDuty should be in the range 0-511 for 9bit PWM
 392:timer.c       **** 	//			pwmDuty should be in the range 0-1023 for 10bit PWM
 393:timer.c       **** 	//outp( (pwmDuty>>8), OCR1BH);		// set the high 8bits of OCR1B
 394:timer.c       **** 	//outp( (pwmDuty&0x00FF), OCR1BL);	// set the low 8bits of OCR1B
 395:timer.c       **** 	OCR1B = pwmDuty;
 1488               	.LM138:
 1489 044e 99BD      		out (72)+1-0x20,r25
 1490 0450 88BD      		out 72-0x20,r24
 1491               	/* epilogue: frame size=0 */
 1492 0452 0895      		ret
 1493               	/* epilogue end (size=1) */
 1494               	/* function timer1PWMBSet size 3 (2) */
 1496               	.Lscope33:
 1499               	.global	__vector_9
 1501               	__vector_9:
 396:timer.c       **** }
 397:timer.c       **** /*
 398:timer.c       **** //! Interrupt handler for tcnt0 overflow interrupt
 399:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW0)
 400:timer.c       **** {
 401:timer.c       **** 	Timer0Reg0++;			// increment low-order counter
 402:timer.c       **** 
 403:timer.c       **** 	// increment pause counter
 404:timer.c       **** 	TimerPauseReg++;
 405:timer.c       **** 
 406:timer.c       **** 	// if a user function is defined, execute it too
 407:timer.c       **** 	if(TimerIntFunc[TIMER0OVERFLOW_INT])
 408:timer.c       **** 		TimerIntFunc[TIMER0OVERFLOW_INT]();
 409:timer.c       **** }
 410:timer.c       **** */
 411:timer.c       **** 
 412:timer.c       **** //! Interrupt handler for tcnt1 overflow interrupt
 413:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW1)
 414:timer.c       **** {
 1503               	.LM139:
 1504               	/* prologue: frame size=0 */
 1505 0454 1F92      		push __zero_reg__
 1506 0456 0F92      		push __tmp_reg__
 1507 0458 0FB6      		in __tmp_reg__,__SREG__
 1508 045a 0F92      		push __tmp_reg__
 1509 045c 1124      		clr __zero_reg__
 1510 045e 2F93      		push r18
 1511 0460 3F93      		push r19
 1512 0462 4F93      		push r20
 1513 0464 5F93      		push r21
 1514 0466 6F93      		push r22
 1515 0468 7F93      		push r23
 1516 046a 8F93      		push r24
 1517 046c 9F93      		push r25
 1518 046e AF93      		push r26
 1519 0470 BF93      		push r27
 1520 0472 EF93      		push r30
 1521 0474 FF93      		push r31
 1522               	/* prologue end (size=17) */
 415:timer.c       **** 	// if a user function is defined, execute it
 416:timer.c       **** 	if(TimerIntFunc[TIMER1OVERFLOW_INT])
 1524               	.LM140:
 1525 0476 8091 0000 		lds r24,TimerIntFunc+2
 1526 047a 9091 0000 		lds r25,(TimerIntFunc+2)+1
 1527 047e 892B      		or r24,r25
 1528 0480 29F0      		breq .L75
 417:timer.c       **** 		TimerIntFunc[TIMER1OVERFLOW_INT]();
 1530               	.LM141:
 1531 0482 E091 0000 		lds r30,TimerIntFunc+2
 1532 0486 F091 0000 		lds r31,(TimerIntFunc+2)+1
 1533 048a 0995      		icall
 1534               	.L75:
 1535               	/* epilogue: frame size=0 */
 1536 048c FF91      		pop r31
 1537 048e EF91      		pop r30
 1538 0490 BF91      		pop r27
 1539 0492 AF91      		pop r26
 1540 0494 9F91      		pop r25
 1541 0496 8F91      		pop r24
 1542 0498 7F91      		pop r23
 1543 049a 6F91      		pop r22
 1544 049c 5F91      		pop r21
 1545 049e 4F91      		pop r20
 1546 04a0 3F91      		pop r19
 1547 04a2 2F91      		pop r18
 1548 04a4 0F90      		pop __tmp_reg__
 1549 04a6 0FBE      		out __SREG__,__tmp_reg__
 1550 04a8 0F90      		pop __tmp_reg__
 1551 04aa 1F90      		pop __zero_reg__
 1552 04ac 1895      		reti
 1553               	/* epilogue end (size=17) */
 1554               	/* function __vector_9 size 45 (11) */
 1556               	.Lscope34:
 1559               	.global	__vector_5
 1561               	__vector_5:
 418:timer.c       **** }
 419:timer.c       **** 
 420:timer.c       **** #ifdef TCNT2	// support timer2 only if it exists
 421:timer.c       **** //! Interrupt handler for tcnt2 overflow interrupt
 422:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OVERFLOW2)
 423:timer.c       **** {
 1563               	.LM142:
 1564               	/* prologue: frame size=0 */
 1565 04ae 1F92      		push __zero_reg__
 1566 04b0 0F92      		push __tmp_reg__
 1567 04b2 0FB6      		in __tmp_reg__,__SREG__
 1568 04b4 0F92      		push __tmp_reg__
 1569 04b6 1124      		clr __zero_reg__
 1570 04b8 2F93      		push r18
 1571 04ba 3F93      		push r19
 1572 04bc 4F93      		push r20
 1573 04be 5F93      		push r21
 1574 04c0 6F93      		push r22
 1575 04c2 7F93      		push r23
 1576 04c4 8F93      		push r24
 1577 04c6 9F93      		push r25
 1578 04c8 AF93      		push r26
 1579 04ca BF93      		push r27
 1580 04cc EF93      		push r30
 1581 04ce FF93      		push r31
 1582               	/* prologue end (size=17) */
 424:timer.c       **** 	Timer2Reg0++;			// increment low-order counter
 1584               	.LM143:
 1585 04d0 8091 0000 		lds r24,Timer2Reg0
 1586 04d4 9091 0000 		lds r25,(Timer2Reg0)+1
 1587 04d8 A091 0000 		lds r26,(Timer2Reg0)+2
 1588 04dc B091 0000 		lds r27,(Timer2Reg0)+3
 1589 04e0 0196      		adiw r24,1
 1590 04e2 A11D      		adc r26,__zero_reg__
 1591 04e4 B11D      		adc r27,__zero_reg__
 1592 04e6 8093 0000 		sts Timer2Reg0,r24
 1593 04ea 9093 0000 		sts (Timer2Reg0)+1,r25
 1594 04ee A093 0000 		sts (Timer2Reg0)+2,r26
 1595 04f2 B093 0000 		sts (Timer2Reg0)+3,r27
 425:timer.c       **** 
 426:timer.c       **** 	// if a user function is defined, execute it
 427:timer.c       **** 	if(TimerIntFunc[TIMER2OVERFLOW_INT])
 1597               	.LM144:
 1598 04f6 8091 0000 		lds r24,TimerIntFunc+10
 1599 04fa 9091 0000 		lds r25,(TimerIntFunc+10)+1
 1600 04fe 892B      		or r24,r25
 1601 0500 29F0      		breq .L77
 428:timer.c       **** 		TimerIntFunc[TIMER2OVERFLOW_INT]();
 1603               	.LM145:
 1604 0502 E091 0000 		lds r30,TimerIntFunc+10
 1605 0506 F091 0000 		lds r31,(TimerIntFunc+10)+1
 1606 050a 0995      		icall
 1607               	.L77:
 1608               	/* epilogue: frame size=0 */
 1609 050c FF91      		pop r31
 1610 050e EF91      		pop r30
 1611 0510 BF91      		pop r27
 1612 0512 AF91      		pop r26
 1613 0514 9F91      		pop r25
 1614 0516 8F91      		pop r24
 1615 0518 7F91      		pop r23
 1616 051a 6F91      		pop r22
 1617 051c 5F91      		pop r21
 1618 051e 4F91      		pop r20
 1619 0520 3F91      		pop r19
 1620 0522 2F91      		pop r18
 1621 0524 0F90      		pop __tmp_reg__
 1622 0526 0FBE      		out __SREG__,__tmp_reg__
 1623 0528 0F90      		pop __tmp_reg__
 1624 052a 1F90      		pop __zero_reg__
 1625 052c 1895      		reti
 1626               	/* epilogue end (size=17) */
 1627               	/* function __vector_5 size 64 (30) */
 1629               	.Lscope35:
 1632               	.global	__vector_10
 1634               	__vector_10:
 429:timer.c       **** }
 430:timer.c       **** #endif
 431:timer.c       **** 
 432:timer.c       **** #ifdef OCR0
 433:timer.c       **** // include support for Output Compare 0 for new AVR processors that support it
 434:timer.c       **** //! Interrupt handler for OutputCompare0 match (OC0) interrupt
 435:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE0)
 436:timer.c       **** {
 1636               	.LM146:
 1637               	/* prologue: frame size=0 */
 1638 052e 1F92      		push __zero_reg__
 1639 0530 0F92      		push __tmp_reg__
 1640 0532 0FB6      		in __tmp_reg__,__SREG__
 1641 0534 0F92      		push __tmp_reg__
 1642 0536 1124      		clr __zero_reg__
 1643 0538 2F93      		push r18
 1644 053a 3F93      		push r19
 1645 053c 4F93      		push r20
 1646 053e 5F93      		push r21
 1647 0540 6F93      		push r22
 1648 0542 7F93      		push r23
 1649 0544 8F93      		push r24
 1650 0546 9F93      		push r25
 1651 0548 AF93      		push r26
 1652 054a BF93      		push r27
 1653 054c EF93      		push r30
 1654 054e FF93      		push r31
 1655               	/* prologue end (size=17) */
 437:timer.c       **** 	// if a user function is defined, execute it
 438:timer.c       **** 	if(TimerIntFunc[TIMER0OUTCOMPARE_INT])
 1657               	.LM147:
 1658 0550 8091 0000 		lds r24,TimerIntFunc+14
 1659 0554 9091 0000 		lds r25,(TimerIntFunc+14)+1
 1660 0558 892B      		or r24,r25
 1661 055a 29F0      		breq .L79
 439:timer.c       **** 		TimerIntFunc[TIMER0OUTCOMPARE_INT]();
 1663               	.LM148:
 1664 055c E091 0000 		lds r30,TimerIntFunc+14
 1665 0560 F091 0000 		lds r31,(TimerIntFunc+14)+1
 1666 0564 0995      		icall
 1667               	.L79:
 1668               	/* epilogue: frame size=0 */
 1669 0566 FF91      		pop r31
 1670 0568 EF91      		pop r30
 1671 056a BF91      		pop r27
 1672 056c AF91      		pop r26
 1673 056e 9F91      		pop r25
 1674 0570 8F91      		pop r24
 1675 0572 7F91      		pop r23
 1676 0574 6F91      		pop r22
 1677 0576 5F91      		pop r21
 1678 0578 4F91      		pop r20
 1679 057a 3F91      		pop r19
 1680 057c 2F91      		pop r18
 1681 057e 0F90      		pop __tmp_reg__
 1682 0580 0FBE      		out __SREG__,__tmp_reg__
 1683 0582 0F90      		pop __tmp_reg__
 1684 0584 1F90      		pop __zero_reg__
 1685 0586 1895      		reti
 1686               	/* epilogue end (size=17) */
 1687               	/* function __vector_10 size 45 (11) */
 1689               	.Lscope36:
 1692               	.global	__vector_7
 1694               	__vector_7:
 440:timer.c       **** }
 441:timer.c       **** #endif
 442:timer.c       **** 
 443:timer.c       **** //! Interrupt handler for CutputCompare1A match (OC1A) interrupt
 444:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1A)
 445:timer.c       **** {
 1696               	.LM149:
 1697               	/* prologue: frame size=0 */
 1698 0588 1F92      		push __zero_reg__
 1699 058a 0F92      		push __tmp_reg__
 1700 058c 0FB6      		in __tmp_reg__,__SREG__
 1701 058e 0F92      		push __tmp_reg__
 1702 0590 1124      		clr __zero_reg__
 1703 0592 2F93      		push r18
 1704 0594 3F93      		push r19
 1705 0596 4F93      		push r20
 1706 0598 5F93      		push r21
 1707 059a 6F93      		push r22
 1708 059c 7F93      		push r23
 1709 059e 8F93      		push r24
 1710 05a0 9F93      		push r25
 1711 05a2 AF93      		push r26
 1712 05a4 BF93      		push r27
 1713 05a6 EF93      		push r30
 1714 05a8 FF93      		push r31
 1715               	/* prologue end (size=17) */
 446:timer.c       **** 	// if a user function is defined, execute it
 447:timer.c       **** 	if(TimerIntFunc[TIMER1OUTCOMPAREA_INT])
 1717               	.LM150:
 1718 05aa 8091 0000 		lds r24,TimerIntFunc+4
 1719 05ae 9091 0000 		lds r25,(TimerIntFunc+4)+1
 1720 05b2 892B      		or r24,r25
 1721 05b4 29F0      		breq .L81
 448:timer.c       **** 		TimerIntFunc[TIMER1OUTCOMPAREA_INT]();
 1723               	.LM151:
 1724 05b6 E091 0000 		lds r30,TimerIntFunc+4
 1725 05ba F091 0000 		lds r31,(TimerIntFunc+4)+1
 1726 05be 0995      		icall
 1727               	.L81:
 1728               	/* epilogue: frame size=0 */
 1729 05c0 FF91      		pop r31
 1730 05c2 EF91      		pop r30
 1731 05c4 BF91      		pop r27
 1732 05c6 AF91      		pop r26
 1733 05c8 9F91      		pop r25
 1734 05ca 8F91      		pop r24
 1735 05cc 7F91      		pop r23
 1736 05ce 6F91      		pop r22
 1737 05d0 5F91      		pop r21
 1738 05d2 4F91      		pop r20
 1739 05d4 3F91      		pop r19
 1740 05d6 2F91      		pop r18
 1741 05d8 0F90      		pop __tmp_reg__
 1742 05da 0FBE      		out __SREG__,__tmp_reg__
 1743 05dc 0F90      		pop __tmp_reg__
 1744 05de 1F90      		pop __zero_reg__
 1745 05e0 1895      		reti
 1746               	/* epilogue end (size=17) */
 1747               	/* function __vector_7 size 45 (11) */
 1749               	.Lscope37:
 1752               	.global	__vector_8
 1754               	__vector_8:
 449:timer.c       **** }
 450:timer.c       **** 
 451:timer.c       **** //! Interrupt handler for OutputCompare1B match (OC1B) interrupt
 452:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE1B)
 453:timer.c       **** {
 1756               	.LM152:
 1757               	/* prologue: frame size=0 */
 1758 05e2 1F92      		push __zero_reg__
 1759 05e4 0F92      		push __tmp_reg__
 1760 05e6 0FB6      		in __tmp_reg__,__SREG__
 1761 05e8 0F92      		push __tmp_reg__
 1762 05ea 1124      		clr __zero_reg__
 1763 05ec 2F93      		push r18
 1764 05ee 3F93      		push r19
 1765 05f0 4F93      		push r20
 1766 05f2 5F93      		push r21
 1767 05f4 6F93      		push r22
 1768 05f6 7F93      		push r23
 1769 05f8 8F93      		push r24
 1770 05fa 9F93      		push r25
 1771 05fc AF93      		push r26
 1772 05fe BF93      		push r27
 1773 0600 EF93      		push r30
 1774 0602 FF93      		push r31
 1775               	/* prologue end (size=17) */
 454:timer.c       **** 	// if a user function is defined, execute it
 455:timer.c       **** 	if(TimerIntFunc[TIMER1OUTCOMPAREB_INT])
 1777               	.LM153:
 1778 0604 8091 0000 		lds r24,TimerIntFunc+6
 1779 0608 9091 0000 		lds r25,(TimerIntFunc+6)+1
 1780 060c 892B      		or r24,r25
 1781 060e 29F0      		breq .L83
 456:timer.c       **** 		TimerIntFunc[TIMER1OUTCOMPAREB_INT]();
 1783               	.LM154:
 1784 0610 E091 0000 		lds r30,TimerIntFunc+6
 1785 0614 F091 0000 		lds r31,(TimerIntFunc+6)+1
 1786 0618 0995      		icall
 1787               	.L83:
 1788               	/* epilogue: frame size=0 */
 1789 061a FF91      		pop r31
 1790 061c EF91      		pop r30
 1791 061e BF91      		pop r27
 1792 0620 AF91      		pop r26
 1793 0622 9F91      		pop r25
 1794 0624 8F91      		pop r24
 1795 0626 7F91      		pop r23
 1796 0628 6F91      		pop r22
 1797 062a 5F91      		pop r21
 1798 062c 4F91      		pop r20
 1799 062e 3F91      		pop r19
 1800 0630 2F91      		pop r18
 1801 0632 0F90      		pop __tmp_reg__
 1802 0634 0FBE      		out __SREG__,__tmp_reg__
 1803 0636 0F90      		pop __tmp_reg__
 1804 0638 1F90      		pop __zero_reg__
 1805 063a 1895      		reti
 1806               	/* epilogue end (size=17) */
 1807               	/* function __vector_8 size 45 (11) */
 1809               	.Lscope38:
 1812               	.global	__vector_6
 1814               	__vector_6:
 457:timer.c       **** }
 458:timer.c       **** 
 459:timer.c       **** //! Interrupt handler for InputCapture1 (IC1) interrupt
 460:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_INPUT_CAPTURE1)
 461:timer.c       **** {
 1816               	.LM155:
 1817               	/* prologue: frame size=0 */
 1818 063c 1F92      		push __zero_reg__
 1819 063e 0F92      		push __tmp_reg__
 1820 0640 0FB6      		in __tmp_reg__,__SREG__
 1821 0642 0F92      		push __tmp_reg__
 1822 0644 1124      		clr __zero_reg__
 1823 0646 2F93      		push r18
 1824 0648 3F93      		push r19
 1825 064a 4F93      		push r20
 1826 064c 5F93      		push r21
 1827 064e 6F93      		push r22
 1828 0650 7F93      		push r23
 1829 0652 8F93      		push r24
 1830 0654 9F93      		push r25
 1831 0656 AF93      		push r26
 1832 0658 BF93      		push r27
 1833 065a EF93      		push r30
 1834 065c FF93      		push r31
 1835               	/* prologue end (size=17) */
 462:timer.c       **** 	// if a user function is defined, execute it
 463:timer.c       **** 	if(TimerIntFunc[TIMER1INPUTCAPTURE_INT])
 1837               	.LM156:
 1838 065e 8091 0000 		lds r24,TimerIntFunc+8
 1839 0662 9091 0000 		lds r25,(TimerIntFunc+8)+1
 1840 0666 892B      		or r24,r25
 1841 0668 29F0      		breq .L85
 464:timer.c       **** 		TimerIntFunc[TIMER1INPUTCAPTURE_INT]();
 1843               	.LM157:
 1844 066a E091 0000 		lds r30,TimerIntFunc+8
 1845 066e F091 0000 		lds r31,(TimerIntFunc+8)+1
 1846 0672 0995      		icall
 1847               	.L85:
 1848               	/* epilogue: frame size=0 */
 1849 0674 FF91      		pop r31
 1850 0676 EF91      		pop r30
 1851 0678 BF91      		pop r27
 1852 067a AF91      		pop r26
 1853 067c 9F91      		pop r25
 1854 067e 8F91      		pop r24
 1855 0680 7F91      		pop r23
 1856 0682 6F91      		pop r22
 1857 0684 5F91      		pop r21
 1858 0686 4F91      		pop r20
 1859 0688 3F91      		pop r19
 1860 068a 2F91      		pop r18
 1861 068c 0F90      		pop __tmp_reg__
 1862 068e 0FBE      		out __SREG__,__tmp_reg__
 1863 0690 0F90      		pop __tmp_reg__
 1864 0692 1F90      		pop __zero_reg__
 1865 0694 1895      		reti
 1866               	/* epilogue end (size=17) */
 1867               	/* function __vector_6 size 45 (11) */
 1869               	.Lscope39:
 1872               	.global	__vector_4
 1874               	__vector_4:
 465:timer.c       **** }
 466:timer.c       **** 
 467:timer.c       **** //! Interrupt handler for OutputCompare2 match (OC2) interrupt
 468:timer.c       **** TIMER_INTERRUPT_HANDLER(SIG_OUTPUT_COMPARE2)
 469:timer.c       **** {
 1876               	.LM158:
 1877               	/* prologue: frame size=0 */
 1878 0696 1F92      		push __zero_reg__
 1879 0698 0F92      		push __tmp_reg__
 1880 069a 0FB6      		in __tmp_reg__,__SREG__
 1881 069c 0F92      		push __tmp_reg__
 1882 069e 1124      		clr __zero_reg__
 1883 06a0 2F93      		push r18
 1884 06a2 3F93      		push r19
 1885 06a4 4F93      		push r20
 1886 06a6 5F93      		push r21
 1887 06a8 6F93      		push r22
 1888 06aa 7F93      		push r23
 1889 06ac 8F93      		push r24
 1890 06ae 9F93      		push r25
 1891 06b0 AF93      		push r26
 1892 06b2 BF93      		push r27
 1893 06b4 EF93      		push r30
 1894 06b6 FF93      		push r31
 1895               	/* prologue end (size=17) */
 470:timer.c       **** 	// if a user function is defined, execute it
 471:timer.c       **** 	if(TimerIntFunc[TIMER2OUTCOMPARE_INT])
 1897               	.LM159:
 1898 06b8 8091 0000 		lds r24,TimerIntFunc+12
 1899 06bc 9091 0000 		lds r25,(TimerIntFunc+12)+1
 1900 06c0 892B      		or r24,r25
 1901 06c2 29F0      		breq .L87
 472:timer.c       **** 		TimerIntFunc[TIMER2OUTCOMPARE_INT]();
 1903               	.LM160:
 1904 06c4 E091 0000 		lds r30,TimerIntFunc+12
 1905 06c8 F091 0000 		lds r31,(TimerIntFunc+12)+1
 1906 06cc 0995      		icall
 1907               	.L87:
 1908               	/* epilogue: frame size=0 */
 1909 06ce FF91      		pop r31
 1910 06d0 EF91      		pop r30
 1911 06d2 BF91      		pop r27
 1912 06d4 AF91      		pop r26
 1913 06d6 9F91      		pop r25
 1914 06d8 8F91      		pop r24
 1915 06da 7F91      		pop r23
 1916 06dc 6F91      		pop r22
 1917 06de 5F91      		pop r21
 1918 06e0 4F91      		pop r20
 1919 06e2 3F91      		pop r19
 1920 06e4 2F91      		pop r18
 1921 06e6 0F90      		pop __tmp_reg__
 1922 06e8 0FBE      		out __SREG__,__tmp_reg__
 1923 06ea 0F90      		pop __tmp_reg__
 1924 06ec 1F90      		pop __zero_reg__
 1925 06ee 1895      		reti
 1926               	/* epilogue end (size=17) */
 1927               	/* function __vector_4 size 45 (11) */
 1929               	.Lscope40:
 1932               	.global	servoInit
 1934               	servoInit:
 1936               	.Ltext3:
   1:servo.c       **** /*! \file servo.c \brief Interrupt-driven RC Servo function library. */
   2:servo.c       **** //*****************************************************************************
   3:servo.c       **** //
   4:servo.c       **** // File Name	: 'servo.c'
   5:servo.c       **** // Title		: Interrupt-driven RC Servo function library
   6:servo.c       **** // Author		: Pascal Stang - Copyright (C) 2002
   7:servo.c       **** // Created		: 7/31/2002
   8:servo.c       **** // Revised		: 8/02/2002
   9:servo.c       **** // Version		: 1.0
  10:servo.c       **** // Target MCU	: Atmel AVR Series
  11:servo.c       **** // Editor Tabs	: 4
  12:servo.c       **** //
  13:servo.c       **** // This code is distributed under the GNU Public License
  14:servo.c       **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
  15:servo.c       **** //
  16:servo.c       **** //*****************************************************************************
  17:servo.c       **** 
  18:servo.c       **** #ifndef WIN32
  19:servo.c       **** 	#include <avr/io.h>
  20:servo.c       **** #endif
  21:servo.c       **** 
  22:servo.c       **** #include "servo.h"
  23:servo.c       **** 
  24:servo.c       **** // Program ROM constants
  25:servo.c       **** 
  26:servo.c       **** // Global variables
  27:servo.c       **** // servo channel registers
  28:servo.c       **** u16 ServoPosTics;
  29:servo.c       **** u16 ServoPeriodTics;
  30:servo.c       **** u08 ServoChannel;
  31:servo.c       **** ServoChannelType ServoChannels[SERVO_NUM_CHANNELS];
  32:servo.c       **** 
  33:servo.c       **** // functions
  34:servo.c       **** 
  35:servo.c       **** //! initializes software PWM system
  36:servo.c       **** void servoInit(void)
  37:servo.c       **** {
 1938               	.LM161:
 1939               	/* prologue: frame size=0 */
 1940               	/* prologue end (size=0) */
  38:servo.c       **** 	u08 channel;
  39:servo.c       **** 	// disble the timer1 output compare A interrupt
  40:servo.c       **** 	cbi(TIMSK, OCIE1A);
 1942               	.LM162:
 1943 06f0 89B7      		in r24,89-0x20
 1944 06f2 8F7E      		andi r24,lo8(-17)
 1945 06f4 89BF      		out 89-0x20,r24
  41:servo.c       **** 	// set the prescaler for timer1
  42:servo.c       **** 	timer1SetPrescaler(TIMER_CLK_DIV256);
 1947               	.LM163:
 1948 06f6 84E0      		ldi r24,lo8(4)
 1949 06f8 0E94 0000 		call timer1SetPrescaler
  43:servo.c       **** 	// attach the software PWM service routine to timer1 output compare A
  44:servo.c       **** 	timerAttach(TIMER1OUTCOMPAREA_INT, servoService);
 1951               	.LM164:
 1952 06fc 60E0      		ldi r22,lo8(pm(servoService))
 1953 06fe 70E0      		ldi r23,hi8(pm(servoService))
 1954 0700 82E0      		ldi r24,lo8(2)
 1955 0702 0E94 0000 		call timerAttach
 1956 0706 A2E2      		ldi r26,lo8(34)
 1957 0708 B0E0      		ldi r27,hi8(34)
 1958 070a 55E1      		ldi r21,lo8(21)
 1959 070c 61E0      		ldi r22,lo8(1)
 1960 070e 70E0      		ldi r23,hi8(1)
 1961 0710 E0E0      		ldi r30,lo8(ServoChannels)
 1962 0712 F0E0      		ldi r31,hi8(ServoChannels)
 1963 0714 20E0      		ldi r18,lo8(0)
 1964 0716 30E0      		ldi r19,hi8(0)
 1965 0718 44E0      		ldi r20,lo8(4)
 1966               	.L93:
  45:servo.c       **** 	// enable and clear channels
  46:servo.c       **** 	for(channel=0; channel<SERVO_NUM_CHANNELS; channel++)
  47:servo.c       **** 	{
  48:servo.c       **** 		// set minimum position as default
  49:servo.c       **** 		ServoChannels[channel].duty = SERVO_MIN;
 1968               	.LM165:
 1969 071a B383      		std Z+3,r27
 1970 071c A283      		std Z+2,r26
  50:servo.c       **** 		// set default port and pins assignments
  51:servo.c       **** 		ServoChannels[channel].port = _SFR_IO_ADDR(SERVO_DEFAULT_PORT);
 1972               	.LM166:
 1973 071e 5083      		st Z,r21
  52:servo.c       **** 		//ServoChannels[channel].port = (unsigned char)&SERVO_DEFAULT_PORT;
  53:servo.c       **** 		ServoChannels[channel].pin = (1<<channel);
 1975               	.LM167:
 1976 0720 CB01      		movw r24,r22
 1977 0722 022E      		mov r0,r18
 1978 0724 02C0      		rjmp 2f
 1979 0726 880F      	1:	lsl r24
 1980 0728 991F      		rol r25
 1981 072a 0A94      	2:	dec r0
 1982 072c E2F7      		brpl 1b
 1983 072e 8183      		std Z+1,r24
 1985               	.LM168:
 1986 0730 4150      		subi r20,lo8(-(-1))
 1987 0732 2F5F      		subi r18,lo8(-(1))
 1988 0734 3F4F      		sbci r19,hi8(-(1))
 1989 0736 3496      		adiw r30,4
 1990 0738 47FF      		sbrs r20,7
 1991 073a EFCF      		rjmp .L93
  54:servo.c       **** 		// set channel pin to output
  55:servo.c       **** 		// THIS IS OBSOLETED BY THE DYNAMIC CHANNEL TO PORT,PIN ASSIGNMENTS
  56:servo.c       **** 		//outb(SERVODDR, inb(SERVODDR) | (1<<channel));
  57:servo.c       **** 	}
  58:servo.c       **** 	// set PosTics
  59:servo.c       **** 	ServoPosTics = 0;
 1993               	.LM169:
 1994 073c 1092 0000 		sts (ServoPosTics)+1,__zero_reg__
 1995 0740 1092 0000 		sts ServoPosTics,__zero_reg__
  60:servo.c       **** 	// set PeriodTics
  61:servo.c       **** 	ServoPeriodTics = SERVO_MAX*9;
 1997               	.LM170:
 1998 0744 8AED      		ldi r24,lo8(1242)
 1999 0746 94E0      		ldi r25,hi8(1242)
 2000 0748 9093 0000 		sts (ServoPeriodTics)+1,r25
 2001 074c 8093 0000 		sts ServoPeriodTics,r24
  62:servo.c       **** 	// set initial interrupt time
  63:servo.c       **** 	u16 OCValue;
  64:servo.c       **** 	// read in current value of output compare register OCR1A
  65:servo.c       **** 	OCValue =  inb(OCR1AL);		// read low byte of OCR1A
 2003               	.LM171:
 2004 0750 2AB5      		in r18,74-0x20
  66:servo.c       **** 	OCValue += inb(OCR1AH)<<8;	// read high byte of OCR1A
 2006               	.LM172:
 2007 0752 8BB5      		in r24,75-0x20
 2008 0754 9927      		clr r25
 2009 0756 982F      		mov r25,r24
 2010 0758 8827      		clr r24
 2011 075a 820F      		add r24,r18
 2012 075c 911D      		adc r25,__zero_reg__
  67:servo.c       **** 	// increment OCR1A value by nextTics
  68:servo.c       **** 	OCValue += ServoPeriodTics; 
 2014               	.LM173:
 2015 075e 8652      		subi r24,lo8(-(1242))
 2016 0760 9B4F      		sbci r25,hi8(-(1242))
  69:servo.c       **** 	// set future output compare time to this new value
  70:servo.c       **** 	outb(OCR1AH, (OCValue>>8));			// write high byte
 2018               	.LM174:
 2019 0762 292F      		mov r18,r25
 2020 0764 3327      		clr r19
 2021 0766 2BBD      		out 75-0x20,r18
  71:servo.c       **** 	outb(OCR1AL, (OCValue & 0x00FF));	// write low byte
 2023               	.LM175:
 2024 0768 8ABD      		out 74-0x20,r24
  72:servo.c       **** 	// enable the timer1 output compare A interrupt
  73:servo.c       **** 	sbi(TIMSK, OCIE1A);
 2026               	.LM176:
 2027 076a 89B7      		in r24,89-0x20
 2028 076c 8061      		ori r24,lo8(16)
 2029 076e 89BF      		out 89-0x20,r24
 2030               	/* epilogue: frame size=0 */
 2031 0770 0895      		ret
 2032               	/* epilogue end (size=1) */
 2033               	/* function servoInit size 65 (64) */
 2039               	.Lscope41:
 2042               	.global	servoOff
 2044               	servoOff:
  74:servo.c       **** }
  75:servo.c       **** 
  76:servo.c       **** //! turns off software PWM system
  77:servo.c       **** void servoOff(void)
  78:servo.c       **** {
 2046               	.LM177:
 2047               	/* prologue: frame size=0 */
 2048               	/* prologue end (size=0) */
  79:servo.c       **** 	// disable the timer1 output compare A interrupt
  80:servo.c       **** 	cbi(TIMSK, OCIE1A);
 2050               	.LM178:
 2051 0772 89B7      		in r24,89-0x20
 2052 0774 8F7E      		andi r24,lo8(-17)
 2053 0776 89BF      		out 89-0x20,r24
  81:servo.c       **** 	// detach the service routine
  82:servo.c       **** 	timerDetach(TIMER1OUTCOMPAREA_INT);
 2055               	.LM179:
 2056 0778 82E0      		ldi r24,lo8(2)
 2057 077a 0E94 0000 		call timerDetach
 2058               	/* epilogue: frame size=0 */
 2059 077e 0895      		ret
 2060               	/* epilogue end (size=1) */
 2061               	/* function servoOff size 7 (6) */
 2063               	.Lscope42:
 2069               	.global	servoSetChannelIO
 2071               	servoSetChannelIO:
  83:servo.c       **** }
  84:servo.c       **** 
  85:servo.c       **** //! set port and I/O pin for channel
  86:servo.c       **** void servoSetChannelIO(u08 channel, u08 port, u08 pin)
  87:servo.c       **** {
 2073               	.LM180:
 2074               	/* prologue: frame size=0 */
 2075               	/* prologue end (size=0) */
 2076 0780 242F      		mov r18,r20
  88:servo.c       **** 	ServoChannels[channel].port = port;
 2078               	.LM181:
 2079 0782 E82F      		mov r30,r24
 2080 0784 FF27      		clr r31
 2081 0786 EE0F      		lsl r30
 2082 0788 FF1F      		rol r31
 2083 078a EE0F      		lsl r30
 2084 078c FF1F      		rol r31
 2085 078e E050      		subi r30,lo8(-(ServoChannels))
 2086 0790 F040      		sbci r31,hi8(-(ServoChannels))
 2087 0792 6083      		st Z,r22
  89:servo.c       **** 	ServoChannels[channel].pin = (1<<(pin&0x07));
 2089               	.LM182:
 2090 0794 3327      		clr r19
 2091 0796 2770      		andi r18,lo8(7)
 2092 0798 3070      		andi r19,hi8(7)
 2093 079a 81E0      		ldi r24,lo8(1)
 2094 079c 90E0      		ldi r25,hi8(1)
 2095 079e 02C0      		rjmp 2f
 2096 07a0 880F      	1:	lsl r24
 2097 07a2 991F      		rol r25
 2098 07a4 2A95      	2:	dec r18
 2099 07a6 E2F7      		brpl 1b
 2100 07a8 8183      		std Z+1,r24
 2101               	/* epilogue: frame size=0 */
 2102 07aa 0895      		ret
 2103               	/* epilogue end (size=1) */
 2104               	/* function servoSetChannelIO size 23 (22) */
 2106               	.Lscope43:
 2111               	.global	servoSetPositionRaw
 2113               	servoSetPositionRaw:
  90:servo.c       **** }
  91:servo.c       **** 
  92:servo.c       **** //! set servo position on channel
  93:servo.c       **** void servoSetPosition(u08 channel, u08 position)
  94:servo.c       **** {
  95:servo.c       **** 	// input should be between 0 and SERVO_POSITION_MAX
  96:servo.c       **** 	u16 pos_scaled;
  97:servo.c       **** 	// calculate scaled position
  98:servo.c       **** 	pos_scaled = ((u16)position*(SERVO_MAX-SERVO_MIN)/SERVO_POSITION_MAX)+SERVO_MIN;
  99:servo.c       **** 	// set position
 100:servo.c       **** 	servoSetPositionRaw(channel, pos_scaled);
 101:servo.c       **** }
 102:servo.c       **** 
 103:servo.c       **** //! get servo position on channel
 104:servo.c       **** u08 servoGetPosition(u08 channel)
 105:servo.c       **** {
 106:servo.c       **** 	return (u08)( ((servoGetPositionRaw(channel)-SERVO_MIN)*SERVO_POSITION_MAX)/(SERVO_MAX-SERVO_MIN) 
 107:servo.c       **** }
 108:servo.c       **** 
 109:servo.c       **** //! set servo position on channel (raw unscaled format)
 110:servo.c       **** void servoSetPositionRaw(u08 channel, u16 position)
 111:servo.c       **** {
 2115               	.LM183:
 2116               	/* prologue: frame size=0 */
 2117               	/* prologue end (size=0) */
 112:servo.c       **** 	// bind to limits
 113:servo.c       **** 	position = MAX(position, SERVO_MIN);
 2119               	.LM184:
 2120 07ac 6232      		cpi r22,34
 2121 07ae 7105      		cpc r23,__zero_reg__
 2122 07b0 10F4      		brsh .L99
 2124               	.LM185:
 2125 07b2 62E2      		ldi r22,lo8(34)
 2126 07b4 70E0      		ldi r23,hi8(34)
 2127               	.L99:
 114:servo.c       **** 	position = MIN(position, SERVO_MAX);
 2129               	.LM186:
 2130 07b6 6B38      		cpi r22,139
 2131 07b8 7105      		cpc r23,__zero_reg__
 2132 07ba 10F0      		brlo .L100
 2133 07bc 6AE8      		ldi r22,lo8(138)
 2134 07be 70E0      		ldi r23,hi8(138)
 2135               	.L100:
 115:servo.c       **** 	// set position
 116:servo.c       **** 	ServoChannels[channel].duty = position;
 2137               	.LM187:
 2138 07c0 E82F      		mov r30,r24
 2139 07c2 FF27      		clr r31
 2140 07c4 EE0F      		lsl r30
 2141 07c6 FF1F      		rol r31
 2142 07c8 EE0F      		lsl r30
 2143 07ca FF1F      		rol r31
 2144 07cc E050      		subi r30,lo8(-(ServoChannels))
 2145 07ce F040      		sbci r31,hi8(-(ServoChannels))
 2146 07d0 7383      		std Z+3,r23
 2147 07d2 6283      		std Z+2,r22
 2148               	/* epilogue: frame size=0 */
 2149 07d4 0895      		ret
 2150               	/* epilogue end (size=1) */
 2151               	/* function servoSetPositionRaw size 21 (20) */
 2153               	.Lscope44:
 2158               	.global	servoSetPosition
 2160               	servoSetPosition:
 2162               	.LM188:
 2163               	/* prologue: frame size=0 */
 2164               	/* prologue end (size=0) */
 2165 07d6 282F      		mov r18,r24
 2167               	.LM189:
 2168 07d8 88E6      		ldi r24,lo8(104)
 2169 07da 689F      		mul r22,r24
 2170 07dc C001      		movw r24,r0
 2171 07de 1124      		clr r1
 2172 07e0 6FEF      		ldi r22,lo8(255)
 2173 07e2 70E0      		ldi r23,hi8(255)
 2174 07e4 0E94 0000 		call __udivmodhi4
 2175 07e8 CB01      		movw r24,r22
 2176 07ea 8296      		adiw r24,34
 2178               	.LM190:
 2179 07ec BC01      		movw r22,r24
 2180 07ee 822F      		mov r24,r18
 2181 07f0 0E94 0000 		call servoSetPositionRaw
 2182               	/* epilogue: frame size=0 */
 2183 07f4 0895      		ret
 2184               	/* epilogue end (size=1) */
 2185               	/* function servoSetPosition size 16 (15) */
 2187               	.Lscope45:
 2191               	.global	servoGetPositionRaw
 2193               	servoGetPositionRaw:
 117:servo.c       **** }
 118:servo.c       **** 
 119:servo.c       **** //! get servo position on channel (raw unscaled format)
 120:servo.c       **** u16 servoGetPositionRaw(u08 channel)
 121:servo.c       **** {
 2195               	.LM191:
 2196               	/* prologue: frame size=0 */
 2197               	/* prologue end (size=0) */
 122:servo.c       **** 	return ServoChannels[channel].duty;
 2199               	.LM192:
 2200 07f6 E82F      		mov r30,r24
 2201 07f8 FF27      		clr r31
 2202 07fa EE0F      		lsl r30
 2203 07fc FF1F      		rol r31
 2204 07fe EE0F      		lsl r30
 2205 0800 FF1F      		rol r31
 2206 0802 E050      		subi r30,lo8(-(ServoChannels))
 2207 0804 F040      		sbci r31,hi8(-(ServoChannels))
 123:servo.c       **** }
 2209               	.LM193:
 2210 0806 8281      		ldd r24,Z+2
 2211 0808 9381      		ldd r25,Z+3
 2212               	/* epilogue: frame size=0 */
 2213 080a 0895      		ret
 2214               	/* epilogue end (size=1) */
 2215               	/* function servoGetPositionRaw size 11 (10) */
 2217               	.Lscope46:
 2221               	.global	servoGetPosition
 2223               	servoGetPosition:
 2225               	.LM194:
 2226               	/* prologue: frame size=0 */
 2227               	/* prologue end (size=0) */
 2229               	.LM195:
 2230 080c 0E94 0000 		call servoGetPositionRaw
 2231 0810 2FEF      		ldi r18,lo8(255)
 2232 0812 30E0      		ldi r19,hi8(255)
 2233 0814 829F      		mul r24,r18
 2234 0816 A001      		movw r20,r0
 2235 0818 839F      		mul r24,r19
 2236 081a 500D      		add r21,r0
 2237 081c 929F      		mul r25,r18
 2238 081e 500D      		add r21,r0
 2239 0820 1124      		clr r1
 2240 0822 CA01      		movw r24,r20
 2241 0824 8E5D      		subi r24,lo8(-(-8670))
 2242 0826 9142      		sbci r25,hi8(-(-8670))
 2243 0828 68E6      		ldi r22,lo8(104)
 2244 082a 70E0      		ldi r23,hi8(104)
 2245 082c 0E94 0000 		call __udivmodhi4
 2246 0830 CB01      		movw r24,r22
 2248               	.LM196:
 2249 0832 9927      		clr r25
 2250               	/* epilogue: frame size=0 */
 2251 0834 0895      		ret
 2252               	/* epilogue end (size=1) */
 2253               	/* function servoGetPosition size 21 (20) */
 2255               	.Lscope47:
 2258               	.global	servoService
 2260               	servoService:
 124:servo.c       **** 
 125:servo.c       **** void servoService(void)
 126:servo.c       **** {
 2262               	.LM197:
 2263               	/* prologue: frame size=0 */
 2264 0836 CF93      		push r28
 2265 0838 DF93      		push r29
 2266               	/* prologue end (size=2) */
 127:servo.c       **** 	u16 nextTics;
 128:servo.c       **** 
 129:servo.c       **** 	if(ServoChannel < SERVO_NUM_CHANNELS)
 2268               	.LM198:
 2269 083a E091 0000 		lds r30,ServoChannel
 2270 083e E530      		cpi r30,lo8(5)
 2271 0840 80F4      		brsh .L105
 130:servo.c       **** 	{
 131:servo.c       **** 		// turn off current channel
 132:servo.c       **** 		outb(_SFR_IO8(ServoChannels[ServoChannel].port), inb(_SFR_IO8(ServoChannels[ServoChannel].port)) 
 2273               	.LM199:
 2274 0842 FF27      		clr r31
 2275 0844 EE0F      		lsl r30
 2276 0846 FF1F      		rol r31
 2277 0848 EE0F      		lsl r30
 2278 084a FF1F      		rol r31
 2279 084c E050      		subi r30,lo8(-(ServoChannels))
 2280 084e F040      		sbci r31,hi8(-(ServoChannels))
 2281 0850 8081      		ld r24,Z
 2282 0852 A82F      		mov r26,r24
 2283 0854 BB27      		clr r27
 2284 0856 9181      		ldd r25,Z+1
 2285 0858 9095      		com r25
 2286 085a ED01      		movw r28,r26
 2287 085c 88A1      		ldd r24,Y+32
 2288 085e 8923      		and r24,r25
 2289 0860 88A3      		std Y+32,r24
 2290               	.L105:
 133:servo.c       **** 	}
 134:servo.c       **** 	
 135:servo.c       **** 	// next channel
 136:servo.c       **** 	ServoChannel++;
 2292               	.LM200:
 2293 0862 8091 0000 		lds r24,ServoChannel
 2294 0866 8F5F      		subi r24,lo8(-(1))
 2295 0868 8093 0000 		sts ServoChannel,r24
 137:servo.c       **** 
 138:servo.c       **** 	if(ServoChannel != SERVO_NUM_CHANNELS)
 2297               	.LM201:
 2298 086c 8530      		cpi r24,lo8(5)
 2299 086e 19F1      		breq .L106
 139:servo.c       **** 	{
 140:servo.c       **** 		// loop to channel 0 if needed
 141:servo.c       **** 		if(ServoChannel > SERVO_NUM_CHANNELS)	ServoChannel = 0;
 2301               	.LM202:
 2302 0870 8630      		cpi r24,lo8(6)
 2303 0872 10F0      		brlo .L107
 2304 0874 1092 0000 		sts ServoChannel,__zero_reg__
 2305               	.L107:
 142:servo.c       **** 		// turn on new channel
 143:servo.c       **** 		outb(_SFR_IO8(ServoChannels[ServoChannel].port), inb(_SFR_IO8(ServoChannels[ServoChannel].port)) 
 2307               	.LM203:
 2308 0878 8091 0000 		lds r24,ServoChannel
 2309 087c E82F      		mov r30,r24
 2310 087e FF27      		clr r31
 2311 0880 EE0F      		lsl r30
 2312 0882 FF1F      		rol r31
 2313 0884 EE0F      		lsl r30
 2314 0886 FF1F      		rol r31
 2315 0888 E050      		subi r30,lo8(-(ServoChannels))
 2316 088a F040      		sbci r31,hi8(-(ServoChannels))
 2317 088c 8081      		ld r24,Z
 2318 088e A82F      		mov r26,r24
 2319 0890 BB27      		clr r27
 2320 0892 ED01      		movw r28,r26
 2321 0894 88A1      		ldd r24,Y+32
 2322 0896 9181      		ldd r25,Z+1
 2323 0898 892B      		or r24,r25
 2324 089a 88A3      		std Y+32,r24
 144:servo.c       **** 		// schedule turn off time
 145:servo.c       **** 		nextTics = ServoChannels[ServoChannel].duty;
 2326               	.LM204:
 2327 089c 8091 0000 		lds r24,ServoChannel
 2328 08a0 E82F      		mov r30,r24
 2329 08a2 FF27      		clr r31
 2330 08a4 EE0F      		lsl r30
 2331 08a6 FF1F      		rol r31
 2332 08a8 EE0F      		lsl r30
 2333 08aa FF1F      		rol r31
 2334 08ac E050      		subi r30,lo8(-(ServoChannels))
 2335 08ae F040      		sbci r31,hi8(-(ServoChannels))
 2336 08b0 4281      		ldd r20,Z+2
 2337 08b2 5381      		ldd r21,Z+3
 2338 08b4 0AC0      		rjmp .L108
 2339               	.L106:
 146:servo.c       **** 	}
 147:servo.c       **** 	else //(Channel == SERVO_NUM_CHANNELS)
 148:servo.c       **** 	{
 149:servo.c       **** 		// ***we could save time by precalculating this
 150:servo.c       **** 		// schedule end-of-period
 151:servo.c       **** 		nextTics = ServoPeriodTics-ServoPosTics;
 2341               	.LM205:
 2342 08b6 4091 0000 		lds r20,ServoPeriodTics
 2343 08ba 5091 0000 		lds r21,(ServoPeriodTics)+1
 2344 08be 8091 0000 		lds r24,ServoPosTics
 2345 08c2 9091 0000 		lds r25,(ServoPosTics)+1
 2346 08c6 481B      		sub r20,r24
 2347 08c8 590B      		sbc r21,r25
 2348               	.L108:
 152:servo.c       **** 	}
 153:servo.c       **** 
 154:servo.c       **** 	// schedule next interrupt
 155:servo.c       **** 	u16 OCValue;
 156:servo.c       **** 	// read in current value of output compare register OCR1A
 157:servo.c       **** 	OCValue =  inb(OCR1AL);		// read low byte of OCR1A
 2350               	.LM206:
 2351 08ca 2AB5      		in r18,74-0x20
 158:servo.c       **** 	OCValue += inb(OCR1AH)<<8;	// read high byte of OCR1A
 2353               	.LM207:
 2354 08cc 8BB5      		in r24,75-0x20
 2355 08ce 9927      		clr r25
 2356 08d0 982F      		mov r25,r24
 2357 08d2 8827      		clr r24
 2358 08d4 820F      		add r24,r18
 2359 08d6 911D      		adc r25,__zero_reg__
 159:servo.c       **** 	// increment OCR1A value by nextTics
 160:servo.c       **** 	OCValue += nextTics;
 2361               	.LM208:
 2362 08d8 840F      		add r24,r20
 2363 08da 951F      		adc r25,r21
 161:servo.c       **** //	OCR1A+=nextTics;
 162:servo.c       **** 	// set future output compare time to this new value
 163:servo.c       **** 	outb(OCR1AH, (OCValue>>8));			// write high byte
 2365               	.LM209:
 2366 08dc 292F      		mov r18,r25
 2367 08de 3327      		clr r19
 2368 08e0 2BBD      		out 75-0x20,r18
 164:servo.c       **** 	outb(OCR1AL, (OCValue & 0x00FF));	// write low byte
 2370               	.LM210:
 2371 08e2 8ABD      		out 74-0x20,r24
 165:servo.c       **** 	// set our new tic position
 166:servo.c       **** 	ServoPosTics += nextTics;
 2373               	.LM211:
 2374 08e4 8091 0000 		lds r24,ServoPosTics
 2375 08e8 9091 0000 		lds r25,(ServoPosTics)+1
 2376 08ec 840F      		add r24,r20
 2377 08ee 951F      		adc r25,r21
 2378 08f0 9093 0000 		sts (ServoPosTics)+1,r25
 2379 08f4 8093 0000 		sts ServoPosTics,r24
 167:servo.c       **** 	if(ServoPosTics >= ServoPeriodTics) ServoPosTics = 0;
 2381               	.LM212:
 2382 08f8 2091 0000 		lds r18,ServoPeriodTics
 2383 08fc 3091 0000 		lds r19,(ServoPeriodTics)+1
 2384 0900 8217      		cp r24,r18
 2385 0902 9307      		cpc r25,r19
 2386 0904 20F0      		brlo .L104
 2387 0906 1092 0000 		sts (ServoPosTics)+1,__zero_reg__
 2388 090a 1092 0000 		sts ServoPosTics,__zero_reg__
 2389               	.L104:
 2390               	/* epilogue: frame size=0 */
 2391 090e DF91      		pop r29
 2392 0910 CF91      		pop r28
 2393 0912 0895      		ret
 2394               	/* epilogue end (size=3) */
 2395               	/* function servoService size 111 (106) */
 2401               	.Lscope48:
 2404               	.global	__vector_11
 2406               	__vector_11:
 2408               	.Ltext4:
   1:SerialExample.c **** /*
   2:SerialExample.c ****     Serial interface Demo for AvrXFifo's
   3:SerialExample.c **** 
   4:SerialExample.c ****     Also illustrates the use of Frame based variables
   5:SerialExample.c ****     at the top level tasking (switched from NAKED to
   6:SerialExample.c ****     NORETURN function attribute)
   7:SerialExample.c **** 
   8:SerialExample.c **** 	When linked with simple serialio there is no buffering
   9:SerialExample.c **** 	of charactors so only two charactors can be received
  10:SerialExample.c **** 	during the delay (Hardware buffering within the USART).
  11:SerialExample.c **** 
  12:SerialExample.c **** 	When linked with the buffered IO up to 31 (or whatever
  13:SerialExample.c **** 	the buffer size - 1 is) charactors can be received while
  14:SerialExample.c **** 	delaying.
  15:SerialExample.c **** */
  16:SerialExample.c **** #include <avr/io.h>
  17:SerialExample.c **** #include <avr/pgmspace.h>
  18:SerialExample.c **** #include <avrx-signal.h>
  19:SerialExample.c **** #include <stdio.h>
  20:SerialExample.c **** #include "avrx.h"
  21:SerialExample.c **** #include <avr/signal.h>	// include "signal" names (interrupt names)
  22:SerialExample.c **** #include <avr/interrupt.h>	// include interrupt support
  23:SerialExample.c **** #include <stdlib.h>
  24:SerialExample.c **** 
  25:SerialExample.c **** // Uncomment this to override "AvrXSerialIo.h and just use one channel
  26:SerialExample.c **** //#define USART_CHANNELS (1<1)	// 0 - USART0, 1 = USART1
  27:SerialExample.c **** 
  28:SerialExample.c **** #include "AvrXSerialIo.h"
  29:SerialExample.c **** 
  30:SerialExample.c **** #include "parserconf.h"
  31:SerialExample.c **** #include "parser.h"
  32:SerialExample.c **** #include "parser.c"
  33:SerialExample.c **** 
  34:SerialExample.c **** 
  35:SerialExample.c **** // global AVRLIB defines
  36:SerialExample.c **** #include <../../avrlibdefs.h>
  37:SerialExample.c **** // global AVRLIB types definitions
  38:SerialExample.c **** #include <../../avrlibtypes.h>
  39:SerialExample.c **** #include "global.h"
  40:SerialExample.c **** 
  41:SerialExample.c **** #include "timer.h"
  42:SerialExample.c **** #include "timer.c"
  43:SerialExample.c **** #include "servo.h"
  44:SerialExample.c **** #include "servo.c"
  45:SerialExample.c **** /*
  46:SerialExample.c **** enum
  47:SerialExample.c **** {
  48:SerialExample.c **** 	FALSE,
  49:SerialExample.c **** 	TRUE
  50:SerialExample.c **** };
  51:SerialExample.c **** 
  52:SerialExample.c **** typedef unsigned char BOOL;
  53:SerialExample.c **** */
  54:SerialExample.c **** 
  55:SerialExample.c **** // Peripheral initialization
  56:SerialExample.c **** 
  57:SerialExample.c **** #define TCNT0_INIT (0xFF-CPUCLK/256/TICKRATE)
  58:SerialExample.c **** #define LEFT_SERVO_CHAN 	0
  59:SerialExample.c **** #define RIGHT_SERVO_CHAN 	1
  60:SerialExample.c **** #define THROTTLE_SERVO_CHAN 2
  61:SerialExample.c **** #define CAM_PAN_SERVO_CHAN  3
  62:SerialExample.c **** #define CAM_TILT_SERVO_CHAN 4
  63:SerialExample.c **** 
  64:SerialExample.c **** #define DEBUG 1
  65:SerialExample.c **** 
  66:SerialExample.c **** void setLeftServo(void);
  67:SerialExample.c **** void setRightServo(void);
  68:SerialExample.c **** void setThrottleServo(void);
  69:SerialExample.c **** void setCamPanServo(void);
  70:SerialExample.c **** void setCamTiltServo(void);
  71:SerialExample.c **** 
  72:SerialExample.c **** int leftServoPos = 50;		//0 seems to be beyond its reach
  73:SerialExample.c **** int rightServoPos;
  74:SerialExample.c **** int throttleServoPos;
  75:SerialExample.c **** int camPanServoPos;
  76:SerialExample.c **** int camTiltServoPos;
  77:SerialExample.c **** 
  78:SerialExample.c **** //long funcAParam;
  79:SerialExample.c **** //long funcBParam;
  80:SerialExample.c **** 
  81:SerialExample.c **** 
  82:SerialExample.c **** /*
  83:SerialExample.c ****  Timer 0 Overflow Interrupt Handler
  84:SerialExample.c **** 
  85:SerialExample.c ****  Prototypical Interrupt handler:
  86:SerialExample.c ****  . Switch to kernel context
  87:SerialExample.c ****  . handle interrupt
  88:SerialExample.c ****  . switch back to interrupted context.
  89:SerialExample.c ****  */
  90:SerialExample.c **** 
  91:SerialExample.c **** AVRX_SIGINT(SIG_OVERFLOW0)
  92:SerialExample.c **** {
 2410               	.LM213:
 2411               	/* prologue: frame size=0 */
 2412               	/* prologue: naked */
 2413               	/* prologue end (size=0) */
  93:SerialExample.c ****     IntProlog();                // Switch to kernel stack/context
 2415               	.LM214:
 2416 0914 0E94 0000 		call IntProlog
  94:SerialExample.c ****     TCNT0 += TCNT0_INIT;		// Add to pre-load to account for any missed clocks
 2418               	.LM215:
 2419 0918 82B7      		in r24,82-0x20
 2420 091a 8F53      		subi r24,lo8(-(-63))
 2421 091c 82BF      		out 82-0x20,r24
  95:SerialExample.c ****     AvrXTimerHandler();         // Call Time queue manager
 2423               	.LM216:
 2424 091e 0E94 0000 		call AvrXTimerHandler
  96:SerialExample.c ****     Epilog();                   // Return to tasks
 2426               	.LM217:
 2427 0922 0E94 0000 		call Epilog
 2428               	/* epilogue: frame size=0 */
 2429               	/* epilogue: naked */
 2430               	/* epilogue end (size=0) */
 2431               	/* function __vector_11 size 9 (9) */
 2433               	.Lscope49:
 2438               	.global	myputs
 2440               	myputs:
  97:SerialExample.c **** }
  98:SerialExample.c **** 
  99:SerialExample.c **** 
 100:SerialExample.c **** 
 101:SerialExample.c **** // Super simple string printers...
 102:SerialExample.c **** 
 103:SerialExample.c **** // PutString from RAM
 104:SerialExample.c **** void myputs(int (*putch)(char), const uint8_t * psz)
 105:SerialExample.c **** {
 2442               	.LM218:
 2443               	/* prologue: frame size=0 */
 2444 0926 0F93      		push r16
 2445 0928 1F93      		push r17
 2446 092a CF93      		push r28
 2447 092c DF93      		push r29
 2448               	/* prologue end (size=4) */
 2449 092e 8C01      		movw r16,r24
 2450 0930 EB01      		movw r28,r22
 106:SerialExample.c **** 	while (*psz != 0)
 107:SerialExample.c **** 		(*putch)(*psz++);
 2452               	.LM219:
 2453 0932 8881      		ld r24,Y
 2454 0934 8823      		tst r24
 2455 0936 31F0      		breq .L116
 2456               	.L114:
 2458               	.LM220:
 2459 0938 8991      		ld r24,Y+
 2460 093a F801      		movw r30,r16
 2461 093c 0995      		icall
 2462 093e 8881      		ld r24,Y
 2463 0940 8823      		tst r24
 2464 0942 D1F7      		brne .L114
 2465               	.L116:
 2466               	/* epilogue: frame size=0 */
 2467 0944 DF91      		pop r29
 2468 0946 CF91      		pop r28
 2469 0948 1F91      		pop r17
 2470 094a 0F91      		pop r16
 2471 094c 0895      		ret
 2472               	/* epilogue end (size=5) */
 2473               	/* function myputs size 20 (11) */
 2475               	.Lscope50:
 2480               	.global	myputs_P
 2482               	myputs_P:
 108:SerialExample.c **** }
 109:SerialExample.c **** 
 110:SerialExample.c **** // PutString from FLASH
 111:SerialExample.c **** void myputs_P(int (*putch)(char), const uint8_t * psz)
 112:SerialExample.c **** {
 2484               	.LM221:
 2485               	/* prologue: frame size=0 */
 2486 094e 0F93      		push r16
 2487 0950 1F93      		push r17
 2488 0952 CF93      		push r28
 2489 0954 DF93      		push r29
 2490               	/* prologue end (size=4) */
 2491 0956 8C01      		movw r16,r24
 2492 0958 EB01      		movw r28,r22
 2493               	.LBB5:
 113:SerialExample.c **** 	while (__LPM(psz) != 0)
 114:SerialExample.c **** 		(*putch)(__LPM(psz++));
 2495               	.LM222:
 2496 095a FB01      		movw r30,r22
 2497               	/* #APP */
 2498 095c 8491      		lpm r24, Z
 2499               		
 2500               	/* #NOAPP */
 2501               	.LBE5:
 2502 095e 8823      		tst r24
 2503 0960 49F0      		breq .L122
 2504               	.L120:
 2505               	.LBB6:
 2507               	.LM223:
 2508 0962 FE01      		movw r30,r28
 2509 0964 2196      		adiw r28,1
 2510               	/* #APP */
 2511 0966 8491      		lpm r24, Z
 2512               		
 2513               	/* #NOAPP */
 2514               	.LBE6:
 2515 0968 F801      		movw r30,r16
 2516 096a 0995      		icall
 2517               	.LBB7:
 2518 096c FE01      		movw r30,r28
 2519               	/* #APP */
 2520 096e 8491      		lpm r24, Z
 2521               		
 2522               	/* #NOAPP */
 2523               	.LBE7:
 2524 0970 8823      		tst r24
 2525 0972 B9F7      		brne .L120
 2526               	.L122:
 2527               	/* epilogue: frame size=0 */
 2528 0974 DF91      		pop r29
 2529 0976 CF91      		pop r28
 2530 0978 1F91      		pop r17
 2531 097a 0F91      		pop r16
 2532 097c 0895      		ret
 2533               	/* epilogue end (size=5) */
 2534               	/* function myputs_P size 33 (24) */
 2545               	.Lscope51:
 2547               		.section	.progmem.data
 2550               	__c.20:
 2551 005b 3100      		.string	"1"
 2552               		.text
 2554               	.global	getUAVStatus
 2556               	getUAVStatus:
 115:SerialExample.c **** }
 116:SerialExample.c **** 
 117:SerialExample.c **** //#if (USART_CHANNELS & CHANNEL_0)
 118:SerialExample.c **** 
 119:SerialExample.c **** //tell the ground station I am OK by sending a "1" 10 times a second
 120:SerialExample.c **** AVRX_GCC_TASKDEF(getUAVStatus, 76, 4)
 121:SerialExample.c **** {	
 2558               	.LM224:
 2559               	/* prologue: frame size=6 */
 2560 097e CF93      		push r28
 2561 0980 DF93      		push r29
 2562 0982 CDB7      		in r28,__SP_L__
 2563 0984 DEB7      		in r29,__SP_H__
 2564 0986 2697      		sbiw r28,6
 2565 0988 0FB6      		in __tmp_reg__,__SREG__
 2566 098a F894      		cli
 2567 098c DEBF      		out __SP_H__,r29
 2568 098e 0FBE      		out __SREG__,__tmp_reg__
 2569 0990 CDBF      		out __SP_L__,r28
 2570               	/* prologue end (size=10) */
 2571               	.L124:
 122:SerialExample.c **** 	TimerControlBlock timer;
 123:SerialExample.c **** 	
 124:SerialExample.c **** 	while(1)
 125:SerialExample.c **** 	{
 126:SerialExample.c **** 		printf_P(PSTR("1"));
 2573               	.LM225:
 2574 0992 80E0      		ldi r24,lo8(__c.20)
 2575 0994 90E0      		ldi r25,hi8(__c.20)
 2576 0996 9F93      		push r25
 2577 0998 8F93      		push r24
 2578 099a 0E94 0000 		call printf_P
 127:SerialExample.c **** 		putchar('\r');
 2580               	.LM226:
 2581 099e 6091 0000 		lds r22,__iob+2
 2582 09a2 7091 0000 		lds r23,(__iob+2)+1
 2583 09a6 8DE0      		ldi r24,lo8(13)
 2584 09a8 90E0      		ldi r25,hi8(13)
 2585 09aa 0E94 0000 		call fputc
 128:SerialExample.c **** 		if (DEBUG) putchar('\n');
 2587               	.LM227:
 2588 09ae 6091 0000 		lds r22,__iob+2
 2589 09b2 7091 0000 		lds r23,(__iob+2)+1
 2590 09b6 8AE0      		ldi r24,lo8(10)
 2591 09b8 90E0      		ldi r25,hi8(10)
 2592 09ba 0E94 0000 		call fputc
 2593 09be 0F90      		pop __tmp_reg__
 2594 09c0 0F90      		pop __tmp_reg__
 129:SerialExample.c **** 		AvrXDelay(&timer, 100);
 2596               	.LM228:
 2597 09c2 64E6      		ldi r22,lo8(100)
 2598 09c4 70E0      		ldi r23,hi8(100)
 2599 09c6 CE01      		movw r24,r28
 2600 09c8 0196      		adiw r24,1
 2601 09ca 0E94 0000 		call AvrXDelay
 2602 09ce E1CF      		rjmp .L124
 2603               	/* epilogue: frame size=6 */
 2604               	/* epilogue: noreturn */
 2605               	/* epilogue end (size=0) */
 2606               	/* function getUAVStatus size 41 (31) */
 2611               	.Lscope52:
 2613               		.section	.progmem.data
 2616               	__c.18:
 2617 005d 6320 2564 		.string	"c %d"
 2617      00
 2620               	__c.19:
 2621 0062 6320 2564 		.string	"c %d"
 2621      00
 2622               		.text
 2624               	.global	getCompassHeading
 2626               	getCompassHeading:
 130:SerialExample.c **** 	}
 131:SerialExample.c **** }
 132:SerialExample.c **** 
 133:SerialExample.c **** AVRX_GCC_TASKDEF(getCompassHeading, 76, 4)
 134:SerialExample.c **** {
 2628               	.LM229:
 2629               	/* prologue: frame size=6 */
 2630 09d0 CF93      		push r28
 2631 09d2 DF93      		push r29
 2632 09d4 CDB7      		in r28,__SP_L__
 2633 09d6 DEB7      		in r29,__SP_H__
 2634 09d8 2697      		sbiw r28,6
 2635 09da 0FB6      		in __tmp_reg__,__SREG__
 2636 09dc F894      		cli
 2637 09de DEBF      		out __SP_H__,r29
 2638 09e0 0FBE      		out __SREG__,__tmp_reg__
 2639 09e2 CDBF      		out __SP_L__,r28
 2640               	/* prologue end (size=10) */
 2641               	.L128:
 2642               	.LBB8:
 135:SerialExample.c **** 	TimerControlBlock timer;
 136:SerialExample.c **** 	
 137:SerialExample.c **** 	while(1)
 138:SerialExample.c **** 	{
 139:SerialExample.c **** 		int c = 0;
 2644               	.LM230:
 2645 09e4 00E0      		ldi r16,lo8(0)
 2646 09e6 10E0      		ldi r17,hi8(0)
 2647               	.L133:
 140:SerialExample.c **** 		
 141:SerialExample.c **** 		while (c<360)
 142:SerialExample.c **** 		{	printf_P(PSTR("c %d"), c/3);   	// c/3 evaluates to an int, even it c is not a multiple of
 2649               	.LM231:
 2650 09e8 C801      		movw r24,r16
 2651 09ea 63E0      		ldi r22,lo8(3)
 2652 09ec 70E0      		ldi r23,hi8(3)
 2653 09ee 0E94 0000 		call __divmodhi4
 2654 09f2 7F93      		push r23
 2655 09f4 6F93      		push r22
 2656 09f6 80E0      		ldi r24,lo8(__c.18)
 2657 09f8 90E0      		ldi r25,hi8(__c.18)
 2658 09fa 9F93      		push r25
 2659 09fc 8F93      		push r24
 2660 09fe 0E94 0000 		call printf_P
 143:SerialExample.c **** 			putchar('\r');					// 3.  This way, the heading is sent as ONE char instead of
 2662               	.LM232:
 2663 0a02 6091 0000 		lds r22,__iob+2
 2664 0a06 7091 0000 		lds r23,(__iob+2)+1
 2665 0a0a 8DE0      		ldi r24,lo8(13)
 2666 0a0c 90E0      		ldi r25,hi8(13)
 2667 0a0e 0E94 0000 		call fputc
 144:SerialExample.c **** 			if (DEBUG) putchar('\n');		// one, two, or three.
 2669               	.LM233:
 2670 0a12 6091 0000 		lds r22,__iob+2
 2671 0a16 7091 0000 		lds r23,(__iob+2)+1
 2672 0a1a 8AE0      		ldi r24,lo8(10)
 2673 0a1c 90E0      		ldi r25,hi8(10)
 2674 0a1e 0E94 0000 		call fputc
 2675 0a22 0F90      		pop __tmp_reg__
 2676 0a24 0F90      		pop __tmp_reg__
 2677 0a26 0F90      		pop __tmp_reg__
 2678 0a28 0F90      		pop __tmp_reg__
 145:SerialExample.c **** 			c++;
 2680               	.LM234:
 2681 0a2a 0F5F      		subi r16,lo8(-(1))
 2682 0a2c 1F4F      		sbci r17,hi8(-(1))
 146:SerialExample.c **** 			AvrXDelay(&timer, 1000);
 2684               	.LM235:
 2685 0a2e 68EE      		ldi r22,lo8(1000)
 2686 0a30 73E0      		ldi r23,hi8(1000)
 2687 0a32 CE01      		movw r24,r28
 2688 0a34 0196      		adiw r24,1
 2689 0a36 0E94 0000 		call AvrXDelay
 2690 0a3a 81E0      		ldi r24,hi8(360)
 2691 0a3c 0836      		cpi r16,lo8(360)
 2692 0a3e 1807      		cpc r17,r24
 2693 0a40 9CF2      		brlt .L133
 2694 0a42 08E6      		ldi r16,lo8(360)
 2695 0a44 11E0      		ldi r17,hi8(360)
 2696               	.L137:
 147:SerialExample.c **** 		}
 148:SerialExample.c **** 		while (c>0)
 149:SerialExample.c **** 		{	printf_P(PSTR("c %d"), c/3);
 2698               	.LM236:
 2699 0a46 C801      		movw r24,r16
 2700 0a48 63E0      		ldi r22,lo8(3)
 2701 0a4a 70E0      		ldi r23,hi8(3)
 2702 0a4c 0E94 0000 		call __divmodhi4
 2703 0a50 7F93      		push r23
 2704 0a52 6F93      		push r22
 2705 0a54 80E0      		ldi r24,lo8(__c.19)
 2706 0a56 90E0      		ldi r25,hi8(__c.19)
 2707 0a58 9F93      		push r25
 2708 0a5a 8F93      		push r24
 2709 0a5c 0E94 0000 		call printf_P
 150:SerialExample.c **** 			putchar('\r');
 2711               	.LM237:
 2712 0a60 6091 0000 		lds r22,__iob+2
 2713 0a64 7091 0000 		lds r23,(__iob+2)+1
 2714 0a68 8DE0      		ldi r24,lo8(13)
 2715 0a6a 90E0      		ldi r25,hi8(13)
 2716 0a6c 0E94 0000 		call fputc
 151:SerialExample.c **** 			if (DEBUG) putchar('\n');		//We only want a newline if we are debugging on
 2718               	.LM238:
 2719 0a70 6091 0000 		lds r22,__iob+2
 2720 0a74 7091 0000 		lds r23,(__iob+2)+1
 2721 0a78 8AE0      		ldi r24,lo8(10)
 2722 0a7a 90E0      		ldi r25,hi8(10)
 2723 0a7c 0E94 0000 		call fputc
 2724 0a80 0F90      		pop __tmp_reg__
 2725 0a82 0F90      		pop __tmp_reg__
 2726 0a84 0F90      		pop __tmp_reg__
 2727 0a86 0F90      		pop __tmp_reg__
 152:SerialExample.c **** 			c--;							//a terminal.  Otherwise, we are communicating with
 2729               	.LM239:
 2730 0a88 0150      		subi r16,lo8(-(-1))
 2731 0a8a 1040      		sbci r17,hi8(-(-1))
 153:SerialExample.c **** 			AvrXDelay(&timer, 1000);		//the ground station and it should not be sent.
 2733               	.LM240:
 2734 0a8c 68EE      		ldi r22,lo8(1000)
 2735 0a8e 73E0      		ldi r23,hi8(1000)
 2736 0a90 CE01      		movw r24,r28
 2737 0a92 0196      		adiw r24,1
 2738 0a94 0E94 0000 		call AvrXDelay
 2739 0a98 1016      		cp __zero_reg__,r16
 2740 0a9a 1106      		cpc __zero_reg__,r17
 2741 0a9c A4F2      		brlt .L137
 2742               	.LBE8:
 2743 0a9e A2CF      		rjmp .L128
 2744               	/* epilogue: frame size=6 */
 2745               	/* epilogue: noreturn */
 2746               	/* epilogue end (size=0) */
 2747               	/* function getCompassHeading size 104 (94) */
 2755               	.Lscope53:
 2757               		.section	.progmem.data
 2760               	__c.16:
 2761 0067 7320 2564 		.string	"s %d"
 2761      00
 2764               	__c.17:
 2765 006c 7320 2564 		.string	"s %d"
 2765      00
 2766               		.text
 2768               	.global	getAirspeed
 2770               	getAirspeed:
 154:SerialExample.c **** 		}
 155:SerialExample.c **** 	}
 156:SerialExample.c **** }
 157:SerialExample.c **** 
 158:SerialExample.c **** AVRX_GCC_TASKDEF(getAirspeed, 76, 4)
 159:SerialExample.c **** {
 2772               	.LM241:
 2773               	/* prologue: frame size=6 */
 2774 0aa0 CF93      		push r28
 2775 0aa2 DF93      		push r29
 2776 0aa4 CDB7      		in r28,__SP_L__
 2777 0aa6 DEB7      		in r29,__SP_H__
 2778 0aa8 2697      		sbiw r28,6
 2779 0aaa 0FB6      		in __tmp_reg__,__SREG__
 2780 0aac F894      		cli
 2781 0aae DEBF      		out __SP_H__,r29
 2782 0ab0 0FBE      		out __SREG__,__tmp_reg__
 2783 0ab2 CDBF      		out __SP_L__,r28
 2784               	/* prologue end (size=10) */
 160:SerialExample.c **** 	TimerControlBlock timer;
 161:SerialExample.c **** 	int s = 0;
 2786               	.LM242:
 2787 0ab4 00E0      		ldi r16,lo8(0)
 2788 0ab6 10E0      		ldi r17,hi8(0)
 2789               	.L160:
 162:SerialExample.c **** 	
 163:SerialExample.c **** 	while(1)
 164:SerialExample.c **** 	{	
 165:SerialExample.c **** 		while (s<25)
 166:SerialExample.c **** 		{	printf_P(PSTR("s %d"), s);   
 167:SerialExample.c **** 			putchar('\r');
 168:SerialExample.c **** 			if (DEBUG) putchar('\n');	
 169:SerialExample.c **** 			s++;							
 170:SerialExample.c **** 			AvrXDelay(&timer, 1000);
 2791               	.LM243:
 2792 0ab8 0931      		cpi r16,25
 2793 0aba 1105      		cpc r17,__zero_reg__
 2794 0abc 2CF5      		brge .L154
 2796               	.LM244:
 2797 0abe 1F93      		push r17
 2798 0ac0 0F93      		push r16
 2799 0ac2 80E0      		ldi r24,lo8(__c.16)
 2800 0ac4 90E0      		ldi r25,hi8(__c.16)
 2801 0ac6 9F93      		push r25
 2802 0ac8 8F93      		push r24
 2803 0aca 0E94 0000 		call printf_P
 2805               	.LM245:
 2806 0ace 6091 0000 		lds r22,__iob+2
 2807 0ad2 7091 0000 		lds r23,(__iob+2)+1
 2808 0ad6 8DE0      		ldi r24,lo8(13)
 2809 0ad8 90E0      		ldi r25,hi8(13)
 2810 0ada 0E94 0000 		call fputc
 2812               	.LM246:
 2813 0ade 6091 0000 		lds r22,__iob+2
 2814 0ae2 7091 0000 		lds r23,(__iob+2)+1
 2815 0ae6 8AE0      		ldi r24,lo8(10)
 2816 0ae8 90E0      		ldi r25,hi8(10)
 2817 0aea 0E94 0000 		call fputc
 2818 0aee 0F90      		pop __tmp_reg__
 2819 0af0 0F90      		pop __tmp_reg__
 2820 0af2 0F90      		pop __tmp_reg__
 2821 0af4 0F90      		pop __tmp_reg__
 2823               	.LM247:
 2824 0af6 0F5F      		subi r16,lo8(-(1))
 2825 0af8 1F4F      		sbci r17,hi8(-(1))
 2827               	.LM248:
 2828 0afa 68EE      		ldi r22,lo8(1000)
 2829 0afc 73E0      		ldi r23,hi8(1000)
 2830 0afe CE01      		movw r24,r28
 2831 0b00 0196      		adiw r24,1
 2832 0b02 0E94 0000 		call AvrXDelay
 2833 0b06 D8CF      		rjmp .L160
 2834               	.L154:
 171:SerialExample.c **** 		}
 172:SerialExample.c **** 		while (s>15)
 173:SerialExample.c **** 		{	printf_P(PSTR("s %d"), s);
 174:SerialExample.c **** 			putchar('\r');
 175:SerialExample.c **** 			if (DEBUG) putchar('\n');
 176:SerialExample.c **** 			s--;
 177:SerialExample.c **** 			AvrXDelay(&timer, 1000);
 2836               	.LM249:
 2837 0b08 0031      		cpi r16,16
 2838 0b0a 1105      		cpc r17,__zero_reg__
 2839 0b0c ACF2      		brlt .L160
 2841               	.LM250:
 2842 0b0e 1F93      		push r17
 2843 0b10 0F93      		push r16
 2844 0b12 80E0      		ldi r24,lo8(__c.17)
 2845 0b14 90E0      		ldi r25,hi8(__c.17)
 2846 0b16 9F93      		push r25
 2847 0b18 8F93      		push r24
 2848 0b1a 0E94 0000 		call printf_P
 2850               	.LM251:
 2851 0b1e 6091 0000 		lds r22,__iob+2
 2852 0b22 7091 0000 		lds r23,(__iob+2)+1
 2853 0b26 8DE0      		ldi r24,lo8(13)
 2854 0b28 90E0      		ldi r25,hi8(13)
 2855 0b2a 0E94 0000 		call fputc
 2857               	.LM252:
 2858 0b2e 6091 0000 		lds r22,__iob+2
 2859 0b32 7091 0000 		lds r23,(__iob+2)+1
 2860 0b36 8AE0      		ldi r24,lo8(10)
 2861 0b38 90E0      		ldi r25,hi8(10)
 2862 0b3a 0E94 0000 		call fputc
 2863 0b3e 0F90      		pop __tmp_reg__
 2864 0b40 0F90      		pop __tmp_reg__
 2865 0b42 0F90      		pop __tmp_reg__
 2866 0b44 0F90      		pop __tmp_reg__
 2868               	.LM253:
 2869 0b46 0150      		subi r16,lo8(-(-1))
 2870 0b48 1040      		sbci r17,hi8(-(-1))
 2872               	.LM254:
 2873 0b4a 68EE      		ldi r22,lo8(1000)
 2874 0b4c 73E0      		ldi r23,hi8(1000)
 2875 0b4e CE01      		movw r24,r28
 2876 0b50 0196      		adiw r24,1
 2877 0b52 0E94 0000 		call AvrXDelay
 2878 0b56 D8CF      		rjmp .L154
 2879               	/* epilogue: frame size=6 */
 2880               	/* epilogue: noreturn */
 2881               	/* epilogue end (size=0) */
 2882               	/* function getAirspeed size 92 (82) */
 2888               	.Lscope54:
 2890               		.section	.progmem.data
 2893               	__c.14:
 2894 0071 6720 2564 		.string	"g %d"
 2894      00
 2897               	__c.15:
 2898 0076 6720 2564 		.string	"g %d"
 2898      00
 2899               		.text
 2901               	.global	getGroundspeed
 2903               	getGroundspeed:
 178:SerialExample.c **** 		}
 179:SerialExample.c **** 	}
 180:SerialExample.c **** }
 181:SerialExample.c **** 
 182:SerialExample.c **** AVRX_GCC_TASKDEF(getGroundspeed, 76, 4)
 183:SerialExample.c **** {
 2905               	.LM255:
 2906               	/* prologue: frame size=6 */
 2907 0b58 CF93      		push r28
 2908 0b5a DF93      		push r29
 2909 0b5c CDB7      		in r28,__SP_L__
 2910 0b5e DEB7      		in r29,__SP_H__
 2911 0b60 2697      		sbiw r28,6
 2912 0b62 0FB6      		in __tmp_reg__,__SREG__
 2913 0b64 F894      		cli
 2914 0b66 DEBF      		out __SP_H__,r29
 2915 0b68 0FBE      		out __SREG__,__tmp_reg__
 2916 0b6a CDBF      		out __SP_L__,r28
 2917               	/* prologue end (size=10) */
 184:SerialExample.c **** 	TimerControlBlock timer;
 185:SerialExample.c **** 	int g = 18;
 2919               	.LM256:
 2920 0b6c 02E1      		ldi r16,lo8(18)
 2921 0b6e 10E0      		ldi r17,hi8(18)
 2922               	.L179:
 186:SerialExample.c **** 	
 187:SerialExample.c **** 	while(1)
 188:SerialExample.c **** 	{	
 189:SerialExample.c **** 		while (g<22)
 190:SerialExample.c **** 		{	printf_P(PSTR("g %d"), g);   
 191:SerialExample.c **** 			putchar('\r');
 192:SerialExample.c **** 			if (DEBUG) putchar('\n');	
 193:SerialExample.c **** 			g++;							
 194:SerialExample.c **** 			AvrXDelay(&timer, 30*1000);
 2924               	.LM257:
 2925 0b70 0631      		cpi r16,22
 2926 0b72 1105      		cpc r17,__zero_reg__
 2927 0b74 2CF5      		brge .L173
 2929               	.LM258:
 2930 0b76 1F93      		push r17
 2931 0b78 0F93      		push r16
 2932 0b7a 80E0      		ldi r24,lo8(__c.14)
 2933 0b7c 90E0      		ldi r25,hi8(__c.14)
 2934 0b7e 9F93      		push r25
 2935 0b80 8F93      		push r24
 2936 0b82 0E94 0000 		call printf_P
 2938               	.LM259:
 2939 0b86 6091 0000 		lds r22,__iob+2
 2940 0b8a 7091 0000 		lds r23,(__iob+2)+1
 2941 0b8e 8DE0      		ldi r24,lo8(13)
 2942 0b90 90E0      		ldi r25,hi8(13)
 2943 0b92 0E94 0000 		call fputc
 2945               	.LM260:
 2946 0b96 6091 0000 		lds r22,__iob+2
 2947 0b9a 7091 0000 		lds r23,(__iob+2)+1
 2948 0b9e 8AE0      		ldi r24,lo8(10)
 2949 0ba0 90E0      		ldi r25,hi8(10)
 2950 0ba2 0E94 0000 		call fputc
 2951 0ba6 0F90      		pop __tmp_reg__
 2952 0ba8 0F90      		pop __tmp_reg__
 2953 0baa 0F90      		pop __tmp_reg__
 2954 0bac 0F90      		pop __tmp_reg__
 2956               	.LM261:
 2957 0bae 0F5F      		subi r16,lo8(-(1))
 2958 0bb0 1F4F      		sbci r17,hi8(-(1))
 2960               	.LM262:
 2961 0bb2 60E3      		ldi r22,lo8(30000)
 2962 0bb4 75E7      		ldi r23,hi8(30000)
 2963 0bb6 CE01      		movw r24,r28
 2964 0bb8 0196      		adiw r24,1
 2965 0bba 0E94 0000 		call AvrXDelay
 2966 0bbe D8CF      		rjmp .L179
 2967               	.L173:
 195:SerialExample.c **** 		}
 196:SerialExample.c **** 		while (g>18)
 197:SerialExample.c **** 		{	printf_P(PSTR("g %d"), g);
 198:SerialExample.c **** 			putchar('\r');
 199:SerialExample.c **** 			if (DEBUG) putchar('\n');
 200:SerialExample.c **** 			g--;
 201:SerialExample.c **** 			AvrXDelay(&timer, 30*1000);
 2969               	.LM263:
 2970 0bc0 0331      		cpi r16,19
 2971 0bc2 1105      		cpc r17,__zero_reg__
 2972 0bc4 ACF2      		brlt .L179
 2974               	.LM264:
 2975 0bc6 1F93      		push r17
 2976 0bc8 0F93      		push r16
 2977 0bca 80E0      		ldi r24,lo8(__c.15)
 2978 0bcc 90E0      		ldi r25,hi8(__c.15)
 2979 0bce 9F93      		push r25
 2980 0bd0 8F93      		push r24
 2981 0bd2 0E94 0000 		call printf_P
 2983               	.LM265:
 2984 0bd6 6091 0000 		lds r22,__iob+2
 2985 0bda 7091 0000 		lds r23,(__iob+2)+1
 2986 0bde 8DE0      		ldi r24,lo8(13)
 2987 0be0 90E0      		ldi r25,hi8(13)
 2988 0be2 0E94 0000 		call fputc
 2990               	.LM266:
 2991 0be6 6091 0000 		lds r22,__iob+2
 2992 0bea 7091 0000 		lds r23,(__iob+2)+1
 2993 0bee 8AE0      		ldi r24,lo8(10)
 2994 0bf0 90E0      		ldi r25,hi8(10)
 2995 0bf2 0E94 0000 		call fputc
 2996 0bf6 0F90      		pop __tmp_reg__
 2997 0bf8 0F90      		pop __tmp_reg__
 2998 0bfa 0F90      		pop __tmp_reg__
 2999 0bfc 0F90      		pop __tmp_reg__
 3001               	.LM267:
 3002 0bfe 0150      		subi r16,lo8(-(-1))
 3003 0c00 1040      		sbci r17,hi8(-(-1))
 3005               	.LM268:
 3006 0c02 60E3      		ldi r22,lo8(30000)
 3007 0c04 75E7      		ldi r23,hi8(30000)
 3008 0c06 CE01      		movw r24,r28
 3009 0c08 0196      		adiw r24,1
 3010 0c0a 0E94 0000 		call AvrXDelay
 3011 0c0e D8CF      		rjmp .L173
 3012               	/* epilogue: frame size=6 */
 3013               	/* epilogue: noreturn */
 3014               	/* epilogue end (size=0) */
 3015               	/* function getGroundspeed size 92 (82) */
 3021               	.Lscope55:
 3023               		.section	.progmem.data
 3026               	__c.8:
 3027 007b 6120 3036 		.string	"a 067.5759E"
 3027      372E 3537 
 3027      3539 4500 
 3030               	__c.9:
 3031 0087 6F20 3839 		.string	"o 89.12345N"
 3031      2E31 3233 
 3031      3435 4E00 
 3034               	__c.10:
 3035 0093 7A20 2564 		.string	"z %d"
 3035      00
 3038               	__c.11:
 3039 0098 6120 3130 		.string	"a 101.4512W"
 3039      312E 3435 
 3039      3132 5700 
 3042               	__c.12:
 3043 00a4 6F20 3035 		.string	"o 05.98765S"
 3043      2E39 3837 
 3043      3635 5300 
 3046               	__c.13:
 3047 00b0 7A20 2564 		.string	"z %d"
 3047      00
 3048               		.text
 3050               	.global	getGPSData
 3052               	getGPSData:
 202:SerialExample.c **** 		}
 203:SerialExample.c **** 	}
 204:SerialExample.c **** }
 205:SerialExample.c **** 
 206:SerialExample.c **** AVRX_GCC_TASKDEF(getGPSData, 76, 4)
 207:SerialExample.c **** {
 3054               	.LM269:
 3055               	/* prologue: frame size=6 */
 3056 0c10 CF93      		push r28
 3057 0c12 DF93      		push r29
 3058 0c14 CDB7      		in r28,__SP_L__
 3059 0c16 DEB7      		in r29,__SP_H__
 3060 0c18 2697      		sbiw r28,6
 3061 0c1a 0FB6      		in __tmp_reg__,__SREG__
 3062 0c1c F894      		cli
 3063 0c1e DEBF      		out __SP_H__,r29
 3064 0c20 0FBE      		out __SREG__,__tmp_reg__
 3065 0c22 CDBF      		out __SP_L__,r28
 3066               	/* prologue end (size=10) */
 208:SerialExample.c **** 	TimerControlBlock timer;
 209:SerialExample.c **** 	int z = 0;
 3068               	.LM270:
 3069 0c24 00E0      		ldi r16,lo8(0)
 3070 0c26 10E0      		ldi r17,hi8(0)
 3071               	.L181:
 210:SerialExample.c **** 	
 211:SerialExample.c **** 	while(1)
 212:SerialExample.c **** 	{	
 213:SerialExample.c **** 		// Since latitude and longitude cannot be expressed as simple integers,
 214:SerialExample.c **** 		// we cannot fake the measurements by cycling through some numbers.
 215:SerialExample.c **** 		printf_P(PSTR("a 067.5759E"));   
 3073               	.LM271:
 3074 0c28 80E0      		ldi r24,lo8(__c.8)
 3075 0c2a 90E0      		ldi r25,hi8(__c.8)
 3076 0c2c 9F93      		push r25
 3077 0c2e 8F93      		push r24
 3078 0c30 0E94 0000 		call printf_P
 216:SerialExample.c **** 		putchar('\r');
 3080               	.LM272:
 3081 0c34 6091 0000 		lds r22,__iob+2
 3082 0c38 7091 0000 		lds r23,(__iob+2)+1
 3083 0c3c 8DE0      		ldi r24,lo8(13)
 3084 0c3e 90E0      		ldi r25,hi8(13)
 3085 0c40 0E94 0000 		call fputc
 217:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3087               	.LM273:
 3088 0c44 6091 0000 		lds r22,__iob+2
 3089 0c48 7091 0000 		lds r23,(__iob+2)+1
 3090 0c4c 8AE0      		ldi r24,lo8(10)
 3091 0c4e 90E0      		ldi r25,hi8(10)
 3092 0c50 0E94 0000 		call fputc
 3093 0c54 0F90      		pop __tmp_reg__
 3094 0c56 0F90      		pop __tmp_reg__
 218:SerialExample.c **** 		
 219:SerialExample.c **** 		printf_P(PSTR("o 89.12345N"));	
 3096               	.LM274:
 3097 0c58 80E0      		ldi r24,lo8(__c.9)
 3098 0c5a 90E0      		ldi r25,hi8(__c.9)
 3099 0c5c 9F93      		push r25
 3100 0c5e 8F93      		push r24
 3101 0c60 0E94 0000 		call printf_P
 220:SerialExample.c **** 		putchar('\r');
 3103               	.LM275:
 3104 0c64 6091 0000 		lds r22,__iob+2
 3105 0c68 7091 0000 		lds r23,(__iob+2)+1
 3106 0c6c 8DE0      		ldi r24,lo8(13)
 3107 0c6e 90E0      		ldi r25,hi8(13)
 3108 0c70 0E94 0000 		call fputc
 221:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3110               	.LM276:
 3111 0c74 6091 0000 		lds r22,__iob+2
 3112 0c78 7091 0000 		lds r23,(__iob+2)+1
 3113 0c7c 8AE0      		ldi r24,lo8(10)
 3114 0c7e 90E0      		ldi r25,hi8(10)
 3115 0c80 0E94 0000 		call fputc
 3116 0c84 0F90      		pop __tmp_reg__
 3117 0c86 0F90      		pop __tmp_reg__
 222:SerialExample.c **** 		
 223:SerialExample.c **** 		printf_P(PSTR("z %d"), z);
 3119               	.LM277:
 3120 0c88 1F93      		push r17
 3121 0c8a 0F93      		push r16
 3122 0c8c 80E0      		ldi r24,lo8(__c.10)
 3123 0c8e 90E0      		ldi r25,hi8(__c.10)
 3124 0c90 9F93      		push r25
 3125 0c92 8F93      		push r24
 3126 0c94 0E94 0000 		call printf_P
 224:SerialExample.c **** 		putchar('\r');
 3128               	.LM278:
 3129 0c98 6091 0000 		lds r22,__iob+2
 3130 0c9c 7091 0000 		lds r23,(__iob+2)+1
 3131 0ca0 8DE0      		ldi r24,lo8(13)
 3132 0ca2 90E0      		ldi r25,hi8(13)
 3133 0ca4 0E94 0000 		call fputc
 225:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3135               	.LM279:
 3136 0ca8 6091 0000 		lds r22,__iob+2
 3137 0cac 7091 0000 		lds r23,(__iob+2)+1
 3138 0cb0 8AE0      		ldi r24,lo8(10)
 3139 0cb2 90E0      		ldi r25,hi8(10)
 3140 0cb4 0E94 0000 		call fputc
 3141 0cb8 0F90      		pop __tmp_reg__
 3142 0cba 0F90      		pop __tmp_reg__
 3143 0cbc 0F90      		pop __tmp_reg__
 3144 0cbe 0F90      		pop __tmp_reg__
 226:SerialExample.c **** 		
 227:SerialExample.c **** 		if (z<100) z++;
 3146               	.LM280:
 3147 0cc0 0436      		cpi r16,100
 3148 0cc2 1105      		cpc r17,__zero_reg__
 3149 0cc4 14F4      		brge .L186
 3150 0cc6 0F5F      		subi r16,lo8(-(1))
 3151 0cc8 1F4F      		sbci r17,hi8(-(1))
 3152               	.L186:
 228:SerialExample.c **** 		AvrXDelay(&timer, 1000);
 3154               	.LM281:
 3155 0cca 68EE      		ldi r22,lo8(1000)
 3156 0ccc 73E0      		ldi r23,hi8(1000)
 3157 0cce CE01      		movw r24,r28
 3158 0cd0 0196      		adiw r24,1
 3159 0cd2 0E94 0000 		call AvrXDelay
 229:SerialExample.c **** 		
 230:SerialExample.c **** 		
 231:SerialExample.c **** 		
 232:SerialExample.c **** 		printf_P(PSTR("a 101.4512W"));   
 3161               	.LM282:
 3162 0cd6 80E0      		ldi r24,lo8(__c.11)
 3163 0cd8 90E0      		ldi r25,hi8(__c.11)
 3164 0cda 9F93      		push r25
 3165 0cdc 8F93      		push r24
 3166 0cde 0E94 0000 		call printf_P
 233:SerialExample.c **** 		putchar('\r');
 3168               	.LM283:
 3169 0ce2 6091 0000 		lds r22,__iob+2
 3170 0ce6 7091 0000 		lds r23,(__iob+2)+1
 3171 0cea 8DE0      		ldi r24,lo8(13)
 3172 0cec 90E0      		ldi r25,hi8(13)
 3173 0cee 0E94 0000 		call fputc
 234:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3175               	.LM284:
 3176 0cf2 6091 0000 		lds r22,__iob+2
 3177 0cf6 7091 0000 		lds r23,(__iob+2)+1
 3178 0cfa 8AE0      		ldi r24,lo8(10)
 3179 0cfc 90E0      		ldi r25,hi8(10)
 3180 0cfe 0E94 0000 		call fputc
 3181 0d02 0F90      		pop __tmp_reg__
 3182 0d04 0F90      		pop __tmp_reg__
 235:SerialExample.c **** 		
 236:SerialExample.c **** 		printf_P(PSTR("o 05.98765S"));   
 3184               	.LM285:
 3185 0d06 80E0      		ldi r24,lo8(__c.12)
 3186 0d08 90E0      		ldi r25,hi8(__c.12)
 3187 0d0a 9F93      		push r25
 3188 0d0c 8F93      		push r24
 3189 0d0e 0E94 0000 		call printf_P
 237:SerialExample.c **** 		putchar('\r');
 3191               	.LM286:
 3192 0d12 6091 0000 		lds r22,__iob+2
 3193 0d16 7091 0000 		lds r23,(__iob+2)+1
 3194 0d1a 8DE0      		ldi r24,lo8(13)
 3195 0d1c 90E0      		ldi r25,hi8(13)
 3196 0d1e 0E94 0000 		call fputc
 238:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3198               	.LM287:
 3199 0d22 6091 0000 		lds r22,__iob+2
 3200 0d26 7091 0000 		lds r23,(__iob+2)+1
 3201 0d2a 8AE0      		ldi r24,lo8(10)
 3202 0d2c 90E0      		ldi r25,hi8(10)
 3203 0d2e 0E94 0000 		call fputc
 3204 0d32 0F90      		pop __tmp_reg__
 3205 0d34 0F90      		pop __tmp_reg__
 239:SerialExample.c **** 		
 240:SerialExample.c **** 		printf_P(PSTR("z %d"), z);
 3207               	.LM288:
 3208 0d36 1F93      		push r17
 3209 0d38 0F93      		push r16
 3210 0d3a 80E0      		ldi r24,lo8(__c.13)
 3211 0d3c 90E0      		ldi r25,hi8(__c.13)
 3212 0d3e 9F93      		push r25
 3213 0d40 8F93      		push r24
 3214 0d42 0E94 0000 		call printf_P
 241:SerialExample.c **** 		putchar('\r');
 3216               	.LM289:
 3217 0d46 6091 0000 		lds r22,__iob+2
 3218 0d4a 7091 0000 		lds r23,(__iob+2)+1
 3219 0d4e 8DE0      		ldi r24,lo8(13)
 3220 0d50 90E0      		ldi r25,hi8(13)
 3221 0d52 0E94 0000 		call fputc
 242:SerialExample.c **** 		if (DEBUG) putchar('\n');
 3223               	.LM290:
 3224 0d56 6091 0000 		lds r22,__iob+2
 3225 0d5a 7091 0000 		lds r23,(__iob+2)+1
 3226 0d5e 8AE0      		ldi r24,lo8(10)
 3227 0d60 90E0      		ldi r25,hi8(10)
 3228 0d62 0E94 0000 		call fputc
 3229 0d66 0F90      		pop __tmp_reg__
 3230 0d68 0F90      		pop __tmp_reg__
 3231 0d6a 0F90      		pop __tmp_reg__
 3232 0d6c 0F90      		pop __tmp_reg__
 243:SerialExample.c **** 		
 244:SerialExample.c **** 		if (z<100) z++;	
 3234               	.LM291:
 3235 0d6e 0436      		cpi r16,100
 3236 0d70 1105      		cpc r17,__zero_reg__
 3237 0d72 14F4      		brge .L190
 3238 0d74 0F5F      		subi r16,lo8(-(1))
 3239 0d76 1F4F      		sbci r17,hi8(-(1))
 3240               	.L190:
 245:SerialExample.c **** 		AvrXDelay(&timer, 1000);
 3242               	.LM292:
 3243 0d78 68EE      		ldi r22,lo8(1000)
 3244 0d7a 73E0      		ldi r23,hi8(1000)
 3245 0d7c CE01      		movw r24,r28
 3246 0d7e 0196      		adiw r24,1
 3247 0d80 0E94 0000 		call AvrXDelay
 3248 0d84 51CF      		rjmp .L181
 3249               	/* epilogue: frame size=6 */
 3250               	/* epilogue: noreturn */
 3251               	/* epilogue end (size=0) */
 3252               	/* function getGPSData size 187 (177) */
 3258               	.Lscope56:
 3260               		.section	.progmem.data
 3263               	__c.6:
 3264 00b5 6220 2564 		.string	"b %d"
 3264      00
 3267               	__c.7:
 3268 00ba 6620 2564 		.string	"f %d"
 3268      00
 3269               		.text
 3271               	.global	getFuelAndBattery
 3273               	getFuelAndBattery:
 246:SerialExample.c **** 		
 247:SerialExample.c **** 	}		
 248:SerialExample.c **** }
 249:SerialExample.c **** 
 250:SerialExample.c **** AVRX_GCC_TASKDEF(getFuelAndBattery, 76, 4)
 251:SerialExample.c **** {
 3275               	.LM293:
 3276               	/* prologue: frame size=6 */
 3277 0d86 CF93      		push r28
 3278 0d88 DF93      		push r29
 3279 0d8a CDB7      		in r28,__SP_L__
 3280 0d8c DEB7      		in r29,__SP_H__
 3281 0d8e 2697      		sbiw r28,6
 3282 0d90 0FB6      		in __tmp_reg__,__SREG__
 3283 0d92 F894      		cli
 3284 0d94 DEBF      		out __SP_H__,r29
 3285 0d96 0FBE      		out __SREG__,__tmp_reg__
 3286 0d98 CDBF      		out __SP_L__,r28
 3287               	/* prologue end (size=10) */
 252:SerialExample.c **** 	TimerControlBlock timer;
 253:SerialExample.c **** 	int b = 100;
 3289               	.LM294:
 3290 0d9a 04E6      		ldi r16,lo8(100)
 3291 0d9c 10E0      		ldi r17,hi8(100)
 254:SerialExample.c **** 	int f = 100;
 3293               	.LM295:
 3294 0d9e 7801      		movw r14,r16
 3295               	.L192:
 255:SerialExample.c **** 	
 256:SerialExample.c **** 	while(1)
 257:SerialExample.c **** 	{	
 258:SerialExample.c **** 		printf_P(PSTR("b %d"), b);   
 3297               	.LM296:
 3298 0da0 FF92      		push r15
 3299 0da2 EF92      		push r14
 3300 0da4 80E0      		ldi r24,lo8(__c.6)
 3301 0da6 90E0      		ldi r25,hi8(__c.6)
 3302 0da8 9F93      		push r25
 3303 0daa 8F93      		push r24
 3304 0dac 0E94 0000 		call printf_P
 259:SerialExample.c **** 		putchar('\r');
 3306               	.LM297:
 3307 0db0 6091 0000 		lds r22,__iob+2
 3308 0db4 7091 0000 		lds r23,(__iob+2)+1
 3309 0db8 8DE0      		ldi r24,lo8(13)
 3310 0dba 90E0      		ldi r25,hi8(13)
 3311 0dbc 0E94 0000 		call fputc
 260:SerialExample.c **** 		if (DEBUG) putchar('\n');	
 3313               	.LM298:
 3314 0dc0 6091 0000 		lds r22,__iob+2
 3315 0dc4 7091 0000 		lds r23,(__iob+2)+1
 3316 0dc8 8AE0      		ldi r24,lo8(10)
 3317 0dca 90E0      		ldi r25,hi8(10)
 3318 0dcc 0E94 0000 		call fputc
 3319 0dd0 0F90      		pop __tmp_reg__
 3320 0dd2 0F90      		pop __tmp_reg__
 3321 0dd4 0F90      		pop __tmp_reg__
 3322 0dd6 0F90      		pop __tmp_reg__
 261:SerialExample.c **** 		printf_P(PSTR("f %d"), f);
 3324               	.LM299:
 3325 0dd8 1F93      		push r17
 3326 0dda 0F93      		push r16
 3327 0ddc 80E0      		ldi r24,lo8(__c.7)
 3328 0dde 90E0      		ldi r25,hi8(__c.7)
 3329 0de0 9F93      		push r25
 3330 0de2 8F93      		push r24
 3331 0de4 0E94 0000 		call printf_P
 262:SerialExample.c **** 		putchar('\r');
 3333               	.LM300:
 3334 0de8 6091 0000 		lds r22,__iob+2
 3335 0dec 7091 0000 		lds r23,(__iob+2)+1
 3336 0df0 8DE0      		ldi r24,lo8(13)
 3337 0df2 90E0      		ldi r25,hi8(13)
 3338 0df4 0E94 0000 		call fputc
 263:SerialExample.c **** 		if (DEBUG) putchar('\n');							
 3340               	.LM301:
 3341 0df8 6091 0000 		lds r22,__iob+2
 3342 0dfc 7091 0000 		lds r23,(__iob+2)+1
 3343 0e00 8AE0      		ldi r24,lo8(10)
 3344 0e02 90E0      		ldi r25,hi8(10)
 3345 0e04 0E94 0000 		call fputc
 3346 0e08 0F90      		pop __tmp_reg__
 3347 0e0a 0F90      		pop __tmp_reg__
 3348 0e0c 0F90      		pop __tmp_reg__
 3349 0e0e 0F90      		pop __tmp_reg__
 264:SerialExample.c **** 		b--;
 3351               	.LM302:
 3352 0e10 0894      		sec
 3353 0e12 E108      		sbc r14,__zero_reg__
 3354 0e14 F108      		sbc r15,__zero_reg__
 265:SerialExample.c **** 		f--;
 3356               	.LM303:
 3357 0e16 0150      		subi r16,lo8(-(-1))
 3358 0e18 1040      		sbci r17,hi8(-(-1))
 266:SerialExample.c **** 		AvrXDelay(&timer, 30*1000);
 3360               	.LM304:
 3361 0e1a 60E3      		ldi r22,lo8(30000)
 3362 0e1c 75E7      		ldi r23,hi8(30000)
 3363 0e1e CE01      		movw r24,r28
 3364 0e20 0196      		adiw r24,1
 3365 0e22 0E94 0000 		call AvrXDelay
 3366 0e26 BCCF      		rjmp .L192
 3367               	/* epilogue: frame size=6 */
 3368               	/* epilogue: noreturn */
 3369               	/* epilogue end (size=0) */
 3370               	/* function getFuelAndBattery size 81 (71) */
 3377               	.Lscope57:
 3379               		.section	.progmem.data
 3382               	__c.2:
 3383 00bf 7120 2564 		.string	"q %d"
 3383      00
 3386               	__c.3:
 3387 00c4 7720 2564 		.string	"w %d"
 3387      00
 3390               	__c.4:
 3391 00c9 7120 2564 		.string	"q %d"
 3391      00
 3394               	__c.5:
 3395 00ce 7720 2564 		.string	"w %d"
 3395      00
 3396               		.text
 3398               	.global	getPitchAndRoll
 3400               	getPitchAndRoll:
 267:SerialExample.c **** 	}
 268:SerialExample.c **** }
 269:SerialExample.c **** 
 270:SerialExample.c **** 
 271:SerialExample.c **** AVRX_GCC_TASKDEF(getPitchAndRoll, 76, 4)
 272:SerialExample.c **** {
 3402               	.LM305:
 3403               	/* prologue: frame size=6 */
 3404 0e28 CF93      		push r28
 3405 0e2a DF93      		push r29
 3406 0e2c CDB7      		in r28,__SP_L__
 3407 0e2e DEB7      		in r29,__SP_H__
 3408 0e30 2697      		sbiw r28,6
 3409 0e32 0FB6      		in __tmp_reg__,__SREG__
 3410 0e34 F894      		cli
 3411 0e36 DEBF      		out __SP_H__,r29
 3412 0e38 0FBE      		out __SREG__,__tmp_reg__
 3413 0e3a CDBF      		out __SP_L__,r28
 3414               	/* prologue end (size=10) */
 273:SerialExample.c **** 	TimerControlBlock timer;
 274:SerialExample.c **** 	int q = 0;
 3416               	.LM306:
 3417 0e3c 00E0      		ldi r16,lo8(0)
 3418 0e3e 10E0      		ldi r17,hi8(0)
 275:SerialExample.c **** 	int w = 127;
 3420               	.LM307:
 3421 0e40 7FE7      		ldi r23,lo8(127)
 3422 0e42 E72E      		mov r14,r23
 3423 0e44 F12C      		mov r15,__zero_reg__
 3424               	.L216:
 276:SerialExample.c **** 	
 277:SerialExample.c **** 	while(1)
 278:SerialExample.c **** 	{	
 279:SerialExample.c **** 		while (q<127)
 280:SerialExample.c **** 		{	printf_P(PSTR("q %d"), q);   
 281:SerialExample.c **** 			putchar('\r');
 282:SerialExample.c **** 			if (DEBUG) putchar('\n');	
 283:SerialExample.c **** 			printf_P(PSTR("w %d"), w);
 284:SerialExample.c **** 			putchar('\r');
 285:SerialExample.c **** 			if (DEBUG) putchar('\n');
 286:SerialExample.c **** 			q++;					
 287:SerialExample.c **** 			w--;		
 288:SerialExample.c **** 			AvrXDelay(&timer, 33);		//try 33Hz
 3426               	.LM308:
 3427 0e46 0F37      		cpi r16,127
 3428 0e48 1105      		cpc r17,__zero_reg__
 3429 0e4a 0CF0      		brlt .+2
 3430 0e4c 44C0      		rjmp .L210
 3432               	.LM309:
 3433 0e4e 1F93      		push r17
 3434 0e50 0F93      		push r16
 3435 0e52 80E0      		ldi r24,lo8(__c.2)
 3436 0e54 90E0      		ldi r25,hi8(__c.2)
 3437 0e56 9F93      		push r25
 3438 0e58 8F93      		push r24
 3439 0e5a 0E94 0000 		call printf_P
 3441               	.LM310:
 3442 0e5e 6091 0000 		lds r22,__iob+2
 3443 0e62 7091 0000 		lds r23,(__iob+2)+1
 3444 0e66 8DE0      		ldi r24,lo8(13)
 3445 0e68 90E0      		ldi r25,hi8(13)
 3446 0e6a 0E94 0000 		call fputc
 3448               	.LM311:
 3449 0e6e 6091 0000 		lds r22,__iob+2
 3450 0e72 7091 0000 		lds r23,(__iob+2)+1
 3451 0e76 8AE0      		ldi r24,lo8(10)
 3452 0e78 90E0      		ldi r25,hi8(10)
 3453 0e7a 0E94 0000 		call fputc
 3454 0e7e 0F90      		pop __tmp_reg__
 3455 0e80 0F90      		pop __tmp_reg__
 3456 0e82 0F90      		pop __tmp_reg__
 3457 0e84 0F90      		pop __tmp_reg__
 3459               	.LM312:
 3460 0e86 FF92      		push r15
 3461 0e88 EF92      		push r14
 3462 0e8a 80E0      		ldi r24,lo8(__c.3)
 3463 0e8c 90E0      		ldi r25,hi8(__c.3)
 3464 0e8e 9F93      		push r25
 3465 0e90 8F93      		push r24
 3466 0e92 0E94 0000 		call printf_P
 3468               	.LM313:
 3469 0e96 6091 0000 		lds r22,__iob+2
 3470 0e9a 7091 0000 		lds r23,(__iob+2)+1
 3471 0e9e 8DE0      		ldi r24,lo8(13)
 3472 0ea0 90E0      		ldi r25,hi8(13)
 3473 0ea2 0E94 0000 		call fputc
 3475               	.LM314:
 3476 0ea6 6091 0000 		lds r22,__iob+2
 3477 0eaa 7091 0000 		lds r23,(__iob+2)+1
 3478 0eae 8AE0      		ldi r24,lo8(10)
 3479 0eb0 90E0      		ldi r25,hi8(10)
 3480 0eb2 0E94 0000 		call fputc
 3481 0eb6 0F90      		pop __tmp_reg__
 3482 0eb8 0F90      		pop __tmp_reg__
 3483 0eba 0F90      		pop __tmp_reg__
 3484 0ebc 0F90      		pop __tmp_reg__
 3486               	.LM315:
 3487 0ebe 0F5F      		subi r16,lo8(-(1))
 3488 0ec0 1F4F      		sbci r17,hi8(-(1))
 3490               	.LM316:
 3491 0ec2 0894      		sec
 3492 0ec4 E108      		sbc r14,__zero_reg__
 3493 0ec6 F108      		sbc r15,__zero_reg__
 3495               	.LM317:
 3496 0ec8 61E2      		ldi r22,lo8(33)
 3497 0eca 70E0      		ldi r23,hi8(33)
 3498 0ecc CE01      		movw r24,r28
 3499 0ece 0196      		adiw r24,1
 3500 0ed0 0E94 0000 		call AvrXDelay
 3501 0ed4 B8CF      		rjmp .L216
 3502               	.L210:
 289:SerialExample.c **** 		}
 290:SerialExample.c **** 		while (q>0)
 291:SerialExample.c **** 		{	printf_P(PSTR("q %d"), q);
 292:SerialExample.c **** 			putchar('\r');
 293:SerialExample.c **** 			if (DEBUG) putchar('\n');
 294:SerialExample.c **** 			printf_P(PSTR("w %d"), w);
 295:SerialExample.c **** 			putchar('\r');
 296:SerialExample.c **** 			if (DEBUG) putchar('\n');
 297:SerialExample.c **** 			q--;
 298:SerialExample.c **** 			w++;
 299:SerialExample.c **** 			AvrXDelay(&timer, 33);
 3504               	.LM318:
 3505 0ed6 1016      		cp __zero_reg__,r16
 3506 0ed8 1106      		cpc __zero_reg__,r17
 3507 0eda 0CF0      		brlt .+2
 3508 0edc B4CF      		rjmp .L216
 3510               	.LM319:
 3511 0ede 1F93      		push r17
 3512 0ee0 0F93      		push r16
 3513 0ee2 80E0      		ldi r24,lo8(__c.4)
 3514 0ee4 90E0      		ldi r25,hi8(__c.4)
 3515 0ee6 9F93      		push r25
 3516 0ee8 8F93      		push r24
 3517 0eea 0E94 0000 		call printf_P
 3519               	.LM320:
 3520 0eee 6091 0000 		lds r22,__iob+2
 3521 0ef2 7091 0000 		lds r23,(__iob+2)+1
 3522 0ef6 8DE0      		ldi r24,lo8(13)
 3523 0ef8 90E0      		ldi r25,hi8(13)
 3524 0efa 0E94 0000 		call fputc
 3526               	.LM321:
 3527 0efe 6091 0000 		lds r22,__iob+2
 3528 0f02 7091 0000 		lds r23,(__iob+2)+1
 3529 0f06 8AE0      		ldi r24,lo8(10)
 3530 0f08 90E0      		ldi r25,hi8(10)
 3531 0f0a 0E94 0000 		call fputc
 3532 0f0e 0F90      		pop __tmp_reg__
 3533 0f10 0F90      		pop __tmp_reg__
 3534 0f12 0F90      		pop __tmp_reg__
 3535 0f14 0F90      		pop __tmp_reg__
 3537               	.LM322:
 3538 0f16 FF92      		push r15
 3539 0f18 EF92      		push r14
 3540 0f1a 80E0      		ldi r24,lo8(__c.5)
 3541 0f1c 90E0      		ldi r25,hi8(__c.5)
 3542 0f1e 9F93      		push r25
 3543 0f20 8F93      		push r24
 3544 0f22 0E94 0000 		call printf_P
 3546               	.LM323:
 3547 0f26 6091 0000 		lds r22,__iob+2
 3548 0f2a 7091 0000 		lds r23,(__iob+2)+1
 3549 0f2e 8DE0      		ldi r24,lo8(13)
 3550 0f30 90E0      		ldi r25,hi8(13)
 3551 0f32 0E94 0000 		call fputc
 3553               	.LM324:
 3554 0f36 6091 0000 		lds r22,__iob+2
 3555 0f3a 7091 0000 		lds r23,(__iob+2)+1
 3556 0f3e 8AE0      		ldi r24,lo8(10)
 3557 0f40 90E0      		ldi r25,hi8(10)
 3558 0f42 0E94 0000 		call fputc
 3559 0f46 0F90      		pop __tmp_reg__
 3560 0f48 0F90      		pop __tmp_reg__
 3561 0f4a 0F90      		pop __tmp_reg__
 3562 0f4c 0F90      		pop __tmp_reg__
 3564               	.LM325:
 3565 0f4e 0150      		subi r16,lo8(-(-1))
 3566 0f50 1040      		sbci r17,hi8(-(-1))
 3568               	.LM326:
 3569 0f52 0894      		sec
 3570 0f54 E11C      		adc r14,__zero_reg__
 3571 0f56 F11C      		adc r15,__zero_reg__
 3573               	.LM327:
 3574 0f58 61E2      		ldi r22,lo8(33)
 3575 0f5a 70E0      		ldi r23,hi8(33)
 3576 0f5c CE01      		movw r24,r28
 3577 0f5e 0196      		adiw r24,1
 3578 0f60 0E94 0000 		call AvrXDelay
 3579 0f64 B8CF      		rjmp .L210
 3580               	/* epilogue: frame size=6 */
 3581               	/* epilogue: noreturn */
 3582               	/* epilogue end (size=0) */
 3583               	/* function getPitchAndRoll size 159 (149) */
 3590               	.Lscope58:
 3593               	.global	getCommands
 3595               	getCommands:
 300:SerialExample.c **** 		}
 301:SerialExample.c **** 	}
 302:SerialExample.c **** }
 303:SerialExample.c **** 
 304:SerialExample.c **** AVRX_GCC_TASKDEF(getCommands, 100, 5)
 305:SerialExample.c **** {	
 3597               	.LM328:
 3598               	/* prologue: frame size=0 */
 3599               	/* prologue end (size=0) */
 306:SerialExample.c **** 	int c;		
 307:SerialExample.c **** 	
 308:SerialExample.c **** 	while (1)
 309:SerialExample.c **** 	{
 310:SerialExample.c **** 		while ((c = getchar()) != EOF)
 3601               	.LM329:
 3602 0f66 15C0      		rjmp .L227
 3603               	.L223:
 311:SerialExample.c **** 		{	
 312:SerialExample.c **** 			if (c == '\r')
 3605               	.LM330:
 3606 0f68 CD30      		cpi r28,13
 3607 0f6a D105      		cpc r29,__zero_reg__
 3608 0f6c 79F4      		brne .L222
 313:SerialExample.c **** 			{	putchar('\r');
 3610               	.LM331:
 3611 0f6e 6091 0000 		lds r22,__iob+2
 3612 0f72 7091 0000 		lds r23,(__iob+2)+1
 3613 0f76 CE01      		movw r24,r28
 3614 0f78 0E94 0000 		call fputc
 314:SerialExample.c **** 				putchar('\n');
 3616               	.LM332:
 3617 0f7c 6091 0000 		lds r22,__iob+2
 3618 0f80 7091 0000 		lds r23,(__iob+2)+1
 3619 0f84 8AE0      		ldi r24,lo8(10)
 3620 0f86 90E0      		ldi r25,hi8(10)
 3621 0f88 0E94 0000 		call fputc
 3622               	.L222:
 315:SerialExample.c **** 			}
 316:SerialExample.c **** 			parserInputFunc(c);
 3624               	.LM333:
 3625 0f8c 8C2F      		mov r24,r28
 3626 0f8e 0E94 0000 		call parserInputFunc
 3627               	.L227:
 3628 0f92 8091 0000 		lds r24,__iob
 3629 0f96 9091 0000 		lds r25,(__iob)+1
 3630 0f9a 0E94 0000 		call fgetc
 3631 0f9e EC01      		movw r28,r24
 3632 0fa0 8FEF      		ldi r24,hi8(-1)
 3633 0fa2 CF3F      		cpi r28,lo8(-1)
 3634 0fa4 D807      		cpc r29,r24
 3635 0fa6 01F7      		brne .L223
 3636 0fa8 F4CF      		rjmp .L227
 3637               	/* epilogue: frame size=0 */
 3638               	/* epilogue: noreturn */
 3639               	/* epilogue end (size=0) */
 3640               	/* function getCommands size 34 (34) */
 3645               	.Lscope59:
 3647               		.section	.progmem.data
 3650               	__c.0:
 3651 00d3 4920 666F 		.string	"I founded Rhizome!\r\n"
 3651      756E 6465 
 3651      6420 5268 
 3651      697A 6F6D 
 3651      6521 0D0A 
 3654               	__c.1:
 3655 00e8 2564 2000 		.string	"%d "
 3656               		.text
 3658               	.global	marktribe
 3660               	marktribe:
 317:SerialExample.c **** 		}
 318:SerialExample.c **** 	}
 319:SerialExample.c **** }
 320:SerialExample.c **** 
 321:SerialExample.c **** AVRX_GCC_TASKDEF(marktribe, 70, 3)
 322:SerialExample.c **** {
 3662               	.LM334:
 3663               	/* prologue: frame size=6 */
 3664 0faa CF93      		push r28
 3665 0fac DF93      		push r29
 3666 0fae CDB7      		in r28,__SP_L__
 3667 0fb0 DEB7      		in r29,__SP_H__
 3668 0fb2 2697      		sbiw r28,6
 3669 0fb4 0FB6      		in __tmp_reg__,__SREG__
 3670 0fb6 F894      		cli
 3671 0fb8 DEBF      		out __SP_H__,r29
 3672 0fba 0FBE      		out __SREG__,__tmp_reg__
 3673 0fbc CDBF      		out __SP_L__,r28
 3674               	/* prologue end (size=10) */
 323:SerialExample.c **** 	TimerControlBlock timer2;
 324:SerialExample.c ****     char c = 'a';
 3676               	.LM335:
 3677 0fbe 11E6      		ldi r17,lo8(97)
 325:SerialExample.c ****     printf_P(PSTR("I founded Rhizome!\r\n"));
 3679               	.LM336:
 3680 0fc0 80E0      		ldi r24,lo8(__c.0)
 3681 0fc2 90E0      		ldi r25,hi8(__c.0)
 3682 0fc4 9F93      		push r25
 3683 0fc6 8F93      		push r24
 3684 0fc8 0E94 0000 		call printf_P
 326:SerialExample.c ****     while(1)
 3686               	.LM337:
 3687 0fcc 0F90      		pop __tmp_reg__
 3688 0fce 0F90      		pop __tmp_reg__
 3689               	.L229:
 327:SerialExample.c ****     {    
 328:SerialExample.c ****         printf_P(PSTR("%d "),c);
 3691               	.LM338:
 3692 0fd0 812F      		mov r24,r17
 3693 0fd2 9927      		clr r25
 3694 0fd4 87FD      		sbrc r24,7
 3695 0fd6 9095      		com r25
 3696 0fd8 9F93      		push r25
 3697 0fda 8F93      		push r24
 3698 0fdc 80E0      		ldi r24,lo8(__c.1)
 3699 0fde 90E0      		ldi r25,hi8(__c.1)
 3700 0fe0 9F93      		push r25
 3701 0fe2 8F93      		push r24
 3702 0fe4 0E94 0000 		call printf_P
 329:SerialExample.c ****         c++;
 3704               	.LM339:
 3705 0fe8 1F5F      		subi r17,lo8(-(1))
 330:SerialExample.c ****         AvrXDelay(&timer2, 1000); //supposed to be a 1000 ms delay
 3707               	.LM340:
 3708 0fea 68EE      		ldi r22,lo8(1000)
 3709 0fec 73E0      		ldi r23,hi8(1000)
 3710 0fee CE01      		movw r24,r28
 3711 0ff0 0196      		adiw r24,1
 3712 0ff2 0E94 0000 		call AvrXDelay
 3713 0ff6 0F90      		pop __tmp_reg__
 3714 0ff8 0F90      		pop __tmp_reg__
 3715 0ffa 0F90      		pop __tmp_reg__
 3716 0ffc 0F90      		pop __tmp_reg__
 3717 0ffe E8CF      		rjmp .L229
 3718               	/* epilogue: frame size=6 */
 3719               	/* epilogue: noreturn */
 3720               	/* epilogue end (size=0) */
 3721               	/* function marktribe size 43 (33) */
 3727               	.Lscope60:
 3729               		.data
 3730               	.LC0:
 3731 0002 6C00      		.string	"l"
 3732               	.LC1:
 3733 0004 7200      		.string	"r"
 3734               	.LC2:
 3735 0006 7400      		.string	"t"
 3736               	.LC3:
 3737 0008 7000      		.string	"p"
 3738               	.LC4:
 3739 000a 6900      		.string	"i"
 3740               		.text
 3742               	.global	main
 3744               	main:
 331:SerialExample.c ****     }
 332:SerialExample.c ****     
 333:SerialExample.c **** }
 334:SerialExample.c **** 	
 335:SerialExample.c **** /*
 336:SerialExample.c **** AVRX_GCC_TASKDEF(servos, 120, 1)
 337:SerialExample.c **** {
 338:SerialExample.c **** 	TimerControlBlock timer3;
 339:SerialExample.c **** 	
 340:SerialExample.c **** 	u08 pos;
 341:SerialExample.c **** 	u08 channel;
 342:SerialExample.c **** 
 343:SerialExample.c **** 	// do some examples
 344:SerialExample.c **** 	// initialize RC servo system
 345:SerialExample.c **** 	servoInit();
 346:SerialExample.c **** 	// setup servo output channel-to-I/Opin mapping
 347:SerialExample.c **** 	// format is servoSetChannelIO( CHANNEL#, PORT, PIN );
 348:SerialExample.c **** 	servoSetChannelIO(0, _SFR_IO_ADDR(PORTC), PC0);
 349:SerialExample.c **** 
 350:SerialExample.c **** 
 351:SerialExample.c **** 	// set port pins to output
 352:SerialExample.c **** 	outb(DDRC, 0x01);
 353:SerialExample.c **** 
 354:SerialExample.c **** 	pos = 0;
 355:SerialExample.c **** 	
 356:SerialExample.c **** 	#define SPEED_SERVO	1
 357:SerialExample.c **** 
 358:SerialExample.c **** 	// spin servos sequentially back and forth between their limits
 359:SerialExample.c **** 	while(1)
 360:SerialExample.c **** 	{
 361:SerialExample.c **** 		for(channel=0; channel<SERVO_NUM_CHANNELS; channel++)
 362:SerialExample.c **** 		{
 363:SerialExample.c **** 			for(pos=0; pos<SERVO_POSITION_MAX; pos++)
 364:SerialExample.c **** 			{
 365:SerialExample.c **** 				servoSetPosition(channel,pos);
 366:SerialExample.c **** 				AvrXDelay(&timer3, 1000);;
 367:SerialExample.c **** 			}
 368:SerialExample.c **** 		}
 369:SerialExample.c **** 
 370:SerialExample.c **** 		for(channel=0; channel<SERVO_NUM_CHANNELS; channel++)
 371:SerialExample.c **** 		{
 372:SerialExample.c **** 			for(pos=SERVO_POSITION_MAX; pos>=1; pos--)
 373:SerialExample.c **** 			{
 374:SerialExample.c **** 				servoSetPosition(channel,pos);
 375:SerialExample.c **** 				AvrXDelay(&timer3, 1000);;
 376:SerialExample.c **** 			}
 377:SerialExample.c **** 		}
 378:SerialExample.c **** 	}
 379:SerialExample.c **** }
 380:SerialExample.c **** */
 381:SerialExample.c **** //#endif // USART_CHANNELS & CHANNEL_0
 382:SerialExample.c **** 
 383:SerialExample.c **** int main(void)
 384:SerialExample.c **** {
 3746               	.LM341:
 3747               	/* prologue: frame size=0 */
 3748 1000 C0E0      		ldi r28,lo8(__stack - 0)
 3749 1002 D0E0      		ldi r29,hi8(__stack - 0)
 3750 1004 DEBF      		out __SP_H__,r29
 3751 1006 CDBF      		out __SP_L__,r28
 3752               	/* prologue end (size=4) */
 385:SerialExample.c ****     AvrXSetKernelStack(0);
 3754               	.LM342:
 3755 1008 80E0      		ldi r24,lo8(0)
 3756 100a 90E0      		ldi r25,hi8(0)
 3757 100c 0E94 0000 		call AvrXSetKernelStack
 386:SerialExample.c **** 
 387:SerialExample.c **** 	MCUCR = _BV(SE);
 3759               	.LM343:
 3760 1010 80E8      		ldi r24,lo8(-128)
 3761 1012 85BF      		out 85-0x20,r24
 388:SerialExample.c **** 	TCNT0 = TCNT0_INIT;
 3763               	.LM344:
 3764 1014 81EC      		ldi r24,lo8(-63)
 3765 1016 82BF      		out 82-0x20,r24
 389:SerialExample.c **** #if defined (__AVR_ATmega103__) || defined (__ATmega103__)
 390:SerialExample.c **** 	TCCR0 =  ((1<<CS02) | (1<<CS01));
 391:SerialExample.c **** #elif defined (__AVR_ATmega128__) || defined (__ATmega128__) || defined (__AVR_ATmega64__) || defin
 392:SerialExample.c **** 	TCCR0 =  ((1<<CS2) | (1<<CS1));
 393:SerialExample.c **** #else	// Most other chips...  Note: some are TCCR0 and some are TCCR0B...
 394:SerialExample.c **** 	TCCR0 =  (1<<CS02);
 3767               	.LM345:
 3768 1018 04E0      		ldi r16,lo8(4)
 3769 101a 03BF      		out 83-0x20,r16
 395:SerialExample.c **** #endif
 396:SerialExample.c **** 	TIMSK = _BV(TOIE0);
 3771               	.LM346:
 3772 101c 11E0      		ldi r17,lo8(1)
 3773 101e 19BF      		out 89-0x20,r17
 397:SerialExample.c **** 
 398:SerialExample.c ****     InitSerial0(BAUD(9600));
 3775               	.LM347:
 3776 1020 8FEC      		ldi r24,lo8(207)
 3777 1022 90E0      		ldi r25,hi8(207)
 3778 1024 0E94 0000 		call InitSerial0
 399:SerialExample.c ****     fdevopen(put_char0, get_c0,0);		// Set up standard I/O
 3780               	.LM348:
 3781 1028 40E0      		ldi r20,lo8(0)
 3782 102a 50E0      		ldi r21,hi8(0)
 3783 102c 60E0      		ldi r22,lo8(pm(get_c0))
 3784 102e 70E0      		ldi r23,hi8(pm(get_c0))
 3785 1030 80E0      		ldi r24,lo8(pm(put_char0))
 3786 1032 90E0      		ldi r25,hi8(pm(put_char0))
 3787 1034 0E94 0000 		call fdevopen
 400:SerialExample.c **** 
 401:SerialExample.c **** 	// initialize parser system
 402:SerialExample.c **** 	parserInit();
 3789               	.LM349:
 3790 1038 0E94 0000 		call parserInit
 403:SerialExample.c **** 	// direct output to uart (serial port)
 404:SerialExample.c **** 	parserSetOutputFunc(put_char0);
 3792               	.LM350:
 3793 103c 80E0      		ldi r24,lo8(pm(put_char0))
 3794 103e 90E0      		ldi r25,hi8(pm(put_char0))
 3795 1040 0E94 0000 		call parserSetOutputFunc
 405:SerialExample.c **** 	// add commands to the command database
 406:SerialExample.c **** 	parserAddCommand("l",		setLeftServo);
 3797               	.LM351:
 3798 1044 60E0      		ldi r22,lo8(pm(setLeftServo))
 3799 1046 70E0      		ldi r23,hi8(pm(setLeftServo))
 3800 1048 80E0      		ldi r24,lo8(.LC0)
 3801 104a 90E0      		ldi r25,hi8(.LC0)
 3802 104c 0E94 0000 		call parserAddCommand
 407:SerialExample.c **** 	parserAddCommand("r",		setRightServo);
 3804               	.LM352:
 3805 1050 60E0      		ldi r22,lo8(pm(setRightServo))
 3806 1052 70E0      		ldi r23,hi8(pm(setRightServo))
 3807 1054 80E0      		ldi r24,lo8(.LC1)
 3808 1056 90E0      		ldi r25,hi8(.LC1)
 3809 1058 0E94 0000 		call parserAddCommand
 408:SerialExample.c ****     parserAddCommand("t", 		setThrottleServo);
 3811               	.LM353:
 3812 105c 60E0      		ldi r22,lo8(pm(setThrottleServo))
 3813 105e 70E0      		ldi r23,hi8(pm(setThrottleServo))
 3814 1060 80E0      		ldi r24,lo8(.LC2)
 3815 1062 90E0      		ldi r25,hi8(.LC2)
 3816 1064 0E94 0000 		call parserAddCommand
 409:SerialExample.c **** 	parserAddCommand("p", 		setCamPanServo);
 3818               	.LM354:
 3819 1068 60E0      		ldi r22,lo8(pm(setCamPanServo))
 3820 106a 70E0      		ldi r23,hi8(pm(setCamPanServo))
 3821 106c 80E0      		ldi r24,lo8(.LC3)
 3822 106e 90E0      		ldi r25,hi8(.LC3)
 3823 1070 0E94 0000 		call parserAddCommand
 410:SerialExample.c **** 	parserAddCommand("i", 		setCamTiltServo);
 3825               	.LM355:
 3826 1074 60E0      		ldi r22,lo8(pm(setCamTiltServo))
 3827 1076 70E0      		ldi r23,hi8(pm(setCamTiltServo))
 3828 1078 80E0      		ldi r24,lo8(.LC4)
 3829 107a 90E0      		ldi r25,hi8(.LC4)
 3830 107c 0E94 0000 		call parserAddCommand
 411:SerialExample.c **** 	
 412:SerialExample.c **** 	// initialize the timer system -- FROM AVRLIB
 413:SerialExample.c **** 	//timerInit();
 414:SerialExample.c **** 	
 415:SerialExample.c **** 	//////////////////////////////////////////////////Servos//////////////////////////
 416:SerialExample.c **** 	servoInit();
 3832               	.LM356:
 3833 1080 0E94 0000 		call servoInit
 417:SerialExample.c **** 	// setup servo output channel-to-I/Opin mapping
 418:SerialExample.c **** 	// format is servoSetChannelIO( CHANNEL#, PORT, PIN );
 419:SerialExample.c **** 	servoSetChannelIO(0, _SFR_IO_ADDR(PORTC), PC0);
 3835               	.LM357:
 3836 1084 40E0      		ldi r20,lo8(0)
 3837 1086 65E1      		ldi r22,lo8(21)
 3838 1088 842F      		mov r24,r20
 3839 108a 0E94 0000 		call servoSetChannelIO
 420:SerialExample.c **** 	servoSetChannelIO(1, _SFR_IO_ADDR(PORTC), PC1);
 3841               	.LM358:
 3842 108e 412F      		mov r20,r17
 3843 1090 65E1      		ldi r22,lo8(21)
 3844 1092 812F      		mov r24,r17
 3845 1094 0E94 0000 		call servoSetChannelIO
 421:SerialExample.c **** 	servoSetChannelIO(2, _SFR_IO_ADDR(PORTC), PC2);
 3847               	.LM359:
 3848 1098 42E0      		ldi r20,lo8(2)
 3849 109a 65E1      		ldi r22,lo8(21)
 3850 109c 842F      		mov r24,r20
 3851 109e 0E94 0000 		call servoSetChannelIO
 422:SerialExample.c **** 	servoSetChannelIO(3, _SFR_IO_ADDR(PORTC), PC3);
 3853               	.LM360:
 3854 10a2 43E0      		ldi r20,lo8(3)
 3855 10a4 65E1      		ldi r22,lo8(21)
 3856 10a6 842F      		mov r24,r20
 3857 10a8 0E94 0000 		call servoSetChannelIO
 423:SerialExample.c **** 	servoSetChannelIO(4, _SFR_IO_ADDR(PORTC), PC4);
 3859               	.LM361:
 3860 10ac 402F      		mov r20,r16
 3861 10ae 65E1      		ldi r22,lo8(21)
 3862 10b0 802F      		mov r24,r16
 3863 10b2 0E94 0000 		call servoSetChannelIO
 424:SerialExample.c **** 
 425:SerialExample.c **** 	// set port pins to output
 426:SerialExample.c **** 	outb(DDRC, 0x1F);
 3865               	.LM362:
 3866 10b6 8FE1      		ldi r24,lo8(31)
 3867 10b8 84BB      		out 52-0x20,r24
 427:SerialExample.c **** 
 428:SerialExample.c **** 	
 429:SerialExample.c **** 	#define SPEED_SERVO	1
 430:SerialExample.c **** 	//////////////////////////////////////////////////////////////////////////////////
 431:SerialExample.c **** 	
 432:SerialExample.c **** 	AvrXRunTask(TCB(getCommands));
 3869               	.LM363:
 3870 10ba 80E0      		ldi r24,lo8(getCommandsTcb)
 3871 10bc 90E0      		ldi r25,hi8(getCommandsTcb)
 3872 10be 0E94 0000 		call AvrXRunTask
 433:SerialExample.c **** //	AvrXRunTask(TCB(marktribe));
 434:SerialExample.c **** 	AvrXRunTask(TCB(getUAVStatus));
 3874               	.LM364:
 3875 10c2 80E0      		ldi r24,lo8(getUAVStatusTcb)
 3876 10c4 90E0      		ldi r25,hi8(getUAVStatusTcb)
 3877 10c6 0E94 0000 		call AvrXRunTask
 435:SerialExample.c **** 	AvrXRunTask(TCB(getAirspeed));
 3879               	.LM365:
 3880 10ca 80E0      		ldi r24,lo8(getAirspeedTcb)
 3881 10cc 90E0      		ldi r25,hi8(getAirspeedTcb)
 3882 10ce 0E94 0000 		call AvrXRunTask
 436:SerialExample.c **** 	AvrXRunTask(TCB(getGroundspeed));
 3884               	.LM366:
 3885 10d2 80E0      		ldi r24,lo8(getGroundspeedTcb)
 3886 10d4 90E0      		ldi r25,hi8(getGroundspeedTcb)
 3887 10d6 0E94 0000 		call AvrXRunTask
 437:SerialExample.c **** 	AvrXRunTask(TCB(getCompassHeading));
 3889               	.LM367:
 3890 10da 80E0      		ldi r24,lo8(getCompassHeadingTcb)
 3891 10dc 90E0      		ldi r25,hi8(getCompassHeadingTcb)
 3892 10de 0E94 0000 		call AvrXRunTask
 438:SerialExample.c **** 	AvrXRunTask(TCB(getGPSData));
 3894               	.LM368:
 3895 10e2 80E0      		ldi r24,lo8(getGPSDataTcb)
 3896 10e4 90E0      		ldi r25,hi8(getGPSDataTcb)
 3897 10e6 0E94 0000 		call AvrXRunTask
 439:SerialExample.c **** 	AvrXRunTask(TCB(getPitchAndRoll));
 3899               	.LM369:
 3900 10ea 80E0      		ldi r24,lo8(getPitchAndRollTcb)
 3901 10ec 90E0      		ldi r25,hi8(getPitchAndRollTcb)
 3902 10ee 0E94 0000 		call AvrXRunTask
 440:SerialExample.c **** 	AvrXRunTask(TCB(getFuelAndBattery));
 3904               	.LM370:
 3905 10f2 80E0      		ldi r24,lo8(getFuelAndBatteryTcb)
 3906 10f4 90E0      		ldi r25,hi8(getFuelAndBatteryTcb)
 3907 10f6 0E94 0000 		call AvrXRunTask
 441:SerialExample.c **** 	//AvrXRunTask(TCB(servos));
 442:SerialExample.c ****     
 443:SerialExample.c **** 	Epilog();
 3909               	.LM371:
 3910 10fa 0E94 0000 		call Epilog
 444:SerialExample.c **** 	return(0);
 445:SerialExample.c **** }
 3912               	.LM372:
 3913 10fe 80E0      		ldi r24,lo8(0)
 3914 1100 90E0      		ldi r25,hi8(0)
 3915               	/* epilogue: frame size=0 */
 3916 1102 0C94 0000 		jmp exit
 3917               	/* epilogue end (size=2) */
 3918               	/* function main size 131 (125) */
 3920               	.Lscope61:
 3922               		.data
 3923               	.LC5:
 3924 000c 4C65 6674 		.string	"Left Servo Set: %d"
 3924      2053 6572 
 3924      766F 2053 
 3924      6574 3A20 
 3924      2564 00
 3925               		.text
 3927               	.global	setLeftServo
 3929               	setLeftServo:
 446:SerialExample.c **** 
 447:SerialExample.c **** void setLeftServo(void)
 448:SerialExample.c **** {	
 3931               	.LM373:
 3932               	/* prologue: frame size=0 */
 3933               	/* prologue end (size=0) */
 449:SerialExample.c **** 	leftServoPos = parserGetArgInt();
 3935               	.LM374:
 3936 1106 0E94 0000 		call parserGetArgInt
 3937 110a 9093 0000 		sts (leftServoPos)+1,r25
 3938 110e 8093 0000 		sts leftServoPos,r24
 450:SerialExample.c **** 	servoSetPosition(LEFT_SERVO_CHAN, (char)leftServoPos);
 3940               	.LM375:
 3941 1112 6091 0000 		lds r22,leftServoPos
 3942 1116 80E0      		ldi r24,lo8(0)
 3943 1118 0E94 0000 		call servoSetPosition
 451:SerialExample.c **** 	if (DEBUG)
 452:SerialExample.c **** 	{	printf("Left Servo Set: %d", leftServoPos);
 3945               	.LM376:
 3946 111c 8091 0000 		lds r24,leftServoPos
 3947 1120 9091 0000 		lds r25,(leftServoPos)+1
 3948 1124 9F93      		push r25
 3949 1126 8F93      		push r24
 3950 1128 80E0      		ldi r24,lo8(.LC5)
 3951 112a 90E0      		ldi r25,hi8(.LC5)
 3952 112c 9F93      		push r25
 3953 112e 8F93      		push r24
 3954 1130 0E94 0000 		call printf
 453:SerialExample.c **** 		putchar('\r');
 3956               	.LM377:
 3957 1134 6091 0000 		lds r22,__iob+2
 3958 1138 7091 0000 		lds r23,(__iob+2)+1
 3959 113c 8DE0      		ldi r24,lo8(13)
 3960 113e 90E0      		ldi r25,hi8(13)
 3961 1140 0E94 0000 		call fputc
 454:SerialExample.c **** 		putchar('\n');
 3963               	.LM378:
 3964 1144 6091 0000 		lds r22,__iob+2
 3965 1148 7091 0000 		lds r23,(__iob+2)+1
 3966 114c 8AE0      		ldi r24,lo8(10)
 3967 114e 90E0      		ldi r25,hi8(10)
 3968 1150 0E94 0000 		call fputc
 3969 1154 0F90      		pop __tmp_reg__
 3970 1156 0F90      		pop __tmp_reg__
 3971 1158 0F90      		pop __tmp_reg__
 3972 115a 0F90      		pop __tmp_reg__
 3973               	/* epilogue: frame size=0 */
 3974 115c 0895      		ret
 3975               	/* epilogue end (size=1) */
 3976               	/* function setLeftServo size 44 (43) */
 3978               	.Lscope62:
 3980               		.data
 3981               	.LC6:
 3982 001f 5269 6768 		.string	"Right Servo Set: %d"
 3982      7420 5365 
 3982      7276 6F20 
 3982      5365 743A 
 3982      2025 6400 
 3983               		.text
 3985               	.global	setRightServo
 3987               	setRightServo:
 455:SerialExample.c **** 	}
 456:SerialExample.c **** }
 457:SerialExample.c **** 
 458:SerialExample.c **** void setRightServo(void)
 459:SerialExample.c **** {	
 3989               	.LM379:
 3990               	/* prologue: frame size=0 */
 3991               	/* prologue end (size=0) */
 460:SerialExample.c **** 	rightServoPos = parserGetArgInt();
 3993               	.LM380:
 3994 115e 0E94 0000 		call parserGetArgInt
 3995 1162 9093 0000 		sts (rightServoPos)+1,r25
 3996 1166 8093 0000 		sts rightServoPos,r24
 461:SerialExample.c **** 	servoSetPosition(RIGHT_SERVO_CHAN, (char)rightServoPos);
 3998               	.LM381:
 3999 116a 6091 0000 		lds r22,rightServoPos
 4000 116e 81E0      		ldi r24,lo8(1)
 4001 1170 0E94 0000 		call servoSetPosition
 462:SerialExample.c **** 	if (DEBUG)
 463:SerialExample.c **** 	{	printf("Right Servo Set: %d", rightServoPos);
 4003               	.LM382:
 4004 1174 8091 0000 		lds r24,rightServoPos
 4005 1178 9091 0000 		lds r25,(rightServoPos)+1
 4006 117c 9F93      		push r25
 4007 117e 8F93      		push r24
 4008 1180 80E0      		ldi r24,lo8(.LC6)
 4009 1182 90E0      		ldi r25,hi8(.LC6)
 4010 1184 9F93      		push r25
 4011 1186 8F93      		push r24
 4012 1188 0E94 0000 		call printf
 464:SerialExample.c **** 		putchar('\r');
 4014               	.LM383:
 4015 118c 6091 0000 		lds r22,__iob+2
 4016 1190 7091 0000 		lds r23,(__iob+2)+1
 4017 1194 8DE0      		ldi r24,lo8(13)
 4018 1196 90E0      		ldi r25,hi8(13)
 4019 1198 0E94 0000 		call fputc
 465:SerialExample.c **** 		putchar('\n');
 4021               	.LM384:
 4022 119c 6091 0000 		lds r22,__iob+2
 4023 11a0 7091 0000 		lds r23,(__iob+2)+1
 4024 11a4 8AE0      		ldi r24,lo8(10)
 4025 11a6 90E0      		ldi r25,hi8(10)
 4026 11a8 0E94 0000 		call fputc
 4027 11ac 0F90      		pop __tmp_reg__
 4028 11ae 0F90      		pop __tmp_reg__
 4029 11b0 0F90      		pop __tmp_reg__
 4030 11b2 0F90      		pop __tmp_reg__
 4031               	/* epilogue: frame size=0 */
 4032 11b4 0895      		ret
 4033               	/* epilogue end (size=1) */
 4034               	/* function setRightServo size 44 (43) */
 4036               	.Lscope63:
 4038               		.data
 4039               	.LC7:
 4040 0033 5468 726F 		.string	"Throttle Servo Set: %d"
 4040      7474 6C65 
 4040      2053 6572 
 4040      766F 2053 
 4040      6574 3A20 
 4041               		.text
 4043               	.global	setThrottleServo
 4045               	setThrottleServo:
 466:SerialExample.c **** 	}
 467:SerialExample.c **** }
 468:SerialExample.c **** 
 469:SerialExample.c **** void setThrottleServo(void)
 470:SerialExample.c **** {
 4047               	.LM385:
 4048               	/* prologue: frame size=0 */
 4049               	/* prologue end (size=0) */
 471:SerialExample.c **** 	throttleServoPos = parserGetArgInt();
 4051               	.LM386:
 4052 11b6 0E94 0000 		call parserGetArgInt
 4053 11ba 9093 0000 		sts (throttleServoPos)+1,r25
 4054 11be 8093 0000 		sts throttleServoPos,r24
 472:SerialExample.c **** 	servoSetPosition(THROTTLE_SERVO_CHAN, (char)throttleServoPos);
 4056               	.LM387:
 4057 11c2 6091 0000 		lds r22,throttleServoPos
 4058 11c6 82E0      		ldi r24,lo8(2)
 4059 11c8 0E94 0000 		call servoSetPosition
 473:SerialExample.c **** 	if (DEBUG)
 474:SerialExample.c **** 	{	printf("Throttle Servo Set: %d", throttleServoPos);
 4061               	.LM388:
 4062 11cc 8091 0000 		lds r24,throttleServoPos
 4063 11d0 9091 0000 		lds r25,(throttleServoPos)+1
 4064 11d4 9F93      		push r25
 4065 11d6 8F93      		push r24
 4066 11d8 80E0      		ldi r24,lo8(.LC7)
 4067 11da 90E0      		ldi r25,hi8(.LC7)
 4068 11dc 9F93      		push r25
 4069 11de 8F93      		push r24
 4070 11e0 0E94 0000 		call printf
 475:SerialExample.c **** 		putchar('\r');
 4072               	.LM389:
 4073 11e4 6091 0000 		lds r22,__iob+2
 4074 11e8 7091 0000 		lds r23,(__iob+2)+1
 4075 11ec 8DE0      		ldi r24,lo8(13)
 4076 11ee 90E0      		ldi r25,hi8(13)
 4077 11f0 0E94 0000 		call fputc
 476:SerialExample.c **** 		putchar('\n');
 4079               	.LM390:
 4080 11f4 6091 0000 		lds r22,__iob+2
 4081 11f8 7091 0000 		lds r23,(__iob+2)+1
 4082 11fc 8AE0      		ldi r24,lo8(10)
 4083 11fe 90E0      		ldi r25,hi8(10)
 4084 1200 0E94 0000 		call fputc
 4085 1204 0F90      		pop __tmp_reg__
 4086 1206 0F90      		pop __tmp_reg__
 4087 1208 0F90      		pop __tmp_reg__
 4088 120a 0F90      		pop __tmp_reg__
 4089               	/* epilogue: frame size=0 */
 4090 120c 0895      		ret
 4091               	/* epilogue end (size=1) */
 4092               	/* function setThrottleServo size 44 (43) */
 4094               	.Lscope64:
 4096               		.data
 4097               	.LC8:
 4098 004a 4361 6D65 		.string	"Camera Pan Servo Set: %d"
 4098      7261 2050 
 4098      616E 2053 
 4098      6572 766F 
 4098      2053 6574 
 4099               		.text
 4101               	.global	setCamPanServo
 4103               	setCamPanServo:
 477:SerialExample.c **** 	}
 478:SerialExample.c **** }
 479:SerialExample.c **** 
 480:SerialExample.c **** void setCamPanServo(void)
 481:SerialExample.c **** {
 4105               	.LM391:
 4106               	/* prologue: frame size=0 */
 4107               	/* prologue end (size=0) */
 482:SerialExample.c **** 	camPanServoPos = parserGetArgInt();
 4109               	.LM392:
 4110 120e 0E94 0000 		call parserGetArgInt
 4111 1212 9093 0000 		sts (camPanServoPos)+1,r25
 4112 1216 8093 0000 		sts camPanServoPos,r24
 483:SerialExample.c **** 	servoSetPosition(CAM_PAN_SERVO_CHAN, (char)camPanServoPos);
 4114               	.LM393:
 4115 121a 6091 0000 		lds r22,camPanServoPos
 4116 121e 83E0      		ldi r24,lo8(3)
 4117 1220 0E94 0000 		call servoSetPosition
 484:SerialExample.c **** 	if (DEBUG)
 485:SerialExample.c **** 	{	printf("Camera Pan Servo Set: %d", camPanServoPos);
 4119               	.LM394:
 4120 1224 8091 0000 		lds r24,camPanServoPos
 4121 1228 9091 0000 		lds r25,(camPanServoPos)+1
 4122 122c 9F93      		push r25
 4123 122e 8F93      		push r24
 4124 1230 80E0      		ldi r24,lo8(.LC8)
 4125 1232 90E0      		ldi r25,hi8(.LC8)
 4126 1234 9F93      		push r25
 4127 1236 8F93      		push r24
 4128 1238 0E94 0000 		call printf
 486:SerialExample.c **** 		putchar('\r');
 4130               	.LM395:
 4131 123c 6091 0000 		lds r22,__iob+2
 4132 1240 7091 0000 		lds r23,(__iob+2)+1
 4133 1244 8DE0      		ldi r24,lo8(13)
 4134 1246 90E0      		ldi r25,hi8(13)
 4135 1248 0E94 0000 		call fputc
 487:SerialExample.c **** 		putchar('\n');
 4137               	.LM396:
 4138 124c 6091 0000 		lds r22,__iob+2
 4139 1250 7091 0000 		lds r23,(__iob+2)+1
 4140 1254 8AE0      		ldi r24,lo8(10)
 4141 1256 90E0      		ldi r25,hi8(10)
 4142 1258 0E94 0000 		call fputc
 4143 125c 0F90      		pop __tmp_reg__
 4144 125e 0F90      		pop __tmp_reg__
 4145 1260 0F90      		pop __tmp_reg__
 4146 1262 0F90      		pop __tmp_reg__
 4147               	/* epilogue: frame size=0 */
 4148 1264 0895      		ret
 4149               	/* epilogue end (size=1) */
 4150               	/* function setCamPanServo size 44 (43) */
 4152               	.Lscope65:
 4154               		.data
 4155               	.LC9:
 4156 0063 4361 6D65 		.string	"Camera Tilt Servo Set: %d"
 4156      7261 2054 
 4156      696C 7420 
 4156      5365 7276 
 4156      6F20 5365 
 4157               		.text
 4159               	.global	setCamTiltServo
 4161               	setCamTiltServo:
 488:SerialExample.c **** 	}
 489:SerialExample.c **** }
 490:SerialExample.c **** 
 491:SerialExample.c **** void setCamTiltServo(void)
 492:SerialExample.c **** {
 4163               	.LM397:
 4164               	/* prologue: frame size=0 */
 4165               	/* prologue end (size=0) */
 493:SerialExample.c **** 	camTiltServoPos = parserGetArgInt();
 4167               	.LM398:
 4168 1266 0E94 0000 		call parserGetArgInt
 4169 126a 9093 0000 		sts (camTiltServoPos)+1,r25
 4170 126e 8093 0000 		sts camTiltServoPos,r24
 494:SerialExample.c **** 	servoSetPosition(CAM_TILT_SERVO_CHAN, (char)camTiltServoPos);
 4172               	.LM399:
 4173 1272 6091 0000 		lds r22,camTiltServoPos
 4174 1276 84E0      		ldi r24,lo8(4)
 4175 1278 0E94 0000 		call servoSetPosition
 495:SerialExample.c **** 	if (DEBUG)
 496:SerialExample.c **** 	{	printf("Camera Tilt Servo Set: %d", camTiltServoPos);
 4177               	.LM400:
 4178 127c 8091 0000 		lds r24,camTiltServoPos
 4179 1280 9091 0000 		lds r25,(camTiltServoPos)+1
 4180 1284 9F93      		push r25
 4181 1286 8F93      		push r24
 4182 1288 80E0      		ldi r24,lo8(.LC9)
 4183 128a 90E0      		ldi r25,hi8(.LC9)
 4184 128c 9F93      		push r25
 4185 128e 8F93      		push r24
 4186 1290 0E94 0000 		call printf
 497:SerialExample.c **** 		putchar('\r');
 4188               	.LM401:
 4189 1294 6091 0000 		lds r22,__iob+2
 4190 1298 7091 0000 		lds r23,(__iob+2)+1
 4191 129c 8DE0      		ldi r24,lo8(13)
 4192 129e 90E0      		ldi r25,hi8(13)
 4193 12a0 0E94 0000 		call fputc
 498:SerialExample.c **** 		putchar('\n');
 4195               	.LM402:
 4196 12a4 6091 0000 		lds r22,__iob+2
 4197 12a8 7091 0000 		lds r23,(__iob+2)+1
 4198 12ac 8AE0      		ldi r24,lo8(10)
 4199 12ae 90E0      		ldi r25,hi8(10)
 4200 12b0 0E94 0000 		call fputc
 4201 12b4 0F90      		pop __tmp_reg__
 4202 12b6 0F90      		pop __tmp_reg__
 4203 12b8 0F90      		pop __tmp_reg__
 4204 12ba 0F90      		pop __tmp_reg__
 4205               	/* epilogue: frame size=0 */
 4206 12bc 0895      		ret
 4207               	/* epilogue end (size=1) */
 4208               	/* function setCamTiltServo size 44 (43) */
 4210               	.Lscope66:
 4212               		.comm CommandList,150,1
 4213               		.comm ParserFunctionList,20,1
 4214               		.comm parserNumCommands,1,1
 4215               		.comm parserBufferLength,1,1
 4216               		.comm parserBuffer,15,1
 4217               		.comm ParserExecFunction,2,1
 4218               		.comm parserOutputFunc,2,1
 4219               		.comm TimerPauseReg,4,1
 4220               		.comm Timer0Reg0,4,1
 4221               		.comm Timer2Reg0,4,1
 4222               		.lcomm TimerIntFunc,16
 4223               		.comm ServoPosTics,2,1
 4224               		.comm ServoPeriodTics,2,1
 4225               		.comm ServoChannel,1,1
 4226               		.comm ServoChannels,20,1
 4227               		.comm rightServoPos,2,1
 4228               		.comm throttleServoPos,2,1
 4229               		.comm camPanServoPos,2,1
 4230               		.comm camTiltServoPos,2,1
 4231               		.comm getUAVStatusStk,111,1
 4232               		.comm getUAVStatusPid,6,1
 4233               		.comm getCompassHeadingStk,111,1
 4234               		.comm getCompassHeadingPid,6,1
 4235               		.comm getAirspeedStk,111,1
 4236               		.comm getAirspeedPid,6,1
 4237               		.comm getGroundspeedStk,111,1
 4238               		.comm getGroundspeedPid,6,1
 4239               		.comm getGPSDataStk,111,1
 4240               		.comm getGPSDataPid,6,1
 4241               		.comm getFuelAndBatteryStk,111,1
 4242               		.comm getFuelAndBatteryPid,6,1
 4243               		.comm getPitchAndRollStk,111,1
 4244               		.comm getPitchAndRollPid,6,1
 4245               		.comm getCommandsStk,135,1
 4246               		.comm getCommandsPid,6,1
 4247               		.comm marktribeStk,105,1
 4248               		.comm marktribePid,6,1
 4298               		.text
 4300               	Letext:
 4301               	/* File "SerialExample.c": code 2425 = 0x0979 (2010), prologues 226, epilogues 189 */
DEFINED SYMBOLS
                            *ABS*:00000000 SerialExample.c
                            *ABS*:0000003f __SREG__
                            *ABS*:0000003e __SP_H__
                            *ABS*:0000003d __SP_L__
                            *ABS*:00000000 __tmp_reg__
                            *ABS*:00000001 __zero_reg__
/var/tmp//ccTFrovn.s:149    .progmem.data:00000000 marktribeTcb
                            *COM*:00000069 marktribeStk
/var/tmp//ccTFrovn.s:3660   .text:00000faa marktribe
                            *COM*:00000006 marktribePid
/var/tmp//ccTFrovn.s:157    .progmem.data:00000007 getCommandsTcb
                            *COM*:00000087 getCommandsStk
/var/tmp//ccTFrovn.s:3595   .text:00000f66 getCommands
                            *COM*:00000006 getCommandsPid
/var/tmp//ccTFrovn.s:165    .progmem.data:0000000e getPitchAndRollTcb
                            *COM*:0000006f getPitchAndRollStk
/var/tmp//ccTFrovn.s:3400   .text:00000e28 getPitchAndRoll
                            *COM*:00000006 getPitchAndRollPid
/var/tmp//ccTFrovn.s:173    .progmem.data:00000015 getFuelAndBatteryTcb
                            *COM*:0000006f getFuelAndBatteryStk
/var/tmp//ccTFrovn.s:3273   .text:00000d86 getFuelAndBattery
                            *COM*:00000006 getFuelAndBatteryPid
/var/tmp//ccTFrovn.s:181    .progmem.data:0000001c getGPSDataTcb
                            *COM*:0000006f getGPSDataStk
/var/tmp//ccTFrovn.s:3052   .text:00000c10 getGPSData
                            *COM*:00000006 getGPSDataPid
/var/tmp//ccTFrovn.s:189    .progmem.data:00000023 getGroundspeedTcb
                            *COM*:0000006f getGroundspeedStk
/var/tmp//ccTFrovn.s:2903   .text:00000b58 getGroundspeed
                            *COM*:00000006 getGroundspeedPid
/var/tmp//ccTFrovn.s:197    .progmem.data:0000002a getAirspeedTcb
                            *COM*:0000006f getAirspeedStk
/var/tmp//ccTFrovn.s:2770   .text:00000aa0 getAirspeed
                            *COM*:00000006 getAirspeedPid
/var/tmp//ccTFrovn.s:205    .progmem.data:00000031 getCompassHeadingTcb
                            *COM*:0000006f getCompassHeadingStk
/var/tmp//ccTFrovn.s:2626   .text:000009d0 getCompassHeading
                            *COM*:00000006 getCompassHeadingPid
/var/tmp//ccTFrovn.s:213    .progmem.data:00000038 getUAVStatusTcb
                            *COM*:0000006f getUAVStatusStk
/var/tmp//ccTFrovn.s:2556   .text:0000097e getUAVStatus
                            *COM*:00000006 getUAVStatusPid
/var/tmp//ccTFrovn.s:222    .data:00000000 leftServoPos
/var/tmp//ccTFrovn.s:228    .progmem.data:0000003f TimerRTCPrescaleFactor
/var/tmp//ccTFrovn.s:240    .progmem.data:0000004f TimerPrescaleFactor
/var/tmp//ccTFrovn.s:251    .text:00000000 parserInit
                            *COM*:00000001 parserBufferLength
                            *COM*:00000002 ParserExecFunction
                            *COM*:00000001 parserNumCommands
/var/tmp//ccTFrovn.s:280    .text:00000012 parserAddCommand
                            *COM*:00000096 CommandList
                            *COM*:00000014 ParserFunctionList
/var/tmp//ccTFrovn.s:328    .text:00000050 parserSetOutputFunc
                            *COM*:00000002 parserOutputFunc
/var/tmp//ccTFrovn.s:347    .text:0000005a parserProcessInputString
                            *COM*:0000000f parserBuffer
/var/tmp//ccTFrovn.s:426    .text:000000c4 parserInputFunc
/var/tmp//ccTFrovn.s:473    .text:000000f2 parserGetArgStr
/var/tmp//ccTFrovn.s:492    .text:000000f8 parserGetArgInt
/var/tmp//ccTFrovn.s:512    .text:00000102 delay_us
/var/tmp//ccTFrovn.s:559    .text:0000012a timerDetach
                             .bss:00000000 TimerIntFunc
/var/tmp//ccTFrovn.s:591    .text:00000140 timer0SetPrescaler
/var/tmp//ccTFrovn.s:612    .text:0000014a timer0ClearOverflowCount
                            *COM*:00000004 Timer0Reg0
/var/tmp//ccTFrovn.s:633    .text:0000015c timer0Init
/var/tmp//ccTFrovn.s:664    .text:00000170 timer1SetPrescaler
/var/tmp//ccTFrovn.s:685    .text:0000017a timer1Init
/var/tmp//ccTFrovn.s:716    .text:0000018c timer2SetPrescaler
/var/tmp//ccTFrovn.s:737    .text:00000196 timer2ClearOverflowCount
                            *COM*:00000004 Timer2Reg0
/var/tmp//ccTFrovn.s:758    .text:000001a8 timer2Init
/var/tmp//ccTFrovn.s:788    .text:000001bc timerInit
/var/tmp//ccTFrovn.s:835    .text:000001de timer0GetPrescaler
/var/tmp//ccTFrovn.s:873    .text:000001f6 timer1GetPrescaler
/var/tmp//ccTFrovn.s:911    .text:0000020e timer2GetPrescaler
/var/tmp//ccTFrovn.s:951    .text:00000226 timerAttach
/var/tmp//ccTFrovn.s:983    .text:0000023c timerPause
                            *COM*:00000004 TimerPauseReg
/var/tmp//ccTFrovn.s:1166   .text:00000376 timer0GetOverflowCount
/var/tmp//ccTFrovn.s:1191   .text:0000038c timer2GetOverflowCount
/var/tmp//ccTFrovn.s:1217   .text:000003a2 timer1PWMInit
/var/tmp//ccTFrovn.s:1282   .text:000003d2 timer1PWMInitICR
/var/tmp//ccTFrovn.s:1330   .text:000003fa timer1PWMAOff
/var/tmp//ccTFrovn.s:1355   .text:00000408 timer1PWMBOff
/var/tmp//ccTFrovn.s:1380   .text:00000416 timer1PWMOff
/var/tmp//ccTFrovn.s:1411   .text:0000042c timer1PWMAOn
/var/tmp//ccTFrovn.s:1436   .text:0000043a timer1PWMBOn
/var/tmp//ccTFrovn.s:1462   .text:00000448 timer1PWMASet
/var/tmp//ccTFrovn.s:1482   .text:0000044e timer1PWMBSet
/var/tmp//ccTFrovn.s:1501   .text:00000454 __vector_9
/var/tmp//ccTFrovn.s:1561   .text:000004ae __vector_5
/var/tmp//ccTFrovn.s:1634   .text:0000052e __vector_10
/var/tmp//ccTFrovn.s:1694   .text:00000588 __vector_7
/var/tmp//ccTFrovn.s:1754   .text:000005e2 __vector_8
/var/tmp//ccTFrovn.s:1814   .text:0000063c __vector_6
/var/tmp//ccTFrovn.s:1874   .text:00000696 __vector_4
/var/tmp//ccTFrovn.s:1934   .text:000006f0 servoInit
/var/tmp//ccTFrovn.s:2260   .text:00000836 servoService
                            *COM*:00000014 ServoChannels
                            *COM*:00000002 ServoPosTics
                            *COM*:00000002 ServoPeriodTics
/var/tmp//ccTFrovn.s:2044   .text:00000772 servoOff
/var/tmp//ccTFrovn.s:2071   .text:00000780 servoSetChannelIO
/var/tmp//ccTFrovn.s:2113   .text:000007ac servoSetPositionRaw
/var/tmp//ccTFrovn.s:2160   .text:000007d6 servoSetPosition
/var/tmp//ccTFrovn.s:2193   .text:000007f6 servoGetPositionRaw
/var/tmp//ccTFrovn.s:2223   .text:0000080c servoGetPosition
                            *COM*:00000001 ServoChannel
/var/tmp//ccTFrovn.s:2406   .text:00000914 __vector_11
/var/tmp//ccTFrovn.s:2440   .text:00000926 myputs
/var/tmp//ccTFrovn.s:2482   .text:0000094e myputs_P
/var/tmp//ccTFrovn.s:2550   .progmem.data:0000005b __c.20
/var/tmp//ccTFrovn.s:2616   .progmem.data:0000005d __c.18
/var/tmp//ccTFrovn.s:2620   .progmem.data:00000062 __c.19
/var/tmp//ccTFrovn.s:2760   .progmem.data:00000067 __c.16
/var/tmp//ccTFrovn.s:2764   .progmem.data:0000006c __c.17
/var/tmp//ccTFrovn.s:2893   .progmem.data:00000071 __c.14
/var/tmp//ccTFrovn.s:2897   .progmem.data:00000076 __c.15
/var/tmp//ccTFrovn.s:3026   .progmem.data:0000007b __c.8
/var/tmp//ccTFrovn.s:3030   .progmem.data:00000087 __c.9
/var/tmp//ccTFrovn.s:3034   .progmem.data:00000093 __c.10
/var/tmp//ccTFrovn.s:3038   .progmem.data:00000098 __c.11
/var/tmp//ccTFrovn.s:3042   .progmem.data:000000a4 __c.12
/var/tmp//ccTFrovn.s:3046   .progmem.data:000000b0 __c.13
/var/tmp//ccTFrovn.s:3263   .progmem.data:000000b5 __c.6
/var/tmp//ccTFrovn.s:3267   .progmem.data:000000ba __c.7
/var/tmp//ccTFrovn.s:3382   .progmem.data:000000bf __c.2
/var/tmp//ccTFrovn.s:3386   .progmem.data:000000c4 __c.3
/var/tmp//ccTFrovn.s:3390   .progmem.data:000000c9 __c.4
/var/tmp//ccTFrovn.s:3394   .progmem.data:000000ce __c.5
/var/tmp//ccTFrovn.s:3650   .progmem.data:000000d3 __c.0
/var/tmp//ccTFrovn.s:3654   .progmem.data:000000e8 __c.1
/var/tmp//ccTFrovn.s:3744   .text:00001000 main
/var/tmp//ccTFrovn.s:3929   .text:00001106 setLeftServo
/var/tmp//ccTFrovn.s:3987   .text:0000115e setRightServo
/var/tmp//ccTFrovn.s:4045   .text:000011b6 setThrottleServo
/var/tmp//ccTFrovn.s:4103   .text:0000120e setCamPanServo
/var/tmp//ccTFrovn.s:4161   .text:00001266 setCamTiltServo
                            *COM*:00000002 rightServoPos
                            *COM*:00000002 throttleServoPos
                            *COM*:00000002 camPanServoPos
                            *COM*:00000002 camTiltServoPos
/var/tmp//ccTFrovn.s:4300   .text:000012be Letext

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
strcpy
atoi
__udivmodhi4
__divmodsi4
__mulsi3
__udivmodsi4
IntProlog
AvrXTimerHandler
Epilog
printf_P
__iob
fputc
AvrXDelay
__divmodhi4
fgetc
__stack
AvrXSetKernelStack
InitSerial0
get_c0
put_char0
fdevopen
AvrXRunTask
exit
printf
